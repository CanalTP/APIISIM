#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Sep  5 10:36:39 2014 by generateDS.py version 2.7b.
#
# Command line options:
#   ('-o', 'mis_collect_stops.py')
#
# Command line arguments:
#   MisCollectStops.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -o "mis_collect_stops.py" MisCollectStops.xsd
#
# Current working directory (os.getcwd()):
#   XSD-APII-SIM-V1.5
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class AbstractRequestType(GeneratedsSuper):
    """Structure générique des requêtes des services fournis sur les
    SIMIdentifiant de la structure de requête. Cet identifiant est
    fourni par le client du service. L'identifiant est rappelé dans
    la ou les réponses du service (sous forme d'élément
    RequestId)."""
    subclass = None
    superclass = None
    def __init__(self, id=None):
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if AbstractRequestType.subclass:
            return AbstractRequestType.subclass(*args_, **kwargs_)
        else:
            return AbstractRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='AbstractRequestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractRequestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractRequestType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractRequestType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractRequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractRequestType


class AbstractResponseType(GeneratedsSuper):
    """Structure générique des réponses des services fournis sur les SIM"""
    subclass = None
    superclass = None
    def __init__(self, RequestId=None, ResponseDefaults=None, extensiontype_=None):
        self.RequestId = RequestId
        self.ResponseDefaults = ResponseDefaults
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractResponseType.subclass:
            return AbstractResponseType.subclass(*args_, **kwargs_)
        else:
            return AbstractResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RequestId(self): return self.RequestId
    def set_RequestId(self, RequestId): self.RequestId = RequestId
    def get_ResponseDefaults(self): return self.ResponseDefaults
    def set_ResponseDefaults(self, ResponseDefaults): self.ResponseDefaults = ResponseDefaults
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractResponseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractResponseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractResponseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractResponseType', fromsubclass_=False):
        if self.RequestId is not None:
            showIndent(outfile, level)
            outfile.write('<%sRequestId>%s</%sRequestId>\n' % (namespace_, self.gds_format_string(quote_xml(self.RequestId).encode(ExternalEncoding), input_name='RequestId'), namespace_))
        if self.ResponseDefaults is not None:
            self.ResponseDefaults.export(outfile, level, namespace_, name_='ResponseDefaults')
    def hasContent_(self):
        if (
            self.RequestId is not None or
            self.ResponseDefaults is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RequestId is not None:
            showIndent(outfile, level)
            outfile.write('RequestId=%s,\n' % quote_python(self.RequestId).encode(ExternalEncoding))
        if self.ResponseDefaults is not None:
            showIndent(outfile, level)
            outfile.write('ResponseDefaults=model_.ServiceDefaultsType(\n')
            self.ResponseDefaults.exportLiteral(outfile, level, name_='ResponseDefaults')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RequestId':
            RequestId_ = child_.text
            RequestId_ = self.gds_validate_string(RequestId_, node, 'RequestId')
            self.RequestId = RequestId_
        elif nodeName_ == 'ResponseDefaults':
            obj_ = ServiceDefaultsType.factory()
            obj_.build(child_)
            self.set_ResponseDefaults(obj_)
# end class AbstractResponseType


class ServiceDefaultsType(GeneratedsSuper):
    """Paramètres par défaut utilisés dans les structures de réponses
    des différents services"""
    subclass = None
    superclass = None
    def __init__(self, DefaultLocale=None, DefaultLocationSystem=None, DefaultSystemOfUnits='SiMetres', geographicOverviewFormats=None):
        self.DefaultLocale = DefaultLocale
        self.DefaultLocationSystem = DefaultLocationSystem
        self.DefaultSystemOfUnits = DefaultSystemOfUnits
        self.geographicOverviewFormats = geographicOverviewFormats
    def factory(*args_, **kwargs_):
        if ServiceDefaultsType.subclass:
            return ServiceDefaultsType.subclass(*args_, **kwargs_)
        else:
            return ServiceDefaultsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultLocale(self): return self.DefaultLocale
    def set_DefaultLocale(self, DefaultLocale): self.DefaultLocale = DefaultLocale
    def get_DefaultLocationSystem(self): return self.DefaultLocationSystem
    def set_DefaultLocationSystem(self, DefaultLocationSystem): self.DefaultLocationSystem = DefaultLocationSystem
    def get_DefaultSystemOfUnits(self): return self.DefaultSystemOfUnits
    def set_DefaultSystemOfUnits(self, DefaultSystemOfUnits): self.DefaultSystemOfUnits = DefaultSystemOfUnits
    def validate_SystemOfUnits(self, value):
        # Validate type SystemOfUnits, a restriction on xs:normalizedString.
        pass
    def get_geographicOverviewFormats(self): return self.geographicOverviewFormats
    def set_geographicOverviewFormats(self, geographicOverviewFormats): self.geographicOverviewFormats = geographicOverviewFormats
    def export(self, outfile, level, namespace_='', name_='ServiceDefaultsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceDefaultsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceDefaultsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceDefaultsType', fromsubclass_=False):
        if self.DefaultLocale is not None:
            self.DefaultLocale.export(outfile, level, namespace_, name_='DefaultLocale')
        if self.DefaultLocationSystem is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefaultLocationSystem>%s</%sDefaultLocationSystem>\n' % (namespace_, self.gds_format_string(quote_xml(self.DefaultLocationSystem).encode(ExternalEncoding), input_name='DefaultLocationSystem'), namespace_))
        if self.DefaultSystemOfUnits is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefaultSystemOfUnits>%s</%sDefaultSystemOfUnits>\n' % (namespace_, self.gds_format_string(quote_xml(self.DefaultSystemOfUnits).encode(ExternalEncoding), input_name='DefaultSystemOfUnits'), namespace_))
        if self.geographicOverviewFormats is not None:
            self.geographicOverviewFormats.export(outfile, level, namespace_, name_='geographicOverviewFormats')
    def hasContent_(self):
        if (
            self.DefaultLocale is not None or
            self.DefaultLocationSystem is not None or
            self.DefaultSystemOfUnits is not None or
            self.geographicOverviewFormats is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceDefaultsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DefaultLocale is not None:
            showIndent(outfile, level)
            outfile.write('DefaultLocale=model_.DefaultLocaleType(\n')
            self.DefaultLocale.exportLiteral(outfile, level, name_='DefaultLocale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefaultLocationSystem is not None:
            showIndent(outfile, level)
            outfile.write('DefaultLocationSystem=%s,\n' % quote_python(self.DefaultLocationSystem).encode(ExternalEncoding))
        if self.DefaultSystemOfUnits is not None:
            showIndent(outfile, level)
            outfile.write('DefaultSystemOfUnits=%s,\n' % quote_python(self.DefaultSystemOfUnits).encode(ExternalEncoding))
        if self.geographicOverviewFormats is not None:
            showIndent(outfile, level)
            outfile.write('geographicOverviewFormats=model_.geographicOverviewFormatsType(\n')
            self.geographicOverviewFormats.exportLiteral(outfile, level, name_='geographicOverviewFormats')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultLocale':
            obj_ = DefaultLocaleType.factory()
            obj_.build(child_)
            self.set_DefaultLocale(obj_)
        elif nodeName_ == 'DefaultLocationSystem':
            DefaultLocationSystem_ = child_.text
            DefaultLocationSystem_ = self.gds_validate_string(DefaultLocationSystem_, node, 'DefaultLocationSystem')
            self.DefaultLocationSystem = DefaultLocationSystem_
        elif nodeName_ == 'DefaultSystemOfUnits':
            DefaultSystemOfUnits_ = child_.text
            DefaultSystemOfUnits_ = self.gds_validate_string(DefaultSystemOfUnits_, node, 'DefaultSystemOfUnits')
            self.DefaultSystemOfUnits = DefaultSystemOfUnits_
            self.validate_SystemOfUnits(self.DefaultSystemOfUnits)    # validate type SystemOfUnits
        elif nodeName_ == 'geographicOverviewFormats':
            obj_ = geographicOverviewFormatsType.factory()
            obj_.build(child_)
            self.set_geographicOverviewFormats(obj_)
# end class ServiceDefaultsType


class PublicationDeliveryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, dataObjects=None):
        self.version = _cast(None, version)
        self.dataObjects = dataObjects
    def factory(*args_, **kwargs_):
        if PublicationDeliveryType.subclass:
            return PublicationDeliveryType.subclass(*args_, **kwargs_)
        else:
            return PublicationDeliveryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataObjects(self): return self.dataObjects
    def set_dataObjects(self, dataObjects): self.dataObjects = dataObjects
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='', name_='PublicationDeliveryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PublicationDeliveryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PublicationDeliveryType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PublicationDeliveryType', fromsubclass_=False):
        if self.dataObjects is not None:
            self.dataObjects.export(outfile, level, namespace_, name_='dataObjects', )
    def hasContent_(self):
        if (
            self.dataObjects is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PublicationDeliveryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dataObjects is not None:
            showIndent(outfile, level)
            outfile.write('dataObjects=model_.dataObjectsType(\n')
            self.dataObjects.exportLiteral(outfile, level, name_='dataObjects')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataObjects':
            obj_ = dataObjectsType.factory()
            obj_.build(child_)
            self.set_dataObjects(obj_)
# end class PublicationDeliveryType


class QuayType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, id=None, Name=None, Description=None, PrivateCode=None, Centroid=None, PostalAddress=None, TransportMode=None, QuayType=None):
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.Name = Name
        self.Description = Description
        self.PrivateCode = PrivateCode
        self.Centroid = Centroid
        self.PostalAddress = PostalAddress
        self.TransportMode = TransportMode
        self.QuayType = QuayType
    def factory(*args_, **kwargs_):
        if QuayType.subclass:
            return QuayType.subclass(*args_, **kwargs_)
        else:
            return QuayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_PrivateCode(self): return self.PrivateCode
    def set_PrivateCode(self, PrivateCode): self.PrivateCode = PrivateCode
    def get_Centroid(self): return self.Centroid
    def set_Centroid(self, Centroid): self.Centroid = Centroid
    def get_PostalAddress(self): return self.PostalAddress
    def set_PostalAddress(self, PostalAddress): self.PostalAddress = PostalAddress
    def get_TransportMode(self): return self.TransportMode
    def set_TransportMode(self, TransportMode): self.TransportMode = TransportMode
    def validate_VehicleModeEnumeration(self, value):
        # Validate type VehicleModeEnumeration, a restriction on xs:NMTOKEN.
        pass
    def get_QuayType(self): return self.QuayType
    def set_QuayType(self, QuayType): self.QuayType = QuayType
    def validate_QuayTypeEnumeration(self, value):
        # Validate type QuayTypeEnumeration, a restriction on xs:string.
        pass
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='QuayType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuayType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuayType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuayType', fromsubclass_=False):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.PrivateCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sPrivateCode>%s</%sPrivateCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.PrivateCode).encode(ExternalEncoding), input_name='PrivateCode'), namespace_))
        if self.Centroid is not None:
            self.Centroid.export(outfile, level, namespace_, name_='Centroid', )
        if self.PostalAddress is not None:
            self.PostalAddress.export(outfile, level, namespace_, name_='PostalAddress')
        if self.TransportMode is not None:
            showIndent(outfile, level)
            outfile.write('<%sTransportMode>%s</%sTransportMode>\n' % (namespace_, self.gds_format_string(quote_xml(self.TransportMode).encode(ExternalEncoding), input_name='TransportMode'), namespace_))
        if self.QuayType is not None:
            showIndent(outfile, level)
            outfile.write('<%sQuayType>%s</%sQuayType>\n' % (namespace_, self.gds_format_string(quote_xml(self.QuayType).encode(ExternalEncoding), input_name='QuayType'), namespace_))
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.PrivateCode is not None or
            self.Centroid is not None or
            self.PostalAddress is not None or
            self.TransportMode is not None or
            self.QuayType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QuayType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.PrivateCode is not None:
            showIndent(outfile, level)
            outfile.write('PrivateCode=%s,\n' % quote_python(self.PrivateCode).encode(ExternalEncoding))
        if self.Centroid is not None:
            showIndent(outfile, level)
            outfile.write('Centroid=model_.CentroidType(\n')
            self.Centroid.exportLiteral(outfile, level, name_='Centroid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PostalAddress is not None:
            showIndent(outfile, level)
            outfile.write('PostalAddress=model_.PostalAddressType(\n')
            self.PostalAddress.exportLiteral(outfile, level, name_='PostalAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TransportMode is not None:
            showIndent(outfile, level)
            outfile.write('TransportMode=%s,\n' % quote_python(self.TransportMode).encode(ExternalEncoding))
        if self.QuayType is not None:
            showIndent(outfile, level)
            outfile.write('QuayType=%s,\n' % quote_python(self.QuayType).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'PrivateCode':
            PrivateCode_ = child_.text
            PrivateCode_ = self.gds_validate_string(PrivateCode_, node, 'PrivateCode')
            self.PrivateCode = PrivateCode_
        elif nodeName_ == 'Centroid':
            obj_ = CentroidType.factory()
            obj_.build(child_)
            self.set_Centroid(obj_)
        elif nodeName_ == 'PostalAddress':
            obj_ = PostalAddressType.factory()
            obj_.build(child_)
            self.set_PostalAddress(obj_)
        elif nodeName_ == 'TransportMode':
            TransportMode_ = child_.text
            TransportMode_ = self.gds_validate_string(TransportMode_, node, 'TransportMode')
            self.TransportMode = TransportMode_
            self.validate_VehicleModeEnumeration(self.TransportMode)    # validate type VehicleModeEnumeration
        elif nodeName_ == 'QuayType':
            QuayType_ = child_.text
            QuayType_ = self.gds_validate_string(QuayType_, node, 'QuayType')
            self.QuayType = QuayType_
            self.validate_QuayTypeEnumeration(self.QuayType)    # validate type QuayTypeEnumeration
# end class QuayType


class LocationStructure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Longitude=None, Latitude=None, pos=None):
        self.Longitude = Longitude
        self.Latitude = Latitude
        self.pos = pos
    def factory(*args_, **kwargs_):
        if LocationStructure.subclass:
            return LocationStructure.subclass(*args_, **kwargs_)
        else:
            return LocationStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Longitude(self): return self.Longitude
    def set_Longitude(self, Longitude): self.Longitude = Longitude
    def get_Latitude(self): return self.Latitude
    def set_Latitude(self, Latitude): self.Latitude = Latitude
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def export(self, outfile, level, namespace_='', name_='LocationStructure', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationStructure')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationStructure'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationStructure', fromsubclass_=False):
        if self.Longitude is not None:
            showIndent(outfile, level)
            outfile.write('<%sLongitude>%s</%sLongitude>\n' % (namespace_, self.gds_format_string(quote_xml(self.Longitude).encode(ExternalEncoding), input_name='Longitude'), namespace_))
        if self.Latitude is not None:
            showIndent(outfile, level)
            outfile.write('<%sLatitude>%s</%sLatitude>\n' % (namespace_, self.gds_format_string(quote_xml(self.Latitude).encode(ExternalEncoding), input_name='Latitude'), namespace_))
        if self.pos is not None:
            self.pos.export(outfile, level, namespace_, name_='pos')
    def hasContent_(self):
        if (
            self.Longitude is not None or
            self.Latitude is not None or
            self.pos is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationStructure'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Longitude is not None:
            showIndent(outfile, level)
            outfile.write('Longitude=%s,\n' % quote_python(self.Longitude).encode(ExternalEncoding))
        if self.Latitude is not None:
            showIndent(outfile, level)
            outfile.write('Latitude=%s,\n' % quote_python(self.Latitude).encode(ExternalEncoding))
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=model_.pos(\n')
            self.pos.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Longitude':
            Longitude_ = child_.text
            Longitude_ = self.gds_validate_string(Longitude_, node, 'Longitude')
            self.Longitude = Longitude_
        elif nodeName_ == 'Latitude':
            Latitude_ = child_.text
            Latitude_ = self.gds_validate_string(Latitude_, node, 'Latitude')
            self.Latitude = Latitude_
        elif nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_pos(obj_)
# end class LocationStructure


class Longitude(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Longitude.subclass:
            return Longitude.subclass(*args_, **kwargs_)
        else:
            return Longitude(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Longitude', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Longitude')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Longitude'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Longitude', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Longitude'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Longitude


class Latitude(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Latitude.subclass:
            return Latitude.subclass(*args_, **kwargs_)
        else:
            return Latitude(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Latitude', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Latitude')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Latitude'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Latitude', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Latitude'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Latitude


class HistoryPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractTimeSlice=None):
        self.owns = _cast(None, owns)
        if AbstractTimeSlice is None:
            self.AbstractTimeSlice = []
        else:
            self.AbstractTimeSlice = AbstractTimeSlice
    def factory(*args_, **kwargs_):
        if HistoryPropertyType.subclass:
            return HistoryPropertyType.subclass(*args_, **kwargs_)
        else:
            return HistoryPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTimeSlice(self): return self.AbstractTimeSlice
    def set_AbstractTimeSlice(self, AbstractTimeSlice): self.AbstractTimeSlice = AbstractTimeSlice
    def add_AbstractTimeSlice(self, value): self.AbstractTimeSlice.append(value)
    def insert_AbstractTimeSlice(self, index, value): self.AbstractTimeSlice[index] = value
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='HistoryPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoryPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HistoryPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HistoryPropertyType', fromsubclass_=False):
        for AbstractTimeSlice_ in self.get_AbstractTimeSlice():
            AbstractTimeSlice_.export(outfile, level, namespace_, name_='AbstractTimeSlice')
    def hasContent_(self):
        if (
            self.AbstractTimeSlice
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HistoryPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AbstractTimeSlice=[\n')
        level += 1
        for AbstractTimeSlice_ in self.AbstractTimeSlice:
            showIndent(outfile, level)
            outfile.write('model_.AbstractTimeSlice(\n')
            AbstractTimeSlice_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTimeSlice':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimeSlice> element')
            self.AbstractTimeSlice.append(obj_)
# end class HistoryPropertyType


class NodeOrEdgePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', Node=None, Edge=None):
        self.owns = _cast(None, owns)
        self.Node = Node
        self.Edge = Edge
    def factory(*args_, **kwargs_):
        if NodeOrEdgePropertyType.subclass:
            return NodeOrEdgePropertyType.subclass(*args_, **kwargs_)
        else:
            return NodeOrEdgePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    def get_Edge(self): return self.Edge
    def set_Edge(self, Edge): self.Edge = Edge
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='NodeOrEdgePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeOrEdgePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NodeOrEdgePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NodeOrEdgePropertyType', fromsubclass_=False):
        if self.Node is not None:
            self.Node.export(outfile, level, namespace_, name_='Node')
        if self.Edge is not None:
            self.Edge.export(outfile, level, namespace_, name_='Edge')
    def hasContent_(self):
        if (
            self.Node is not None or
            self.Edge is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NodeOrEdgePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Node is not None:
            showIndent(outfile, level)
            outfile.write('Node=model_.Node(\n')
            self.Node.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Edge is not None:
            showIndent(outfile, level)
            outfile.write('Edge=model_.Edge(\n')
            self.Edge.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Node':
            obj_ = NodeType.factory()
            obj_.build(child_)
            self.set_Node(obj_)
        elif nodeName_ == 'Edge':
            obj_ = EdgeType.factory()
            obj_.build(child_)
            self.set_Edge(obj_)
# end class NodeOrEdgePropertyType


class NodePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', Node=None):
        self.owns = _cast(None, owns)
        self.Node = Node
    def factory(*args_, **kwargs_):
        if NodePropertyType.subclass:
            return NodePropertyType.subclass(*args_, **kwargs_)
        else:
            return NodePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='NodePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NodePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NodePropertyType', fromsubclass_=False):
        if self.Node is not None:
            self.Node.export(outfile, level, namespace_, name_='Node')
    def hasContent_(self):
        if (
            self.Node is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NodePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Node is not None:
            showIndent(outfile, level)
            outfile.write('Node=model_.Node(\n')
            self.Node.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Node':
            obj_ = NodeType.factory()
            obj_.build(child_)
            self.set_Node(obj_)
# end class NodePropertyType


class FaceOrTopoSolidPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', Face=None, TopoSolid=None):
        self.owns = _cast(None, owns)
        self.Face = Face
        self.TopoSolid = TopoSolid
    def factory(*args_, **kwargs_):
        if FaceOrTopoSolidPropertyType.subclass:
            return FaceOrTopoSolidPropertyType.subclass(*args_, **kwargs_)
        else:
            return FaceOrTopoSolidPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Face(self): return self.Face
    def set_Face(self, Face): self.Face = Face
    def get_TopoSolid(self): return self.TopoSolid
    def set_TopoSolid(self, TopoSolid): self.TopoSolid = TopoSolid
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='FaceOrTopoSolidPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FaceOrTopoSolidPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FaceOrTopoSolidPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FaceOrTopoSolidPropertyType', fromsubclass_=False):
        if self.Face is not None:
            self.Face.export(outfile, level, namespace_, name_='Face')
        if self.TopoSolid is not None:
            self.TopoSolid.export(outfile, level, namespace_, name_='TopoSolid')
    def hasContent_(self):
        if (
            self.Face is not None or
            self.TopoSolid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FaceOrTopoSolidPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Face is not None:
            showIndent(outfile, level)
            outfile.write('Face=model_.Face(\n')
            self.Face.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TopoSolid is not None:
            showIndent(outfile, level)
            outfile.write('TopoSolid=model_.TopoSolid(\n')
            self.TopoSolid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Face':
            obj_ = FaceType.factory()
            obj_.build(child_)
            self.set_Face(obj_)
        elif nodeName_ == 'TopoSolid':
            obj_ = TopoSolidType.factory()
            obj_.build(child_)
            self.set_TopoSolid(obj_)
# end class FaceOrTopoSolidPropertyType


class TopoSolidPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', TopoSolid=None):
        self.owns = _cast(None, owns)
        self.TopoSolid = TopoSolid
    def factory(*args_, **kwargs_):
        if TopoSolidPropertyType.subclass:
            return TopoSolidPropertyType.subclass(*args_, **kwargs_)
        else:
            return TopoSolidPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopoSolid(self): return self.TopoSolid
    def set_TopoSolid(self, TopoSolid): self.TopoSolid = TopoSolid
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TopoSolidPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoSolidPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoSolidPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoSolidPropertyType', fromsubclass_=False):
        if self.TopoSolid is not None:
            self.TopoSolid.export(outfile, level, namespace_, name_='TopoSolid')
    def hasContent_(self):
        if (
            self.TopoSolid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoSolidPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopoSolid is not None:
            showIndent(outfile, level)
            outfile.write('TopoSolid=model_.TopoSolid(\n')
            self.TopoSolid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopoSolid':
            obj_ = TopoSolidType.factory()
            obj_.build(child_)
            self.set_TopoSolid(obj_)
# end class TopoSolidPropertyType


class DirectedNodePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orientation='+', owns='false', Node=None):
        self.orientation = _cast(None, orientation)
        self.owns = _cast(None, owns)
        self.Node = Node
    def factory(*args_, **kwargs_):
        if DirectedNodePropertyType.subclass:
            return DirectedNodePropertyType.subclass(*args_, **kwargs_)
        else:
            return DirectedNodePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='DirectedNodePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedNodePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectedNodePropertyType'):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DirectedNodePropertyType', fromsubclass_=False):
        if self.Node is not None:
            self.Node.export(outfile, level, namespace_, name_='Node', )
    def hasContent_(self):
        if (
            self.Node is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectedNodePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            showIndent(outfile, level)
            outfile.write('orientation = %s,\n' % (self.orientation,))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Node is not None:
            showIndent(outfile, level)
            outfile.write('Node=model_.Node(\n')
            self.Node.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            self.orientation = value
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Node':
            obj_ = NodeType.factory()
            obj_.build(child_)
            self.set_Node(obj_)
# end class DirectedNodePropertyType


class DirectedEdgePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orientation='+', owns='false', Edge=None):
        self.orientation = _cast(None, orientation)
        self.owns = _cast(None, owns)
        self.Edge = Edge
    def factory(*args_, **kwargs_):
        if DirectedEdgePropertyType.subclass:
            return DirectedEdgePropertyType.subclass(*args_, **kwargs_)
        else:
            return DirectedEdgePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Edge(self): return self.Edge
    def set_Edge(self, Edge): self.Edge = Edge
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='DirectedEdgePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedEdgePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectedEdgePropertyType'):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DirectedEdgePropertyType', fromsubclass_=False):
        if self.Edge is not None:
            self.Edge.export(outfile, level, namespace_, name_='Edge', )
    def hasContent_(self):
        if (
            self.Edge is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectedEdgePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            showIndent(outfile, level)
            outfile.write('orientation = %s,\n' % (self.orientation,))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Edge is not None:
            showIndent(outfile, level)
            outfile.write('Edge=model_.Edge(\n')
            self.Edge.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            self.orientation = value
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Edge':
            obj_ = EdgeType.factory()
            obj_.build(child_)
            self.set_Edge(obj_)
# end class DirectedEdgePropertyType


class DirectedFacePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orientation='+', owns='false', Face=None):
        self.orientation = _cast(None, orientation)
        self.owns = _cast(None, owns)
        self.Face = Face
    def factory(*args_, **kwargs_):
        if DirectedFacePropertyType.subclass:
            return DirectedFacePropertyType.subclass(*args_, **kwargs_)
        else:
            return DirectedFacePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Face(self): return self.Face
    def set_Face(self, Face): self.Face = Face
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='DirectedFacePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedFacePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectedFacePropertyType'):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DirectedFacePropertyType', fromsubclass_=False):
        if self.Face is not None:
            self.Face.export(outfile, level, namespace_, name_='Face', )
    def hasContent_(self):
        if (
            self.Face is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectedFacePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            showIndent(outfile, level)
            outfile.write('orientation = %s,\n' % (self.orientation,))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Face is not None:
            showIndent(outfile, level)
            outfile.write('Face=model_.Face(\n')
            self.Face.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            self.orientation = value
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Face':
            obj_ = FaceType.factory()
            obj_.build(child_)
            self.set_Face(obj_)
# end class DirectedFacePropertyType


class DirectedTopoSolidPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orientation='+', owns='false', TopoSolid=None):
        self.orientation = _cast(None, orientation)
        self.owns = _cast(None, owns)
        self.TopoSolid = TopoSolid
    def factory(*args_, **kwargs_):
        if DirectedTopoSolidPropertyType.subclass:
            return DirectedTopoSolidPropertyType.subclass(*args_, **kwargs_)
        else:
            return DirectedTopoSolidPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopoSolid(self): return self.TopoSolid
    def set_TopoSolid(self, TopoSolid): self.TopoSolid = TopoSolid
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='DirectedTopoSolidPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedTopoSolidPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectedTopoSolidPropertyType'):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DirectedTopoSolidPropertyType', fromsubclass_=False):
        if self.TopoSolid is not None:
            self.TopoSolid.export(outfile, level, namespace_, name_='TopoSolid', )
    def hasContent_(self):
        if (
            self.TopoSolid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectedTopoSolidPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            showIndent(outfile, level)
            outfile.write('orientation = %s,\n' % (self.orientation,))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopoSolid is not None:
            showIndent(outfile, level)
            outfile.write('TopoSolid=model_.TopoSolid(\n')
            self.TopoSolid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            self.orientation = value
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopoSolid':
            obj_ = TopoSolidType.factory()
            obj_.build(child_)
            self.set_TopoSolid(obj_)
# end class DirectedTopoSolidPropertyType


class TopoPointPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', TopoPoint=None):
        self.owns = _cast(None, owns)
        self.TopoPoint = TopoPoint
    def factory(*args_, **kwargs_):
        if TopoPointPropertyType.subclass:
            return TopoPointPropertyType.subclass(*args_, **kwargs_)
        else:
            return TopoPointPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopoPoint(self): return self.TopoPoint
    def set_TopoPoint(self, TopoPoint): self.TopoPoint = TopoPoint
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TopoPointPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoPointPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoPointPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoPointPropertyType', fromsubclass_=False):
        if self.TopoPoint is not None:
            self.TopoPoint.export(outfile, level, namespace_, name_='TopoPoint', )
    def hasContent_(self):
        if (
            self.TopoPoint is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoPointPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopoPoint is not None:
            showIndent(outfile, level)
            outfile.write('TopoPoint=model_.TopoPoint(\n')
            self.TopoPoint.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopoPoint':
            obj_ = TopoPointType.factory()
            obj_.build(child_)
            self.set_TopoPoint(obj_)
# end class TopoPointPropertyType


class TopoCurvePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', TopoCurve=None):
        self.owns = _cast(None, owns)
        self.TopoCurve = TopoCurve
    def factory(*args_, **kwargs_):
        if TopoCurvePropertyType.subclass:
            return TopoCurvePropertyType.subclass(*args_, **kwargs_)
        else:
            return TopoCurvePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopoCurve(self): return self.TopoCurve
    def set_TopoCurve(self, TopoCurve): self.TopoCurve = TopoCurve
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TopoCurvePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoCurvePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoCurvePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoCurvePropertyType', fromsubclass_=False):
        if self.TopoCurve is not None:
            self.TopoCurve.export(outfile, level, namespace_, name_='TopoCurve', )
    def hasContent_(self):
        if (
            self.TopoCurve is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoCurvePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopoCurve is not None:
            showIndent(outfile, level)
            outfile.write('TopoCurve=model_.TopoCurve(\n')
            self.TopoCurve.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopoCurve':
            obj_ = TopoCurveType.factory()
            obj_.build(child_)
            self.set_TopoCurve(obj_)
# end class TopoCurvePropertyType


class TopoSurfacePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', TopoSurface=None):
        self.owns = _cast(None, owns)
        self.TopoSurface = TopoSurface
    def factory(*args_, **kwargs_):
        if TopoSurfacePropertyType.subclass:
            return TopoSurfacePropertyType.subclass(*args_, **kwargs_)
        else:
            return TopoSurfacePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopoSurface(self): return self.TopoSurface
    def set_TopoSurface(self, TopoSurface): self.TopoSurface = TopoSurface
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TopoSurfacePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoSurfacePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoSurfacePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoSurfacePropertyType', fromsubclass_=False):
        if self.TopoSurface is not None:
            self.TopoSurface.export(outfile, level, namespace_, name_='TopoSurface', )
    def hasContent_(self):
        if (
            self.TopoSurface is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoSurfacePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopoSurface is not None:
            showIndent(outfile, level)
            outfile.write('TopoSurface=model_.TopoSurface(\n')
            self.TopoSurface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopoSurface':
            obj_ = TopoSurfaceType.factory()
            obj_.build(child_)
            self.set_TopoSurface(obj_)
# end class TopoSurfacePropertyType


class TopoVolumePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', TopoVolume=None):
        self.owns = _cast(None, owns)
        self.TopoVolume = TopoVolume
    def factory(*args_, **kwargs_):
        if TopoVolumePropertyType.subclass:
            return TopoVolumePropertyType.subclass(*args_, **kwargs_)
        else:
            return TopoVolumePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopoVolume(self): return self.TopoVolume
    def set_TopoVolume(self, TopoVolume): self.TopoVolume = TopoVolume
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TopoVolumePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoVolumePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoVolumePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoVolumePropertyType', fromsubclass_=False):
        if self.TopoVolume is not None:
            self.TopoVolume.export(outfile, level, namespace_, name_='TopoVolume', )
    def hasContent_(self):
        if (
            self.TopoVolume is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoVolumePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopoVolume is not None:
            showIndent(outfile, level)
            outfile.write('TopoVolume=model_.TopoVolume(\n')
            self.TopoVolume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopoVolume':
            obj_ = TopoVolumeType.factory()
            obj_.build(child_)
            self.set_TopoVolume(obj_)
# end class TopoVolumePropertyType


class TopoPrimitiveMemberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractTopoPrimitive=None):
        self.owns = _cast(None, owns)
        self.AbstractTopoPrimitive = AbstractTopoPrimitive
    def factory(*args_, **kwargs_):
        if TopoPrimitiveMemberType.subclass:
            return TopoPrimitiveMemberType.subclass(*args_, **kwargs_)
        else:
            return TopoPrimitiveMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTopoPrimitive(self): return self.AbstractTopoPrimitive
    def set_AbstractTopoPrimitive(self, AbstractTopoPrimitive): self.AbstractTopoPrimitive = AbstractTopoPrimitive
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TopoPrimitiveMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoPrimitiveMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoPrimitiveMemberType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoPrimitiveMemberType', fromsubclass_=False):
        if self.AbstractTopoPrimitive is not None:
            self.AbstractTopoPrimitive.export(outfile, level, namespace_, name_='AbstractTopoPrimitive')
    def hasContent_(self):
        if (
            self.AbstractTopoPrimitive is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoPrimitiveMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractTopoPrimitive is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTopoPrimitive=model_.AbstractTopoPrimitive(\n')
            self.AbstractTopoPrimitive.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTopoPrimitive':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTopoPrimitive> element')
            self.set_AbstractTopoPrimitive(obj_)
# end class TopoPrimitiveMemberType


class TopoPrimitiveArrayAssociationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractTopoPrimitive=None):
        self.owns = _cast(None, owns)
        self.AbstractTopoPrimitive = AbstractTopoPrimitive
    def factory(*args_, **kwargs_):
        if TopoPrimitiveArrayAssociationType.subclass:
            return TopoPrimitiveArrayAssociationType.subclass(*args_, **kwargs_)
        else:
            return TopoPrimitiveArrayAssociationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTopoPrimitive(self): return self.AbstractTopoPrimitive
    def set_AbstractTopoPrimitive(self, AbstractTopoPrimitive): self.AbstractTopoPrimitive = AbstractTopoPrimitive
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TopoPrimitiveArrayAssociationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoPrimitiveArrayAssociationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoPrimitiveArrayAssociationType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoPrimitiveArrayAssociationType', fromsubclass_=False):
        if self.AbstractTopoPrimitive is not None:
            self.AbstractTopoPrimitive.export(outfile, level, namespace_, name_='AbstractTopoPrimitive')
    def hasContent_(self):
        if (
            self.AbstractTopoPrimitive is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoPrimitiveArrayAssociationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractTopoPrimitive is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTopoPrimitive=model_.AbstractTopoPrimitive(\n')
            self.AbstractTopoPrimitive.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTopoPrimitive':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTopoPrimitive> element')
            self.set_AbstractTopoPrimitive(obj_)
# end class TopoPrimitiveArrayAssociationType


class TopoComplexPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TopoComplex=None):
        self.TopoComplex = TopoComplex
    def factory(*args_, **kwargs_):
        if TopoComplexPropertyType.subclass:
            return TopoComplexPropertyType.subclass(*args_, **kwargs_)
        else:
            return TopoComplexPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopoComplex(self): return self.TopoComplex
    def set_TopoComplex(self, TopoComplex): self.TopoComplex = TopoComplex
    def export(self, outfile, level, namespace_='', name_='TopoComplexPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoComplexPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoComplexPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TopoComplexPropertyType', fromsubclass_=False):
        if self.TopoComplex is not None:
            self.TopoComplex.export(outfile, level, namespace_, name_='TopoComplex', )
    def hasContent_(self):
        if (
            self.TopoComplex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoComplexPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopoComplex is not None:
            showIndent(outfile, level)
            outfile.write('TopoComplex=model_.TopoComplex(\n')
            self.TopoComplex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopoComplex':
            obj_ = TopoComplexType.factory()
            obj_.build(child_)
            self.set_TopoComplex(obj_)
# end class TopoComplexPropertyType


class GeometricComplexPropertyType(GeneratedsSuper):
    """A property that has a geometric complex as its value domain may
    either be an appropriate geometry element encapsulated in an
    element of this type or an XLink reference to a remote geometry
    element (where remote includes geometry elements located
    elsewhere in the same document). Either the reference or the
    contained element shall be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', GeometricComplex=None, CompositeCurve=None, CompositeSurface=None, CompositeSolid=None):
        self.owns = _cast(None, owns)
        self.GeometricComplex = GeometricComplex
        self.CompositeCurve = CompositeCurve
        self.CompositeSurface = CompositeSurface
        self.CompositeSolid = CompositeSolid
    def factory(*args_, **kwargs_):
        if GeometricComplexPropertyType.subclass:
            return GeometricComplexPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeometricComplexPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeometricComplex(self): return self.GeometricComplex
    def set_GeometricComplex(self, GeometricComplex): self.GeometricComplex = GeometricComplex
    def get_CompositeCurve(self): return self.CompositeCurve
    def set_CompositeCurve(self, CompositeCurve): self.CompositeCurve = CompositeCurve
    def get_CompositeSurface(self): return self.CompositeSurface
    def set_CompositeSurface(self, CompositeSurface): self.CompositeSurface = CompositeSurface
    def get_CompositeSolid(self): return self.CompositeSolid
    def set_CompositeSolid(self, CompositeSolid): self.CompositeSolid = CompositeSolid
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='GeometricComplexPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeometricComplexPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeometricComplexPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GeometricComplexPropertyType', fromsubclass_=False):
        if self.GeometricComplex is not None:
            self.GeometricComplex.export(outfile, level, namespace_, name_='GeometricComplex', )
        if self.CompositeCurve is not None:
            self.CompositeCurve.export(outfile, level, namespace_, name_='CompositeCurve', )
        if self.CompositeSurface is not None:
            self.CompositeSurface.export(outfile, level, namespace_, name_='CompositeSurface', )
        if self.CompositeSolid is not None:
            self.CompositeSolid.export(outfile, level, namespace_, name_='CompositeSolid', )
    def hasContent_(self):
        if (
            self.GeometricComplex is not None or
            self.CompositeCurve is not None or
            self.CompositeSurface is not None or
            self.CompositeSolid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeometricComplexPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GeometricComplex is not None:
            showIndent(outfile, level)
            outfile.write('GeometricComplex=model_.GeometricComplex(\n')
            self.GeometricComplex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompositeCurve is not None:
            showIndent(outfile, level)
            outfile.write('CompositeCurve=model_.CompositeCurve(\n')
            self.CompositeCurve.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompositeSurface is not None:
            showIndent(outfile, level)
            outfile.write('CompositeSurface=model_.CompositeSurface(\n')
            self.CompositeSurface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompositeSolid is not None:
            showIndent(outfile, level)
            outfile.write('CompositeSolid=model_.CompositeSolid(\n')
            self.CompositeSolid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeometricComplex':
            obj_ = GeometricComplexType.factory()
            obj_.build(child_)
            self.set_GeometricComplex(obj_)
        elif nodeName_ == 'CompositeCurve':
            obj_ = CompositeCurveType.factory()
            obj_.build(child_)
            self.set_CompositeCurve(obj_)
        elif nodeName_ == 'CompositeSurface':
            obj_ = CompositeSurfaceType.factory()
            obj_.build(child_)
            self.set_CompositeSurface(obj_)
        elif nodeName_ == 'CompositeSolid':
            obj_ = CompositeSolidType.factory()
            obj_.build(child_)
            self.set_CompositeSolid(obj_)
# end class GeometricComplexPropertyType


class MultiGeometryPropertyType(GeneratedsSuper):
    """A property that has a geometric aggregate as its value domain may
    either be an appropriate geometry element encapsulated in an
    element of this type or an XLink reference to a remote geometry
    element (where remote includes geometry elements located
    elsewhere in the same document). Either the reference or the
    contained element shall be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractGeometricAggregate=None):
        self.owns = _cast(None, owns)
        self.AbstractGeometricAggregate = AbstractGeometricAggregate
    def factory(*args_, **kwargs_):
        if MultiGeometryPropertyType.subclass:
            return MultiGeometryPropertyType.subclass(*args_, **kwargs_)
        else:
            return MultiGeometryPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeometricAggregate(self): return self.AbstractGeometricAggregate
    def set_AbstractGeometricAggregate(self, AbstractGeometricAggregate): self.AbstractGeometricAggregate = AbstractGeometricAggregate
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='MultiGeometryPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiGeometryPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiGeometryPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultiGeometryPropertyType', fromsubclass_=False):
        if self.AbstractGeometricAggregate is not None:
            self.AbstractGeometricAggregate.export(outfile, level, namespace_, name_='AbstractGeometricAggregate')
    def hasContent_(self):
        if (
            self.AbstractGeometricAggregate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiGeometryPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeometricAggregate is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometricAggregate=model_.AbstractGeometricAggregate(\n')
            self.AbstractGeometricAggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeometricAggregate':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometricAggregate> element')
            self.set_AbstractGeometricAggregate(obj_)
# end class MultiGeometryPropertyType


class MultiPointPropertyType(GeneratedsSuper):
    """A property that has a collection of points as its value domain may
    either be an appropriate geometry element encapsulated in an
    element of this type or an XLink reference to a remote geometry
    element (where remote includes geometry elements located
    elsewhere in the same document). Either the reference or the
    contained element shall be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', MultiPoint=None):
        self.owns = _cast(None, owns)
        self.MultiPoint = MultiPoint
    def factory(*args_, **kwargs_):
        if MultiPointPropertyType.subclass:
            return MultiPointPropertyType.subclass(*args_, **kwargs_)
        else:
            return MultiPointPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MultiPoint(self): return self.MultiPoint
    def set_MultiPoint(self, MultiPoint): self.MultiPoint = MultiPoint
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='MultiPointPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiPointPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiPointPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultiPointPropertyType', fromsubclass_=False):
        if self.MultiPoint is not None:
            self.MultiPoint.export(outfile, level, namespace_, name_='MultiPoint', )
    def hasContent_(self):
        if (
            self.MultiPoint is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiPointPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MultiPoint is not None:
            showIndent(outfile, level)
            outfile.write('MultiPoint=model_.MultiPoint(\n')
            self.MultiPoint.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiPoint':
            obj_ = MultiPointType.factory()
            obj_.build(child_)
            self.set_MultiPoint(obj_)
# end class MultiPointPropertyType


class MultiCurvePropertyType(GeneratedsSuper):
    """A property that has a collection of curves as its value domain may
    either be an appropriate geometry element encapsulated in an
    element of this type or an XLink reference to a remote geometry
    element (where remote includes geometry elements located
    elsewhere in the same document). Either the reference or the
    contained element shall be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', MultiCurve=None):
        self.owns = _cast(None, owns)
        self.MultiCurve = MultiCurve
    def factory(*args_, **kwargs_):
        if MultiCurvePropertyType.subclass:
            return MultiCurvePropertyType.subclass(*args_, **kwargs_)
        else:
            return MultiCurvePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MultiCurve(self): return self.MultiCurve
    def set_MultiCurve(self, MultiCurve): self.MultiCurve = MultiCurve
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='MultiCurvePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiCurvePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiCurvePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultiCurvePropertyType', fromsubclass_=False):
        if self.MultiCurve is not None:
            self.MultiCurve.export(outfile, level, namespace_, name_='MultiCurve', )
    def hasContent_(self):
        if (
            self.MultiCurve is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiCurvePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MultiCurve is not None:
            showIndent(outfile, level)
            outfile.write('MultiCurve=model_.MultiCurve(\n')
            self.MultiCurve.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiCurve':
            obj_ = MultiCurveType.factory()
            obj_.build(child_)
            self.set_MultiCurve(obj_)
# end class MultiCurvePropertyType


class MultiSurfacePropertyType(GeneratedsSuper):
    """A property that has a collection of surfaces as its value domain may
    either be an appropriate geometry element encapsulated in an
    element of this type or an XLink reference to a remote geometry
    element (where remote includes geometry elements located
    elsewhere in the same document). Either the reference or the
    contained element shall be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', MultiSurface=None):
        self.owns = _cast(None, owns)
        self.MultiSurface = MultiSurface
    def factory(*args_, **kwargs_):
        if MultiSurfacePropertyType.subclass:
            return MultiSurfacePropertyType.subclass(*args_, **kwargs_)
        else:
            return MultiSurfacePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MultiSurface(self): return self.MultiSurface
    def set_MultiSurface(self, MultiSurface): self.MultiSurface = MultiSurface
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='MultiSurfacePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiSurfacePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiSurfacePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultiSurfacePropertyType', fromsubclass_=False):
        if self.MultiSurface is not None:
            self.MultiSurface.export(outfile, level, namespace_, name_='MultiSurface', )
    def hasContent_(self):
        if (
            self.MultiSurface is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiSurfacePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MultiSurface is not None:
            showIndent(outfile, level)
            outfile.write('MultiSurface=model_.MultiSurface(\n')
            self.MultiSurface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiSurface':
            obj_ = MultiSurfaceType.factory()
            obj_.build(child_)
            self.set_MultiSurface(obj_)
# end class MultiSurfacePropertyType


class MultiSolidPropertyType(GeneratedsSuper):
    """A property that has a collection of solids as its value domain may
    either be an appropriate geometry element encapsulated in an
    element of this type or an XLink reference to a remote geometry
    element (where remote includes geometry elements located
    elsewhere in the same document). Either the reference or the
    contained element shall be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', MultiSolid=None):
        self.owns = _cast(None, owns)
        self.MultiSolid = MultiSolid
    def factory(*args_, **kwargs_):
        if MultiSolidPropertyType.subclass:
            return MultiSolidPropertyType.subclass(*args_, **kwargs_)
        else:
            return MultiSolidPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MultiSolid(self): return self.MultiSolid
    def set_MultiSolid(self, MultiSolid): self.MultiSolid = MultiSolid
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='MultiSolidPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiSolidPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiSolidPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultiSolidPropertyType', fromsubclass_=False):
        if self.MultiSolid is not None:
            self.MultiSolid.export(outfile, level, namespace_, name_='MultiSolid', )
    def hasContent_(self):
        if (
            self.MultiSolid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiSolidPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MultiSolid is not None:
            showIndent(outfile, level)
            outfile.write('MultiSolid=model_.MultiSolid(\n')
            self.MultiSolid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiSolid':
            obj_ = MultiSolidType.factory()
            obj_.build(child_)
            self.set_MultiSolid(obj_)
# end class MultiSolidPropertyType


class AbstractCurveSegmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', extensiontype_=None):
        self.numDerivativesAtEnd = _cast(None, numDerivativesAtEnd)
        self.numDerivativeInterior = _cast(None, numDerivativeInterior)
        self.numDerivativesAtStart = _cast(None, numDerivativesAtStart)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractCurveSegmentType.subclass:
            return AbstractCurveSegmentType.subclass(*args_, **kwargs_)
        else:
            return AbstractCurveSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numDerivativesAtEnd(self): return self.numDerivativesAtEnd
    def set_numDerivativesAtEnd(self, numDerivativesAtEnd): self.numDerivativesAtEnd = numDerivativesAtEnd
    def get_numDerivativeInterior(self): return self.numDerivativeInterior
    def set_numDerivativeInterior(self, numDerivativeInterior): self.numDerivativeInterior = numDerivativeInterior
    def get_numDerivativesAtStart(self): return self.numDerivativesAtStart
    def set_numDerivativesAtStart(self, numDerivativesAtStart): self.numDerivativesAtStart = numDerivativesAtStart
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractCurveSegmentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCurveSegmentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractCurveSegmentType'):
        if self.numDerivativesAtEnd is not None and 'numDerivativesAtEnd' not in already_processed:
            already_processed.append('numDerivativesAtEnd')
            outfile.write(' numDerivativesAtEnd=%s' % (quote_attrib(self.numDerivativesAtEnd), ))
        if self.numDerivativeInterior is not None and 'numDerivativeInterior' not in already_processed:
            already_processed.append('numDerivativeInterior')
            outfile.write(' numDerivativeInterior=%s' % (quote_attrib(self.numDerivativeInterior), ))
        if self.numDerivativesAtStart is not None and 'numDerivativesAtStart' not in already_processed:
            already_processed.append('numDerivativesAtStart')
            outfile.write(' numDerivativesAtStart=%s' % (quote_attrib(self.numDerivativesAtStart), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCurveSegmentType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCurveSegmentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numDerivativesAtEnd is not None and 'numDerivativesAtEnd' not in already_processed:
            already_processed.append('numDerivativesAtEnd')
            showIndent(outfile, level)
            outfile.write('numDerivativesAtEnd = %s,\n' % (self.numDerivativesAtEnd,))
        if self.numDerivativeInterior is not None and 'numDerivativeInterior' not in already_processed:
            already_processed.append('numDerivativeInterior')
            showIndent(outfile, level)
            outfile.write('numDerivativeInterior = %s,\n' % (self.numDerivativeInterior,))
        if self.numDerivativesAtStart is not None and 'numDerivativesAtStart' not in already_processed:
            already_processed.append('numDerivativesAtStart')
            showIndent(outfile, level)
            outfile.write('numDerivativesAtStart = %s,\n' % (self.numDerivativesAtStart,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numDerivativesAtEnd', node)
        if value is not None and 'numDerivativesAtEnd' not in already_processed:
            already_processed.append('numDerivativesAtEnd')
            self.numDerivativesAtEnd = value
        value = find_attr_value_('numDerivativeInterior', node)
        if value is not None and 'numDerivativeInterior' not in already_processed:
            already_processed.append('numDerivativeInterior')
            self.numDerivativeInterior = value
        value = find_attr_value_('numDerivativesAtStart', node)
        if value is not None and 'numDerivativesAtStart' not in already_processed:
            already_processed.append('numDerivativesAtStart')
            self.numDerivativesAtStart = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractCurveSegmentType


class CurveSegmentArrayPropertyType(GeneratedsSuper):
    """gml:CurveSegmentArrayPropertyType is a container for an array of
    curve segments."""
    subclass = None
    superclass = None
    def __init__(self, AbstractCurveSegment=None):
        self.AbstractCurveSegment = AbstractCurveSegment
    def factory(*args_, **kwargs_):
        if CurveSegmentArrayPropertyType.subclass:
            return CurveSegmentArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return CurveSegmentArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCurveSegment(self): return self.AbstractCurveSegment
    def set_AbstractCurveSegment(self, AbstractCurveSegment): self.AbstractCurveSegment = AbstractCurveSegment
    def export(self, outfile, level, namespace_='', name_='CurveSegmentArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurveSegmentArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurveSegmentArrayPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurveSegmentArrayPropertyType', fromsubclass_=False):
        if self.AbstractCurveSegment is not None:
            self.AbstractCurveSegment.export(outfile, level, namespace_, name_='AbstractCurveSegment')
    def hasContent_(self):
        if (
            self.AbstractCurveSegment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CurveSegmentArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractCurveSegment is not None:
            showIndent(outfile, level)
            outfile.write('AbstractCurveSegment=model_.AbstractCurveSegment(\n')
            self.AbstractCurveSegment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCurveSegment':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCurveSegment> element')
            self.set_AbstractCurveSegment(obj_)
# end class CurveSegmentArrayPropertyType


class LineStringSegmentType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', interpolation=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None):
        super(LineStringSegmentType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.interpolation = _cast(None, interpolation)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
    def factory(*args_, **kwargs_):
        if LineStringSegmentType.subclass:
            return LineStringSegmentType.subclass(*args_, **kwargs_)
        else:
            return LineStringSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='LineStringSegmentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineStringSegmentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineStringSegmentType'):
        super(LineStringSegmentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LineStringSegmentType')
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LineStringSegmentType', fromsubclass_=False):
        super(LineStringSegmentType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            super(LineStringSegmentType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineStringSegmentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(LineStringSegmentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LineStringSegmentType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(LineStringSegmentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        super(LineStringSegmentType, self).buildChildren(child_, node, nodeName_, True)
# end class LineStringSegmentType


class ArcStringType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', numArc=None, interpolation=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None):
        super(ArcStringType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.numArc = _cast(None, numArc)
        self.interpolation = _cast(None, interpolation)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
    def factory(*args_, **kwargs_):
        if ArcStringType.subclass:
            return ArcStringType.subclass(*args_, **kwargs_)
        else:
            return ArcStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_numArc(self): return self.numArc
    def set_numArc(self, numArc): self.numArc = numArc
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='ArcStringType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArcStringType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArcStringType'):
        super(ArcStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ArcStringType')
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            outfile.write(' numArc=%s' % (quote_attrib(self.numArc), ))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArcStringType', fromsubclass_=False):
        super(ArcStringType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            super(ArcStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArcStringType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            showIndent(outfile, level)
            outfile.write('numArc = %s,\n' % (self.numArc,))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(ArcStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ArcStringType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numArc', node)
        if value is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            self.numArc = value
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(ArcStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        super(ArcStringType, self).buildChildren(child_, node, nodeName_, True)
# end class ArcStringType


class ArcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numArc=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, extensiontype_=None):
        self.numArc = _cast(None, numArc)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ArcType.subclass:
            return ArcType.subclass(*args_, **kwargs_)
        else:
            return ArcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_numArc(self): return self.numArc
    def set_numArc(self, numArc): self.numArc = numArc
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ArcType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArcType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArcType'):
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            outfile.write(' numArc=%s' % (quote_attrib(self.numArc), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ArcType', fromsubclass_=False):
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArcType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            showIndent(outfile, level)
            outfile.write('numArc = %s,\n' % (self.numArc,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numArc', node)
        if value is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            self.numArc = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
# end class ArcType


class CircleType(ArcType):
    subclass = None
    superclass = ArcType
    def __init__(self, numArc=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None):
        super(CircleType, self).__init__(numArc, pos, pointProperty, pointRep, posList, coordinates, )
        pass
    def factory(*args_, **kwargs_):
        if CircleType.subclass:
            return CircleType.subclass(*args_, **kwargs_)
        else:
            return CircleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CircleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CircleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CircleType'):
        super(CircleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CircleType')
    def exportChildren(self, outfile, level, namespace_='', name_='CircleType', fromsubclass_=False):
        super(CircleType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(CircleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CircleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CircleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CircleType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CircleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CircleType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CircleType


class ArcStringByBulgeType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', numArc=None, interpolation=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, bulge=None, normal=None):
        super(ArcStringByBulgeType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.numArc = _cast(None, numArc)
        self.interpolation = _cast(None, interpolation)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        if bulge is None:
            self.bulge = []
        else:
            self.bulge = bulge
        if normal is None:
            self.normal = []
        else:
            self.normal = normal
    def factory(*args_, **kwargs_):
        if ArcStringByBulgeType.subclass:
            return ArcStringByBulgeType.subclass(*args_, **kwargs_)
        else:
            return ArcStringByBulgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_bulge(self): return self.bulge
    def set_bulge(self, bulge): self.bulge = bulge
    def add_bulge(self, value): self.bulge.append(value)
    def insert_bulge(self, index, value): self.bulge[index] = value
    def get_normal(self): return self.normal
    def set_normal(self, normal): self.normal = normal
    def add_normal(self, value): self.normal.append(value)
    def insert_normal(self, index, value): self.normal[index] = value
    def get_numArc(self): return self.numArc
    def set_numArc(self, numArc): self.numArc = numArc
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='ArcStringByBulgeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArcStringByBulgeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArcStringByBulgeType'):
        super(ArcStringByBulgeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ArcStringByBulgeType')
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            outfile.write(' numArc=%s' % (quote_attrib(self.numArc), ))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArcStringByBulgeType', fromsubclass_=False):
        super(ArcStringByBulgeType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
        for bulge_ in self.bulge:
            showIndent(outfile, level)
            outfile.write('<%sbulge>%s</%sbulge>\n' % (namespace_, self.gds_format_string(quote_xml(bulge_).encode(ExternalEncoding), input_name='bulge'), namespace_))
        for normal_ in self.normal:
            normal_.export(outfile, level, namespace_, name_='normal')
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            self.bulge or
            self.normal or
            super(ArcStringByBulgeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArcStringByBulgeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            showIndent(outfile, level)
            outfile.write('numArc = %s,\n' % (self.numArc,))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(ArcStringByBulgeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ArcStringByBulgeType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('bulge=[\n')
        level += 1
        for bulge_ in self.bulge:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(bulge_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('normal=[\n')
        level += 1
        for normal_ in self.normal:
            showIndent(outfile, level)
            outfile.write('model_.VectorType(\n')
            normal_.exportLiteral(outfile, level, name_='VectorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numArc', node)
        if value is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            self.numArc = value
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(ArcStringByBulgeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        elif nodeName_ == 'bulge':
            bulge_ = child_.text
            bulge_ = self.gds_validate_string(bulge_, node, 'bulge')
            self.bulge.append(bulge_)
        elif nodeName_ == 'normal':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.normal.append(obj_)
        super(ArcStringByBulgeType, self).buildChildren(child_, node, nodeName_, True)
# end class ArcStringByBulgeType


class ArcByBulgeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numArc=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, bulge=None, normal=None):
        self.numArc = _cast(None, numArc)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        self.bulge = bulge
        self.normal = normal
    def factory(*args_, **kwargs_):
        if ArcByBulgeType.subclass:
            return ArcByBulgeType.subclass(*args_, **kwargs_)
        else:
            return ArcByBulgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_bulge(self): return self.bulge
    def set_bulge(self, bulge): self.bulge = bulge
    def get_normal(self): return self.normal
    def set_normal(self, normal): self.normal = normal
    def get_numArc(self): return self.numArc
    def set_numArc(self, numArc): self.numArc = numArc
    def export(self, outfile, level, namespace_='', name_='ArcByBulgeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArcByBulgeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArcByBulgeType'):
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            outfile.write(' numArc=%s' % (quote_attrib(self.numArc), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArcByBulgeType', fromsubclass_=False):
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
        if self.bulge is not None:
            showIndent(outfile, level)
            outfile.write('<%sbulge>%s</%sbulge>\n' % (namespace_, self.gds_format_string(quote_xml(self.bulge).encode(ExternalEncoding), input_name='bulge'), namespace_))
        if self.normal is not None:
            self.normal.export(outfile, level, namespace_, name_='normal', )
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            self.bulge is not None or
            self.normal is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArcByBulgeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            showIndent(outfile, level)
            outfile.write('numArc = %s,\n' % (self.numArc,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bulge is not None:
            showIndent(outfile, level)
            outfile.write('bulge=%s,\n' % quote_python(self.bulge).encode(ExternalEncoding))
        if self.normal is not None:
            showIndent(outfile, level)
            outfile.write('normal=model_.VectorType(\n')
            self.normal.exportLiteral(outfile, level, name_='normal')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numArc', node)
        if value is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            self.numArc = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        elif nodeName_ == 'bulge':
            bulge_ = child_.text
            bulge_ = self.gds_validate_string(bulge_, node, 'bulge')
            self.bulge = bulge_
        elif nodeName_ == 'normal':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.set_normal(obj_)
# end class ArcByBulgeType


class ArcByCenterPointType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', numArc=None, interpolation=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, radius=None, startAngle=None, endAngle=None):
        super(ArcByCenterPointType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.numArc = _cast(None, numArc)
        self.interpolation = _cast(None, interpolation)
        self.pos = pos
        self.pointProperty = pointProperty
        self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        self.radius = radius
        self.startAngle = startAngle
        self.endAngle = endAngle
    def factory(*args_, **kwargs_):
        if ArcByCenterPointType.subclass:
            return ArcByCenterPointType.subclass(*args_, **kwargs_)
        else:
            return ArcByCenterPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def get_startAngle(self): return self.startAngle
    def set_startAngle(self, startAngle): self.startAngle = startAngle
    def get_endAngle(self): return self.endAngle
    def set_endAngle(self, endAngle): self.endAngle = endAngle
    def get_numArc(self): return self.numArc
    def set_numArc(self, numArc): self.numArc = numArc
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='ArcByCenterPointType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArcByCenterPointType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArcByCenterPointType'):
        super(ArcByCenterPointType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ArcByCenterPointType')
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            outfile.write(' numArc=%s' % (quote_attrib(self.numArc), ))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArcByCenterPointType', fromsubclass_=False):
        super(ArcByCenterPointType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.pos is not None:
            self.pos.export(outfile, level, namespace_, name_='pos', )
        if self.pointProperty is not None:
            self.pointProperty.export(outfile, level, namespace_, name_='pointProperty', )
        if self.pointRep is not None:
            self.pointRep.export(outfile, level, namespace_, name_='pointRep', )
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
        if self.radius is not None:
            self.radius.export(outfile, level, namespace_, name_='radius', )
        if self.startAngle is not None:
            self.startAngle.export(outfile, level, namespace_, name_='startAngle')
        if self.endAngle is not None:
            self.endAngle.export(outfile, level, namespace_, name_='endAngle')
    def hasContent_(self):
        if (
            self.pos is not None or
            self.pointProperty is not None or
            self.pointRep is not None or
            self.posList is not None or
            self.coordinates is not None or
            self.radius is not None or
            self.startAngle is not None or
            self.endAngle is not None or
            super(ArcByCenterPointType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArcByCenterPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numArc is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            showIndent(outfile, level)
            outfile.write('numArc = %s,\n' % (self.numArc,))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(ArcByCenterPointType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ArcByCenterPointType, self).exportLiteralChildren(outfile, level, name_)
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=model_.pos(\n')
            self.pos.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointProperty is not None:
            showIndent(outfile, level)
            outfile.write('pointProperty=model_.pointProperty(\n')
            self.pointProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointRep is not None:
            showIndent(outfile, level)
            outfile.write('pointRep=model_.pointRep(\n')
            self.pointRep.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.radius is not None:
            showIndent(outfile, level)
            outfile.write('radius=model_.LengthType(\n')
            self.radius.exportLiteral(outfile, level, name_='radius')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.startAngle is not None:
            showIndent(outfile, level)
            outfile.write('startAngle=model_.AngleType(\n')
            self.startAngle.exportLiteral(outfile, level, name_='startAngle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.endAngle is not None:
            showIndent(outfile, level)
            outfile.write('endAngle=model_.AngleType(\n')
            self.endAngle.exportLiteral(outfile, level, name_='endAngle')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numArc', node)
        if value is not None and 'numArc' not in already_processed:
            already_processed.append('numArc')
            self.numArc = value
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(ArcByCenterPointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_pos(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_pointProperty(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_pointRep(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        elif nodeName_ == 'radius':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.set_radius(obj_)
        elif nodeName_ == 'startAngle':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.set_startAngle(obj_)
        elif nodeName_ == 'endAngle':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.set_endAngle(obj_)
        super(ArcByCenterPointType, self).buildChildren(child_, node, nodeName_, True)
# end class ArcByCenterPointType


class CircleByCenterPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, radius=None):
        self.pos = pos
        self.pointProperty = pointProperty
        self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        self.radius = radius
    def factory(*args_, **kwargs_):
        if CircleByCenterPointType.subclass:
            return CircleByCenterPointType.subclass(*args_, **kwargs_)
        else:
            return CircleByCenterPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def export(self, outfile, level, namespace_='', name_='CircleByCenterPointType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CircleByCenterPointType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CircleByCenterPointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CircleByCenterPointType', fromsubclass_=False):
        if self.pos is not None:
            self.pos.export(outfile, level, namespace_, name_='pos', )
        if self.pointProperty is not None:
            self.pointProperty.export(outfile, level, namespace_, name_='pointProperty', )
        if self.pointRep is not None:
            self.pointRep.export(outfile, level, namespace_, name_='pointRep', )
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
        if self.radius is not None:
            self.radius.export(outfile, level, namespace_, name_='radius', )
    def hasContent_(self):
        if (
            self.pos is not None or
            self.pointProperty is not None or
            self.pointRep is not None or
            self.posList is not None or
            self.coordinates is not None or
            self.radius is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CircleByCenterPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=model_.pos(\n')
            self.pos.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointProperty is not None:
            showIndent(outfile, level)
            outfile.write('pointProperty=model_.pointProperty(\n')
            self.pointProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointRep is not None:
            showIndent(outfile, level)
            outfile.write('pointRep=model_.pointRep(\n')
            self.pointRep.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.radius is not None:
            showIndent(outfile, level)
            outfile.write('radius=model_.LengthType(\n')
            self.radius.exportLiteral(outfile, level, name_='radius')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_pos(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_pointProperty(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_pointRep(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        elif nodeName_ == 'radius':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.set_radius(obj_)
# end class CircleByCenterPointType


class CubicSplineType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', degree=None, interpolation=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, vectorAtStart=None, vectorAtEnd=None):
        super(CubicSplineType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.degree = _cast(None, degree)
        self.interpolation = _cast(None, interpolation)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        self.vectorAtStart = vectorAtStart
        self.vectorAtEnd = vectorAtEnd
    def factory(*args_, **kwargs_):
        if CubicSplineType.subclass:
            return CubicSplineType.subclass(*args_, **kwargs_)
        else:
            return CubicSplineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_vectorAtStart(self): return self.vectorAtStart
    def set_vectorAtStart(self, vectorAtStart): self.vectorAtStart = vectorAtStart
    def get_vectorAtEnd(self): return self.vectorAtEnd
    def set_vectorAtEnd(self, vectorAtEnd): self.vectorAtEnd = vectorAtEnd
    def get_degree(self): return self.degree
    def set_degree(self, degree): self.degree = degree
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='CubicSplineType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CubicSplineType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CubicSplineType'):
        super(CubicSplineType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CubicSplineType')
        if self.degree is not None and 'degree' not in already_processed:
            already_processed.append('degree')
            outfile.write(' degree=%s' % (quote_attrib(self.degree), ))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CubicSplineType', fromsubclass_=False):
        super(CubicSplineType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
        if self.vectorAtStart is not None:
            self.vectorAtStart.export(outfile, level, namespace_, name_='vectorAtStart', )
        if self.vectorAtEnd is not None:
            self.vectorAtEnd.export(outfile, level, namespace_, name_='vectorAtEnd', )
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            self.vectorAtStart is not None or
            self.vectorAtEnd is not None or
            super(CubicSplineType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CubicSplineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.degree is not None and 'degree' not in already_processed:
            already_processed.append('degree')
            showIndent(outfile, level)
            outfile.write('degree = %s,\n' % (self.degree,))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(CubicSplineType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CubicSplineType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vectorAtStart is not None:
            showIndent(outfile, level)
            outfile.write('vectorAtStart=model_.VectorType(\n')
            self.vectorAtStart.exportLiteral(outfile, level, name_='vectorAtStart')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vectorAtEnd is not None:
            showIndent(outfile, level)
            outfile.write('vectorAtEnd=model_.VectorType(\n')
            self.vectorAtEnd.exportLiteral(outfile, level, name_='vectorAtEnd')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('degree', node)
        if value is not None and 'degree' not in already_processed:
            already_processed.append('degree')
            self.degree = value
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(CubicSplineType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        elif nodeName_ == 'vectorAtStart':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.set_vectorAtStart(obj_)
        elif nodeName_ == 'vectorAtEnd':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.set_vectorAtEnd(obj_)
        super(CubicSplineType, self).buildChildren(child_, node, nodeName_, True)
# end class CubicSplineType


class BSplineType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', knotType=None, isPolynomial=None, interpolation='polynomialSpline', pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, degree=None, knot=None):
        super(BSplineType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.knotType = _cast(None, knotType)
        self.isPolynomial = _cast(None, isPolynomial)
        self.interpolation = _cast(None, interpolation)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        self.degree = degree
        if knot is None:
            self.knot = []
        else:
            self.knot = knot
    def factory(*args_, **kwargs_):
        if BSplineType.subclass:
            return BSplineType.subclass(*args_, **kwargs_)
        else:
            return BSplineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_degree(self): return self.degree
    def set_degree(self, degree): self.degree = degree
    def get_knot(self): return self.knot
    def set_knot(self, knot): self.knot = knot
    def add_knot(self, value): self.knot.append(value)
    def insert_knot(self, index, value): self.knot[index] = value
    def get_knotType(self): return self.knotType
    def set_knotType(self, knotType): self.knotType = knotType
    def get_isPolynomial(self): return self.isPolynomial
    def set_isPolynomial(self, isPolynomial): self.isPolynomial = isPolynomial
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='BSplineType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BSplineType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BSplineType'):
        super(BSplineType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BSplineType')
        if self.knotType is not None and 'knotType' not in already_processed:
            already_processed.append('knotType')
            outfile.write(' knotType=%s' % (quote_attrib(self.knotType), ))
        if self.isPolynomial is not None and 'isPolynomial' not in already_processed:
            already_processed.append('isPolynomial')
            outfile.write(' isPolynomial=%s' % (quote_attrib(self.isPolynomial), ))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BSplineType', fromsubclass_=False):
        super(BSplineType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
        if self.degree is not None:
            showIndent(outfile, level)
            outfile.write('<%sdegree>%s</%sdegree>\n' % (namespace_, self.gds_format_string(quote_xml(self.degree).encode(ExternalEncoding), input_name='degree'), namespace_))
        for knot_ in self.knot:
            knot_.export(outfile, level, namespace_, name_='knot')
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            self.degree is not None or
            self.knot or
            super(BSplineType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BSplineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.knotType is not None and 'knotType' not in already_processed:
            already_processed.append('knotType')
            showIndent(outfile, level)
            outfile.write('knotType = %s,\n' % (self.knotType,))
        if self.isPolynomial is not None and 'isPolynomial' not in already_processed:
            already_processed.append('isPolynomial')
            showIndent(outfile, level)
            outfile.write('isPolynomial = %s,\n' % (self.isPolynomial,))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(BSplineType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BSplineType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.degree is not None:
            showIndent(outfile, level)
            outfile.write('degree=%s,\n' % quote_python(self.degree).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('knot=[\n')
        level += 1
        for knot_ in self.knot:
            showIndent(outfile, level)
            outfile.write('model_.KnotPropertyType(\n')
            knot_.exportLiteral(outfile, level, name_='KnotPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('knotType', node)
        if value is not None and 'knotType' not in already_processed:
            already_processed.append('knotType')
            self.knotType = value
        value = find_attr_value_('isPolynomial', node)
        if value is not None and 'isPolynomial' not in already_processed:
            already_processed.append('isPolynomial')
            self.isPolynomial = value
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(BSplineType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        elif nodeName_ == 'degree':
            degree_ = child_.text
            degree_ = self.gds_validate_string(degree_, node, 'degree')
            self.degree = degree_
        elif nodeName_ == 'knot':
            obj_ = KnotPropertyType.factory()
            obj_.build(child_)
            self.knot.append(obj_)
        super(BSplineType, self).buildChildren(child_, node, nodeName_, True)
# end class BSplineType


class KnotType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, multiplicity=None, weight=None):
        self.value = value
        self.multiplicity = multiplicity
        self.weight = weight
    def factory(*args_, **kwargs_):
        if KnotType.subclass:
            return KnotType.subclass(*args_, **kwargs_)
        else:
            return KnotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_multiplicity(self): return self.multiplicity
    def set_multiplicity(self, multiplicity): self.multiplicity = multiplicity
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def export(self, outfile, level, namespace_='', name_='KnotType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KnotType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KnotType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KnotType', fromsubclass_=False):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
        if self.multiplicity is not None:
            showIndent(outfile, level)
            outfile.write('<%smultiplicity>%s</%smultiplicity>\n' % (namespace_, self.gds_format_string(quote_xml(self.multiplicity).encode(ExternalEncoding), input_name='multiplicity'), namespace_))
        if self.weight is not None:
            showIndent(outfile, level)
            outfile.write('<%sweight>%s</%sweight>\n' % (namespace_, self.gds_format_string(quote_xml(self.weight).encode(ExternalEncoding), input_name='weight'), namespace_))
    def hasContent_(self):
        if (
            self.value is not None or
            self.multiplicity is not None or
            self.weight is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KnotType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.multiplicity is not None:
            showIndent(outfile, level)
            outfile.write('multiplicity=%s,\n' % quote_python(self.multiplicity).encode(ExternalEncoding))
        if self.weight is not None:
            showIndent(outfile, level)
            outfile.write('weight=%s,\n' % quote_python(self.weight).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'multiplicity':
            multiplicity_ = child_.text
            multiplicity_ = self.gds_validate_string(multiplicity_, node, 'multiplicity')
            self.multiplicity = multiplicity_
        elif nodeName_ == 'weight':
            weight_ = child_.text
            weight_ = self.gds_validate_string(weight_, node, 'weight')
            self.weight = weight_
# end class KnotType


class KnotPropertyType(GeneratedsSuper):
    """gml:KnotPropertyType encapsulates a knot to use it in a geometric
    type."""
    subclass = None
    superclass = None
    def __init__(self, Knot=None):
        self.Knot = Knot
    def factory(*args_, **kwargs_):
        if KnotPropertyType.subclass:
            return KnotPropertyType.subclass(*args_, **kwargs_)
        else:
            return KnotPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Knot(self): return self.Knot
    def set_Knot(self, Knot): self.Knot = Knot
    def export(self, outfile, level, namespace_='', name_='KnotPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KnotPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KnotPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KnotPropertyType', fromsubclass_=False):
        if self.Knot is not None:
            self.Knot.export(outfile, level, namespace_, name_='Knot', )
    def hasContent_(self):
        if (
            self.Knot is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KnotPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Knot is not None:
            showIndent(outfile, level)
            outfile.write('Knot=model_.KnotType(\n')
            self.Knot.exportLiteral(outfile, level, name_='Knot')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Knot':
            obj_ = KnotType.factory()
            obj_.build(child_)
            self.set_Knot(obj_)
# end class KnotPropertyType


class BezierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, knotType=None, isPolynomial=None, interpolation=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None, degree=None, knot=None):
        self.knotType = _cast(None, knotType)
        self.isPolynomial = _cast(None, isPolynomial)
        self.interpolation = _cast(None, interpolation)
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
        self.degree = degree
        if knot is None:
            self.knot = []
        else:
            self.knot = knot
    def factory(*args_, **kwargs_):
        if BezierType.subclass:
            return BezierType.subclass(*args_, **kwargs_)
        else:
            return BezierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_degree(self): return self.degree
    def set_degree(self, degree): self.degree = degree
    def get_knot(self): return self.knot
    def set_knot(self, knot): self.knot = knot
    def add_knot(self, value): self.knot.append(value)
    def insert_knot(self, index, value): self.knot[index] = value
    def get_knotType(self): return self.knotType
    def set_knotType(self, knotType): self.knotType = knotType
    def get_isPolynomial(self): return self.isPolynomial
    def set_isPolynomial(self, isPolynomial): self.isPolynomial = isPolynomial
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='BezierType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BezierType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BezierType'):
        if self.knotType is not None and 'knotType' not in already_processed:
            already_processed.append('knotType')
            outfile.write(' knotType=%s' % (quote_attrib(self.knotType), ))
        if self.isPolynomial is not None and 'isPolynomial' not in already_processed:
            already_processed.append('isPolynomial')
            outfile.write(' isPolynomial=%s' % (quote_attrib(self.isPolynomial), ))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BezierType', fromsubclass_=False):
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
        if self.degree is not None:
            showIndent(outfile, level)
            outfile.write('<%sdegree>%s</%sdegree>\n' % (namespace_, self.gds_format_string(quote_xml(self.degree).encode(ExternalEncoding), input_name='degree'), namespace_))
        for knot_ in self.knot:
            knot_.export(outfile, level, namespace_, name_='knot')
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            self.degree is not None or
            self.knot
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BezierType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.knotType is not None and 'knotType' not in already_processed:
            already_processed.append('knotType')
            showIndent(outfile, level)
            outfile.write('knotType = %s,\n' % (self.knotType,))
        if self.isPolynomial is not None and 'isPolynomial' not in already_processed:
            already_processed.append('isPolynomial')
            showIndent(outfile, level)
            outfile.write('isPolynomial = %s,\n' % (self.isPolynomial,))
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.degree is not None:
            showIndent(outfile, level)
            outfile.write('degree=%s,\n' % quote_python(self.degree).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('knot=[\n')
        level += 1
        for knot_ in self.knot:
            showIndent(outfile, level)
            outfile.write('model_.KnotPropertyType(\n')
            knot_.exportLiteral(outfile, level, name_='KnotPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('knotType', node)
        if value is not None and 'knotType' not in already_processed:
            already_processed.append('knotType')
            self.knotType = value
        value = find_attr_value_('isPolynomial', node)
        if value is not None and 'isPolynomial' not in already_processed:
            already_processed.append('isPolynomial')
            self.isPolynomial = value
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        elif nodeName_ == 'degree':
            degree_ = child_.text
            degree_ = self.gds_validate_string(degree_, node, 'degree')
            self.degree = degree_
        elif nodeName_ == 'knot':
            obj_ = KnotPropertyType.factory()
            obj_.build(child_)
            self.knot.append(obj_)
# end class BezierType


class OffsetCurveType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', offsetBase=None, distance=None, refDirection=None):
        super(OffsetCurveType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.offsetBase = offsetBase
        self.distance = distance
        self.refDirection = refDirection
    def factory(*args_, **kwargs_):
        if OffsetCurveType.subclass:
            return OffsetCurveType.subclass(*args_, **kwargs_)
        else:
            return OffsetCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_offsetBase(self): return self.offsetBase
    def set_offsetBase(self, offsetBase): self.offsetBase = offsetBase
    def get_distance(self): return self.distance
    def set_distance(self, distance): self.distance = distance
    def get_refDirection(self): return self.refDirection
    def set_refDirection(self, refDirection): self.refDirection = refDirection
    def export(self, outfile, level, namespace_='', name_='OffsetCurveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OffsetCurveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OffsetCurveType'):
        super(OffsetCurveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OffsetCurveType')
    def exportChildren(self, outfile, level, namespace_='', name_='OffsetCurveType', fromsubclass_=False):
        super(OffsetCurveType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.offsetBase is not None:
            self.offsetBase.export(outfile, level, namespace_, name_='offsetBase', )
        if self.distance is not None:
            self.distance.export(outfile, level, namespace_, name_='distance', )
        if self.refDirection is not None:
            self.refDirection.export(outfile, level, namespace_, name_='refDirection')
    def hasContent_(self):
        if (
            self.offsetBase is not None or
            self.distance is not None or
            self.refDirection is not None or
            super(OffsetCurveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OffsetCurveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OffsetCurveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OffsetCurveType, self).exportLiteralChildren(outfile, level, name_)
        if self.offsetBase is not None:
            showIndent(outfile, level)
            outfile.write('offsetBase=model_.CurvePropertyType(\n')
            self.offsetBase.exportLiteral(outfile, level, name_='offsetBase')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distance is not None:
            showIndent(outfile, level)
            outfile.write('distance=model_.LengthType(\n')
            self.distance.exportLiteral(outfile, level, name_='distance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.refDirection is not None:
            showIndent(outfile, level)
            outfile.write('refDirection=model_.VectorType(\n')
            self.refDirection.exportLiteral(outfile, level, name_='refDirection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OffsetCurveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'offsetBase':
            obj_ = CurvePropertyType.factory()
            obj_.build(child_)
            self.set_offsetBase(obj_)
        elif nodeName_ == 'distance':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.set_distance(obj_)
        elif nodeName_ == 'refDirection':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.set_refDirection(obj_)
        super(OffsetCurveType, self).buildChildren(child_, node, nodeName_, True)
# end class OffsetCurveType


class AffinePlacementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, location=None, refDirection=None, inDimension=None, outDimension=None):
        self.location = location
        if refDirection is None:
            self.refDirection = []
        else:
            self.refDirection = refDirection
        self.inDimension = inDimension
        self.outDimension = outDimension
    def factory(*args_, **kwargs_):
        if AffinePlacementType.subclass:
            return AffinePlacementType.subclass(*args_, **kwargs_)
        else:
            return AffinePlacementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_refDirection(self): return self.refDirection
    def set_refDirection(self, refDirection): self.refDirection = refDirection
    def add_refDirection(self, value): self.refDirection.append(value)
    def insert_refDirection(self, index, value): self.refDirection[index] = value
    def get_inDimension(self): return self.inDimension
    def set_inDimension(self, inDimension): self.inDimension = inDimension
    def get_outDimension(self): return self.outDimension
    def set_outDimension(self, outDimension): self.outDimension = outDimension
    def export(self, outfile, level, namespace_='', name_='AffinePlacementType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AffinePlacementType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AffinePlacementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AffinePlacementType', fromsubclass_=False):
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', )
        for refDirection_ in self.refDirection:
            refDirection_.export(outfile, level, namespace_, name_='refDirection')
        if self.inDimension is not None:
            showIndent(outfile, level)
            outfile.write('<%sinDimension>%s</%sinDimension>\n' % (namespace_, self.gds_format_string(quote_xml(self.inDimension).encode(ExternalEncoding), input_name='inDimension'), namespace_))
        if self.outDimension is not None:
            showIndent(outfile, level)
            outfile.write('<%soutDimension>%s</%soutDimension>\n' % (namespace_, self.gds_format_string(quote_xml(self.outDimension).encode(ExternalEncoding), input_name='outDimension'), namespace_))
    def hasContent_(self):
        if (
            self.location is not None or
            self.refDirection or
            self.inDimension is not None or
            self.outDimension is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AffinePlacementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.DirectPositionType(\n')
            self.location.exportLiteral(outfile, level, name_='location')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('refDirection=[\n')
        level += 1
        for refDirection_ in self.refDirection:
            showIndent(outfile, level)
            outfile.write('model_.VectorType(\n')
            refDirection_.exportLiteral(outfile, level, name_='VectorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.inDimension is not None:
            showIndent(outfile, level)
            outfile.write('inDimension=%s,\n' % quote_python(self.inDimension).encode(ExternalEncoding))
        if self.outDimension is not None:
            showIndent(outfile, level)
            outfile.write('outDimension=%s,\n' % quote_python(self.outDimension).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'location':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_location(obj_)
        elif nodeName_ == 'refDirection':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.refDirection.append(obj_)
        elif nodeName_ == 'inDimension':
            inDimension_ = child_.text
            inDimension_ = self.gds_validate_string(inDimension_, node, 'inDimension')
            self.inDimension = inDimension_
        elif nodeName_ == 'outDimension':
            outDimension_ = child_.text
            outDimension_ = self.gds_validate_string(outDimension_, node, 'outDimension')
            self.outDimension = outDimension_
# end class AffinePlacementType


class ClothoidType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', interpolation=None, refLocation=None, scaleFactor=None, startParameter=None, endParameter=None):
        super(ClothoidType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, )
        self.interpolation = _cast(None, interpolation)
        self.refLocation = refLocation
        self.scaleFactor = scaleFactor
        self.startParameter = startParameter
        self.endParameter = endParameter
    def factory(*args_, **kwargs_):
        if ClothoidType.subclass:
            return ClothoidType.subclass(*args_, **kwargs_)
        else:
            return ClothoidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refLocation(self): return self.refLocation
    def set_refLocation(self, refLocation): self.refLocation = refLocation
    def get_scaleFactor(self): return self.scaleFactor
    def set_scaleFactor(self, scaleFactor): self.scaleFactor = scaleFactor
    def get_startParameter(self): return self.startParameter
    def set_startParameter(self, startParameter): self.startParameter = startParameter
    def get_endParameter(self): return self.endParameter
    def set_endParameter(self, endParameter): self.endParameter = endParameter
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='ClothoidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothoidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClothoidType'):
        super(ClothoidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ClothoidType')
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClothoidType', fromsubclass_=False):
        super(ClothoidType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.refLocation is not None:
            self.refLocation.export(outfile, level, namespace_, name_='refLocation', )
        if self.scaleFactor is not None:
            showIndent(outfile, level)
            outfile.write('<%sscaleFactor>%s</%sscaleFactor>\n' % (namespace_, self.gds_format_string(quote_xml(self.scaleFactor).encode(ExternalEncoding), input_name='scaleFactor'), namespace_))
        if self.startParameter is not None:
            showIndent(outfile, level)
            outfile.write('<%sstartParameter>%s</%sstartParameter>\n' % (namespace_, self.gds_format_string(quote_xml(self.startParameter).encode(ExternalEncoding), input_name='startParameter'), namespace_))
        if self.endParameter is not None:
            showIndent(outfile, level)
            outfile.write('<%sendParameter>%s</%sendParameter>\n' % (namespace_, self.gds_format_string(quote_xml(self.endParameter).encode(ExternalEncoding), input_name='endParameter'), namespace_))
    def hasContent_(self):
        if (
            self.refLocation is not None or
            self.scaleFactor is not None or
            self.startParameter is not None or
            self.endParameter is not None or
            super(ClothoidType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ClothoidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(ClothoidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ClothoidType, self).exportLiteralChildren(outfile, level, name_)
        if self.refLocation is not None:
            showIndent(outfile, level)
            outfile.write('refLocation=model_.refLocationType(\n')
            self.refLocation.exportLiteral(outfile, level, name_='refLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scaleFactor is not None:
            showIndent(outfile, level)
            outfile.write('scaleFactor=%s,\n' % quote_python(self.scaleFactor).encode(ExternalEncoding))
        if self.startParameter is not None:
            showIndent(outfile, level)
            outfile.write('startParameter=%s,\n' % quote_python(self.startParameter).encode(ExternalEncoding))
        if self.endParameter is not None:
            showIndent(outfile, level)
            outfile.write('endParameter=%s,\n' % quote_python(self.endParameter).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(ClothoidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'refLocation':
            obj_ = refLocationType.factory()
            obj_.build(child_)
            self.set_refLocation(obj_)
        elif nodeName_ == 'scaleFactor':
            scaleFactor_ = child_.text
            scaleFactor_ = self.gds_validate_string(scaleFactor_, node, 'scaleFactor')
            self.scaleFactor = scaleFactor_
        elif nodeName_ == 'startParameter':
            startParameter_ = child_.text
            startParameter_ = self.gds_validate_string(startParameter_, node, 'startParameter')
            self.startParameter = startParameter_
        elif nodeName_ == 'endParameter':
            endParameter_ = child_.text
            endParameter_ = self.gds_validate_string(endParameter_, node, 'endParameter')
            self.endParameter = endParameter_
        super(ClothoidType, self).buildChildren(child_, node, nodeName_, True)
# end class ClothoidType


class GeodesicStringType(AbstractCurveSegmentType):
    subclass = None
    superclass = AbstractCurveSegmentType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', interpolation=None, posList=None, pos=None, pointProperty=None, extensiontype_=None):
        super(GeodesicStringType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, extensiontype_, )
        self.interpolation = _cast(None, interpolation)
        self.posList = posList
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if GeodesicStringType.subclass:
            return GeodesicStringType.subclass(*args_, **kwargs_)
        else:
            return GeodesicStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='GeodesicStringType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodesicStringType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeodesicStringType'):
        super(GeodesicStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodesicStringType')
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='GeodesicStringType', fromsubclass_=False):
        super(GeodesicStringType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
    def hasContent_(self):
        if (
            self.posList is not None or
            self.pos or
            self.pointProperty or
            super(GeodesicStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeodesicStringType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(GeodesicStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GeodesicStringType, self).exportLiteralChildren(outfile, level, name_)
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(GeodesicStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        super(GeodesicStringType, self).buildChildren(child_, node, nodeName_, True)
# end class GeodesicStringType


class GeodesicType(GeodesicStringType):
    subclass = None
    superclass = GeodesicStringType
    def __init__(self, numDerivativesAtEnd='0', numDerivativeInterior='0', numDerivativesAtStart='0', interpolation=None, posList=None, pos=None, pointProperty=None):
        super(GeodesicType, self).__init__(numDerivativesAtEnd, numDerivativeInterior, numDerivativesAtStart, interpolation, posList, pos, pointProperty, )
        pass
    def factory(*args_, **kwargs_):
        if GeodesicType.subclass:
            return GeodesicType.subclass(*args_, **kwargs_)
        else:
            return GeodesicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='GeodesicType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodesicType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeodesicType'):
        super(GeodesicType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodesicType')
    def exportChildren(self, outfile, level, namespace_='', name_='GeodesicType', fromsubclass_=False):
        super(GeodesicType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(GeodesicType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeodesicType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeodesicType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GeodesicType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodesicType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GeodesicType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GeodesicType


class AbstractSurfacePatchType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractSurfacePatchType.subclass:
            return AbstractSurfacePatchType.subclass(*args_, **kwargs_)
        else:
            return AbstractSurfacePatchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractSurfacePatchType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractSurfacePatchType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractSurfacePatchType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractSurfacePatchType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractSurfacePatchType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractSurfacePatchType


class SurfacePatchArrayPropertyType(GeneratedsSuper):
    """gml:SurfacePatchArrayPropertyType is a container for a sequence of
    surface patches."""
    subclass = None
    superclass = None
    def __init__(self, AbstractSurfacePatch=None):
        self.AbstractSurfacePatch = AbstractSurfacePatch
    def factory(*args_, **kwargs_):
        if SurfacePatchArrayPropertyType.subclass:
            return SurfacePatchArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return SurfacePatchArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractSurfacePatch(self): return self.AbstractSurfacePatch
    def set_AbstractSurfacePatch(self, AbstractSurfacePatch): self.AbstractSurfacePatch = AbstractSurfacePatch
    def export(self, outfile, level, namespace_='', name_='SurfacePatchArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SurfacePatchArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SurfacePatchArrayPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SurfacePatchArrayPropertyType', fromsubclass_=False):
        if self.AbstractSurfacePatch is not None:
            self.AbstractSurfacePatch.export(outfile, level, namespace_, name_='AbstractSurfacePatch')
    def hasContent_(self):
        if (
            self.AbstractSurfacePatch is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SurfacePatchArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractSurfacePatch is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSurfacePatch=model_.AbstractSurfacePatch(\n')
            self.AbstractSurfacePatch.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractSurfacePatch':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSurfacePatch> element')
            self.set_AbstractSurfacePatch(obj_)
# end class SurfacePatchArrayPropertyType


class PolygonPatchType(AbstractSurfacePatchType):
    subclass = None
    superclass = AbstractSurfacePatchType
    def __init__(self, interpolation=None, exterior=None, interior=None):
        super(PolygonPatchType, self).__init__()
        self.interpolation = _cast(None, interpolation)
        self.exterior = exterior
        if interior is None:
            self.interior = []
        else:
            self.interior = interior
    def factory(*args_, **kwargs_):
        if PolygonPatchType.subclass:
            return PolygonPatchType.subclass(*args_, **kwargs_)
        else:
            return PolygonPatchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exterior(self): return self.exterior
    def set_exterior(self, exterior): self.exterior = exterior
    def get_interior(self): return self.interior
    def set_interior(self, interior): self.interior = interior
    def add_interior(self, value): self.interior.append(value)
    def insert_interior(self, index, value): self.interior[index] = value
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='PolygonPatchType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolygonPatchType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolygonPatchType'):
        super(PolygonPatchType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PolygonPatchType')
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PolygonPatchType', fromsubclass_=False):
        super(PolygonPatchType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.exterior is not None:
            self.exterior.export(outfile, level, namespace_, name_='exterior')
        for interior_ in self.interior:
            interior_.export(outfile, level, namespace_, name_='interior')
    def hasContent_(self):
        if (
            self.exterior is not None or
            self.interior or
            super(PolygonPatchType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolygonPatchType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(PolygonPatchType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PolygonPatchType, self).exportLiteralChildren(outfile, level, name_)
        if self.exterior is not None:
            showIndent(outfile, level)
            outfile.write('exterior=model_.exterior(\n')
            self.exterior.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('interior=[\n')
        level += 1
        for interior_ in self.interior:
            showIndent(outfile, level)
            outfile.write('model_.interior(\n')
            interior_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(PolygonPatchType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exterior':
            obj_ = AbstractRingPropertyType.factory()
            obj_.build(child_)
            self.set_exterior(obj_)
        elif nodeName_ == 'interior':
            obj_ = AbstractRingPropertyType.factory()
            obj_.build(child_)
            self.interior.append(obj_)
        super(PolygonPatchType, self).buildChildren(child_, node, nodeName_, True)
# end class PolygonPatchType


class TriangleType(AbstractSurfacePatchType):
    subclass = None
    superclass = AbstractSurfacePatchType
    def __init__(self, interpolation=None, exterior=None):
        super(TriangleType, self).__init__()
        self.interpolation = _cast(None, interpolation)
        self.exterior = exterior
    def factory(*args_, **kwargs_):
        if TriangleType.subclass:
            return TriangleType.subclass(*args_, **kwargs_)
        else:
            return TriangleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exterior(self): return self.exterior
    def set_exterior(self, exterior): self.exterior = exterior
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='TriangleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TriangleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TriangleType'):
        super(TriangleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TriangleType')
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TriangleType', fromsubclass_=False):
        super(TriangleType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.exterior is not None:
            self.exterior.export(outfile, level, namespace_, name_='exterior', )
    def hasContent_(self):
        if (
            self.exterior is not None or
            super(TriangleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TriangleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(TriangleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TriangleType, self).exportLiteralChildren(outfile, level, name_)
        if self.exterior is not None:
            showIndent(outfile, level)
            outfile.write('exterior=model_.exterior(\n')
            self.exterior.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(TriangleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exterior':
            obj_ = AbstractRingPropertyType.factory()
            obj_.build(child_)
            self.set_exterior(obj_)
        super(TriangleType, self).buildChildren(child_, node, nodeName_, True)
# end class TriangleType


class RectangleType(AbstractSurfacePatchType):
    subclass = None
    superclass = AbstractSurfacePatchType
    def __init__(self, interpolation=None, exterior=None):
        super(RectangleType, self).__init__()
        self.interpolation = _cast(None, interpolation)
        self.exterior = exterior
    def factory(*args_, **kwargs_):
        if RectangleType.subclass:
            return RectangleType.subclass(*args_, **kwargs_)
        else:
            return RectangleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exterior(self): return self.exterior
    def set_exterior(self, exterior): self.exterior = exterior
    def get_interpolation(self): return self.interpolation
    def set_interpolation(self, interpolation): self.interpolation = interpolation
    def export(self, outfile, level, namespace_='', name_='RectangleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RectangleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RectangleType'):
        super(RectangleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RectangleType')
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            outfile.write(' interpolation=%s' % (quote_attrib(self.interpolation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RectangleType', fromsubclass_=False):
        super(RectangleType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.exterior is not None:
            self.exterior.export(outfile, level, namespace_, name_='exterior', )
    def hasContent_(self):
        if (
            self.exterior is not None or
            super(RectangleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RectangleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interpolation is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            showIndent(outfile, level)
            outfile.write('interpolation = %s,\n' % (self.interpolation,))
        super(RectangleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RectangleType, self).exportLiteralChildren(outfile, level, name_)
        if self.exterior is not None:
            showIndent(outfile, level)
            outfile.write('exterior=model_.exterior(\n')
            self.exterior.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolation', node)
        if value is not None and 'interpolation' not in already_processed:
            already_processed.append('interpolation')
            self.interpolation = value
        super(RectangleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exterior':
            obj_ = AbstractRingPropertyType.factory()
            obj_.build(child_)
            self.set_exterior(obj_)
        super(RectangleType, self).buildChildren(child_, node, nodeName_, True)
# end class RectangleType


class RingPropertyType(GeneratedsSuper):
    """A property with the content model of gml:RingPropertyType
    encapsulates a ring to represent a component of a surface
    boundary."""
    subclass = None
    superclass = None
    def __init__(self, Ring=None):
        self.Ring = Ring
    def factory(*args_, **kwargs_):
        if RingPropertyType.subclass:
            return RingPropertyType.subclass(*args_, **kwargs_)
        else:
            return RingPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ring(self): return self.Ring
    def set_Ring(self, Ring): self.Ring = Ring
    def export(self, outfile, level, namespace_='', name_='RingPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RingPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RingPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RingPropertyType', fromsubclass_=False):
        if self.Ring is not None:
            self.Ring.export(outfile, level, namespace_, name_='Ring', )
    def hasContent_(self):
        if (
            self.Ring is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RingPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Ring is not None:
            showIndent(outfile, level)
            outfile.write('Ring=model_.Ring(\n')
            self.Ring.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ring':
            obj_ = RingType.factory()
            obj_.build(child_)
            self.set_Ring(obj_)
# end class RingPropertyType


class AbstractParametricCurveSurfaceType(AbstractSurfacePatchType):
    subclass = None
    superclass = AbstractSurfacePatchType
    def __init__(self, aggregationType=None, extensiontype_=None):
        super(AbstractParametricCurveSurfaceType, self).__init__(extensiontype_, )
        self.aggregationType = _cast(None, aggregationType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractParametricCurveSurfaceType.subclass:
            return AbstractParametricCurveSurfaceType.subclass(*args_, **kwargs_)
        else:
            return AbstractParametricCurveSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractParametricCurveSurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractParametricCurveSurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractParametricCurveSurfaceType'):
        super(AbstractParametricCurveSurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractParametricCurveSurfaceType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractParametricCurveSurfaceType', fromsubclass_=False):
        super(AbstractParametricCurveSurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(AbstractParametricCurveSurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractParametricCurveSurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(AbstractParametricCurveSurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractParametricCurveSurfaceType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractParametricCurveSurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractParametricCurveSurfaceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractParametricCurveSurfaceType


class AbstractGriddedSurfaceType(AbstractParametricCurveSurfaceType):
    subclass = None
    superclass = AbstractParametricCurveSurfaceType
    def __init__(self, aggregationType=None, rows_attr=None, columns=None, rows=None, extensiontype_=None):
        super(AbstractGriddedSurfaceType, self).__init__(aggregationType, extensiontype_, )
        self.rows_attr = _cast(None, rows_attr)
        self.columns = _cast(None, columns)
        self.rows = rows
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGriddedSurfaceType.subclass:
            return AbstractGriddedSurfaceType.subclass(*args_, **kwargs_)
        else:
            return AbstractGriddedSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rows(self): return self.rows
    def set_rows(self, rows): self.rows = rows
    def get_rows_attr(self): return self.rows_attr
    def set_rows_attr(self, rows_attr): self.rows_attr = rows_attr
    def get_columns(self): return self.columns
    def set_columns(self, columns): self.columns = columns
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGriddedSurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGriddedSurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGriddedSurfaceType'):
        super(AbstractGriddedSurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGriddedSurfaceType')
        if self.rows_attr is not None and 'rows_attr' not in already_processed:
            already_processed.append('rows_attr')
            outfile.write(' rows_attr=%s' % (self.gds_format_string(quote_attrib(self.rows_attr).encode(ExternalEncoding), input_name='rows_attr'), ))
        if self.columns is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            outfile.write(' columns=%s' % (quote_attrib(self.columns), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGriddedSurfaceType', fromsubclass_=False):
        super(AbstractGriddedSurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.rows is not None:
            self.rows.export(outfile, level, namespace_, name_='rows', )
    def hasContent_(self):
        if (
            self.rows is not None or
            super(AbstractGriddedSurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGriddedSurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rows_attr is not None and 'rows_attr' not in already_processed:
            already_processed.append('rows_attr')
            showIndent(outfile, level)
            outfile.write('rows_attr = "%s",\n' % (self.rows_attr,))
        if self.columns is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            showIndent(outfile, level)
            outfile.write('columns = %s,\n' % (self.columns,))
        super(AbstractGriddedSurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractGriddedSurfaceType, self).exportLiteralChildren(outfile, level, name_)
        if self.rows is not None:
            showIndent(outfile, level)
            outfile.write('rows=model_.rowsType1(\n')
            self.rows.exportLiteral(outfile, level, name_='rows')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rows_attr', node)
        if value is not None and 'rows_attr' not in already_processed:
            already_processed.append('rows_attr')
            self.rows_attr = value
        value = find_attr_value_('columns', node)
        if value is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            self.columns = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractGriddedSurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rows':
            obj_ = rowsType1.factory()
            obj_.build(child_)
            self.set_rows(obj_)
        super(AbstractGriddedSurfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractGriddedSurfaceType


class ConeType(AbstractGriddedSurfaceType):
    subclass = None
    superclass = AbstractGriddedSurfaceType
    def __init__(self, aggregationType=None, rows_attr=None, columns=None, rows=None, horizontalCurveType=None, verticalCurveType=None):
        super(ConeType, self).__init__(aggregationType, rows_attr, columns, rows, )
        self.horizontalCurveType = _cast(None, horizontalCurveType)
        self.verticalCurveType = _cast(None, verticalCurveType)
        pass
    def factory(*args_, **kwargs_):
        if ConeType.subclass:
            return ConeType.subclass(*args_, **kwargs_)
        else:
            return ConeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_horizontalCurveType(self): return self.horizontalCurveType
    def set_horizontalCurveType(self, horizontalCurveType): self.horizontalCurveType = horizontalCurveType
    def get_verticalCurveType(self): return self.verticalCurveType
    def set_verticalCurveType(self, verticalCurveType): self.verticalCurveType = verticalCurveType
    def export(self, outfile, level, namespace_='', name_='ConeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConeType'):
        super(ConeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConeType')
        if self.horizontalCurveType is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            outfile.write(' horizontalCurveType=%s' % (quote_attrib(self.horizontalCurveType), ))
        if self.verticalCurveType is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            outfile.write(' verticalCurveType=%s' % (quote_attrib(self.verticalCurveType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConeType', fromsubclass_=False):
        super(ConeType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(ConeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.horizontalCurveType is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            showIndent(outfile, level)
            outfile.write('horizontalCurveType = %s,\n' % (self.horizontalCurveType,))
        if self.verticalCurveType is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            showIndent(outfile, level)
            outfile.write('verticalCurveType = %s,\n' % (self.verticalCurveType,))
        super(ConeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConeType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('horizontalCurveType', node)
        if value is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            self.horizontalCurveType = value
        value = find_attr_value_('verticalCurveType', node)
        if value is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            self.verticalCurveType = value
        super(ConeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ConeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConeType


class CylinderType(AbstractGriddedSurfaceType):
    subclass = None
    superclass = AbstractGriddedSurfaceType
    def __init__(self, aggregationType=None, rows_attr=None, columns=None, rows=None, horizontalCurveType=None, verticalCurveType=None):
        super(CylinderType, self).__init__(aggregationType, rows_attr, columns, rows, )
        self.horizontalCurveType = _cast(None, horizontalCurveType)
        self.verticalCurveType = _cast(None, verticalCurveType)
        pass
    def factory(*args_, **kwargs_):
        if CylinderType.subclass:
            return CylinderType.subclass(*args_, **kwargs_)
        else:
            return CylinderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_horizontalCurveType(self): return self.horizontalCurveType
    def set_horizontalCurveType(self, horizontalCurveType): self.horizontalCurveType = horizontalCurveType
    def get_verticalCurveType(self): return self.verticalCurveType
    def set_verticalCurveType(self, verticalCurveType): self.verticalCurveType = verticalCurveType
    def export(self, outfile, level, namespace_='', name_='CylinderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CylinderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CylinderType'):
        super(CylinderType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CylinderType')
        if self.horizontalCurveType is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            outfile.write(' horizontalCurveType=%s' % (quote_attrib(self.horizontalCurveType), ))
        if self.verticalCurveType is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            outfile.write(' verticalCurveType=%s' % (quote_attrib(self.verticalCurveType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CylinderType', fromsubclass_=False):
        super(CylinderType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(CylinderType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CylinderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.horizontalCurveType is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            showIndent(outfile, level)
            outfile.write('horizontalCurveType = %s,\n' % (self.horizontalCurveType,))
        if self.verticalCurveType is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            showIndent(outfile, level)
            outfile.write('verticalCurveType = %s,\n' % (self.verticalCurveType,))
        super(CylinderType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CylinderType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('horizontalCurveType', node)
        if value is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            self.horizontalCurveType = value
        value = find_attr_value_('verticalCurveType', node)
        if value is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            self.verticalCurveType = value
        super(CylinderType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CylinderType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CylinderType


class SphereType(AbstractGriddedSurfaceType):
    subclass = None
    superclass = AbstractGriddedSurfaceType
    def __init__(self, aggregationType=None, rows_attr=None, columns=None, rows=None, horizontalCurveType=None, verticalCurveType=None):
        super(SphereType, self).__init__(aggregationType, rows_attr, columns, rows, )
        self.horizontalCurveType = _cast(None, horizontalCurveType)
        self.verticalCurveType = _cast(None, verticalCurveType)
        pass
    def factory(*args_, **kwargs_):
        if SphereType.subclass:
            return SphereType.subclass(*args_, **kwargs_)
        else:
            return SphereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_horizontalCurveType(self): return self.horizontalCurveType
    def set_horizontalCurveType(self, horizontalCurveType): self.horizontalCurveType = horizontalCurveType
    def get_verticalCurveType(self): return self.verticalCurveType
    def set_verticalCurveType(self, verticalCurveType): self.verticalCurveType = verticalCurveType
    def export(self, outfile, level, namespace_='', name_='SphereType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SphereType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SphereType'):
        super(SphereType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SphereType')
        if self.horizontalCurveType is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            outfile.write(' horizontalCurveType=%s' % (quote_attrib(self.horizontalCurveType), ))
        if self.verticalCurveType is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            outfile.write(' verticalCurveType=%s' % (quote_attrib(self.verticalCurveType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SphereType', fromsubclass_=False):
        super(SphereType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(SphereType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SphereType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.horizontalCurveType is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            showIndent(outfile, level)
            outfile.write('horizontalCurveType = %s,\n' % (self.horizontalCurveType,))
        if self.verticalCurveType is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            showIndent(outfile, level)
            outfile.write('verticalCurveType = %s,\n' % (self.verticalCurveType,))
        super(SphereType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SphereType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('horizontalCurveType', node)
        if value is not None and 'horizontalCurveType' not in already_processed:
            already_processed.append('horizontalCurveType')
            self.horizontalCurveType = value
        value = find_attr_value_('verticalCurveType', node)
        if value is not None and 'verticalCurveType' not in already_processed:
            already_processed.append('verticalCurveType')
            self.verticalCurveType = value
        super(SphereType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SphereType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SphereType


class LineStringSegmentArrayPropertyType(GeneratedsSuper):
    """gml:LineStringSegmentArrayPropertyType provides a container for line
    strings."""
    subclass = None
    superclass = None
    def __init__(self, LineStringSegment=None):
        self.LineStringSegment = LineStringSegment
    def factory(*args_, **kwargs_):
        if LineStringSegmentArrayPropertyType.subclass:
            return LineStringSegmentArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return LineStringSegmentArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineStringSegment(self): return self.LineStringSegment
    def set_LineStringSegment(self, LineStringSegment): self.LineStringSegment = LineStringSegment
    def export(self, outfile, level, namespace_='', name_='LineStringSegmentArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineStringSegmentArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineStringSegmentArrayPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LineStringSegmentArrayPropertyType', fromsubclass_=False):
        if self.LineStringSegment is not None:
            self.LineStringSegment.export(outfile, level, namespace_, name_='LineStringSegment', )
    def hasContent_(self):
        if (
            self.LineStringSegment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineStringSegmentArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LineStringSegment is not None:
            showIndent(outfile, level)
            outfile.write('LineStringSegment=model_.LineStringSegment(\n')
            self.LineStringSegment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineStringSegment':
            obj_ = LineStringSegmentType.factory()
            obj_.build(child_)
            self.set_LineStringSegment(obj_)
# end class LineStringSegmentArrayPropertyType


class SolidPropertyType(GeneratedsSuper):
    """A property that has a solid as its value domain may either be an
    appropriate geometry element encapsulated in an element of this
    type or an XLink reference to a remote geometry element (where
    remote includes geometry elements located elsewhere in the same
    document). Either the reference or the contained element shall
    be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractSolid=None):
        self.owns = _cast(None, owns)
        self.AbstractSolid = AbstractSolid
    def factory(*args_, **kwargs_):
        if SolidPropertyType.subclass:
            return SolidPropertyType.subclass(*args_, **kwargs_)
        else:
            return SolidPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractSolid(self): return self.AbstractSolid
    def set_AbstractSolid(self, AbstractSolid): self.AbstractSolid = AbstractSolid
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='SolidPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolidPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SolidPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SolidPropertyType', fromsubclass_=False):
        if self.AbstractSolid is not None:
            self.AbstractSolid.export(outfile, level, namespace_, name_='AbstractSolid')
    def hasContent_(self):
        if (
            self.AbstractSolid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SolidPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractSolid is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSolid=model_.AbstractSolid(\n')
            self.AbstractSolid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractSolid':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSolid> element')
            self.set_AbstractSolid(obj_)
# end class SolidPropertyType


class SolidArrayPropertyType(GeneratedsSuper):
    """gml:SolidArrayPropertyType is a container for an array of solids.
    The elements are always contained in the array property,
    referencing geometry elements or arrays of geometry elements is
    not supported."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractSolid=None):
        self.owns = _cast(None, owns)
        self.AbstractSolid = AbstractSolid
    def factory(*args_, **kwargs_):
        if SolidArrayPropertyType.subclass:
            return SolidArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return SolidArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractSolid(self): return self.AbstractSolid
    def set_AbstractSolid(self, AbstractSolid): self.AbstractSolid = AbstractSolid
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='SolidArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolidArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SolidArrayPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SolidArrayPropertyType', fromsubclass_=False):
        if self.AbstractSolid is not None:
            self.AbstractSolid.export(outfile, level, namespace_, name_='AbstractSolid')
    def hasContent_(self):
        if (
            self.AbstractSolid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SolidArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractSolid is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSolid=model_.AbstractSolid(\n')
            self.AbstractSolid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractSolid':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSolid> element')
            self.set_AbstractSolid(obj_)
# end class SolidArrayPropertyType


class ShellType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, aggregationType=None, surfaceMember=None):
        self.aggregationType = _cast(None, aggregationType)
        if surfaceMember is None:
            self.surfaceMember = []
        else:
            self.surfaceMember = surfaceMember
    def factory(*args_, **kwargs_):
        if ShellType.subclass:
            return ShellType.subclass(*args_, **kwargs_)
        else:
            return ShellType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_surfaceMember(self): return self.surfaceMember
    def set_surfaceMember(self, surfaceMember): self.surfaceMember = surfaceMember
    def add_surfaceMember(self, value): self.surfaceMember.append(value)
    def insert_surfaceMember(self, index, value): self.surfaceMember[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='ShellType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShellType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShellType'):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ShellType', fromsubclass_=False):
        for surfaceMember_ in self.surfaceMember:
            surfaceMember_.export(outfile, level, namespace_, name_='surfaceMember')
    def hasContent_(self):
        if (
            self.surfaceMember
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ShellType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('surfaceMember=[\n')
        level += 1
        for surfaceMember_ in self.surfaceMember:
            showIndent(outfile, level)
            outfile.write('model_.surfaceMember(\n')
            surfaceMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'surfaceMember':
            obj_ = SurfacePropertyType.factory()
            obj_.build(child_)
            self.surfaceMember.append(obj_)
# end class ShellType


class ShellPropertyType(GeneratedsSuper):
    """A property with the content model of gml:ShellPropertyType
    encapsulates a shell to represent a component of a solid
    boundary."""
    subclass = None
    superclass = None
    def __init__(self, Shell=None):
        self.Shell = Shell
    def factory(*args_, **kwargs_):
        if ShellPropertyType.subclass:
            return ShellPropertyType.subclass(*args_, **kwargs_)
        else:
            return ShellPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shell(self): return self.Shell
    def set_Shell(self, Shell): self.Shell = Shell
    def export(self, outfile, level, namespace_='', name_='ShellPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShellPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShellPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShellPropertyType', fromsubclass_=False):
        if self.Shell is not None:
            self.Shell.export(outfile, level, namespace_, name_='Shell', )
    def hasContent_(self):
        if (
            self.Shell is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ShellPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Shell is not None:
            showIndent(outfile, level)
            outfile.write('Shell=model_.Shell(\n')
            self.Shell.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shell':
            obj_ = ShellType.factory()
            obj_.build(child_)
            self.set_Shell(obj_)
# end class ShellPropertyType


class SurfacePropertyType(GeneratedsSuper):
    """A property that has a surface as its value domain may either be an
    appropriate geometry element encapsulated in an element of this
    type or an XLink reference to a remote geometry element (where
    remote includes geometry elements located elsewhere in the same
    document). Either the reference or the contained element shall
    be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractSurface=None):
        self.owns = _cast(None, owns)
        self.AbstractSurface = AbstractSurface
    def factory(*args_, **kwargs_):
        if SurfacePropertyType.subclass:
            return SurfacePropertyType.subclass(*args_, **kwargs_)
        else:
            return SurfacePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractSurface(self): return self.AbstractSurface
    def set_AbstractSurface(self, AbstractSurface): self.AbstractSurface = AbstractSurface
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='SurfacePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SurfacePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SurfacePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SurfacePropertyType', fromsubclass_=False):
        if self.AbstractSurface is not None:
            self.AbstractSurface.export(outfile, level, namespace_, name_='AbstractSurface')
    def hasContent_(self):
        if (
            self.AbstractSurface is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SurfacePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractSurface is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSurface=model_.AbstractSurface(\n')
            self.AbstractSurface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractSurface':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSurface> element')
            self.set_AbstractSurface(obj_)
# end class SurfacePropertyType


class SurfaceArrayPropertyType(GeneratedsSuper):
    """gml:SurfaceArrayPropertyType is a container for an array of
    surfaces. The elements are always contained in the array
    property, referencing geometry elements or arrays of geometry
    elements via XLinks is not supported."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractSurface=None):
        self.owns = _cast(None, owns)
        self.AbstractSurface = AbstractSurface
    def factory(*args_, **kwargs_):
        if SurfaceArrayPropertyType.subclass:
            return SurfaceArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return SurfaceArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractSurface(self): return self.AbstractSurface
    def set_AbstractSurface(self, AbstractSurface): self.AbstractSurface = AbstractSurface
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='SurfaceArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SurfaceArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SurfaceArrayPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SurfaceArrayPropertyType', fromsubclass_=False):
        if self.AbstractSurface is not None:
            self.AbstractSurface.export(outfile, level, namespace_, name_='AbstractSurface')
    def hasContent_(self):
        if (
            self.AbstractSurface is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SurfaceArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractSurface is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSurface=model_.AbstractSurface(\n')
            self.AbstractSurface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractSurface':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSurface> element')
            self.set_AbstractSurface(obj_)
# end class SurfaceArrayPropertyType


class AbstractRingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractRingType.subclass:
            return AbstractRingType.subclass(*args_, **kwargs_)
        else:
            return AbstractRingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractRingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractRingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractRingType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractRingType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractRingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractRingType


class AbstractRingPropertyType(GeneratedsSuper):
    """A property with the content model of gml:AbstractRingPropertyType
    encapsulates a ring to represent the surface boundary property
    of a surface."""
    subclass = None
    superclass = None
    def __init__(self, AbstractRing=None):
        self.AbstractRing = AbstractRing
    def factory(*args_, **kwargs_):
        if AbstractRingPropertyType.subclass:
            return AbstractRingPropertyType.subclass(*args_, **kwargs_)
        else:
            return AbstractRingPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractRing(self): return self.AbstractRing
    def set_AbstractRing(self, AbstractRing): self.AbstractRing = AbstractRing
    def export(self, outfile, level, namespace_='', name_='AbstractRingPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractRingPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractRingPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractRingPropertyType', fromsubclass_=False):
        if self.AbstractRing is not None:
            self.AbstractRing.export(outfile, level, namespace_, name_='AbstractRing')
    def hasContent_(self):
        if (
            self.AbstractRing is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractRingPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractRing is not None:
            showIndent(outfile, level)
            outfile.write('AbstractRing=model_.AbstractRing(\n')
            self.AbstractRing.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractRing':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractRing> element')
            self.set_AbstractRing(obj_)
# end class AbstractRingPropertyType


class LinearRingType(AbstractRingType):
    subclass = None
    superclass = AbstractRingType
    def __init__(self, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None):
        super(LinearRingType, self).__init__()
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
    def factory(*args_, **kwargs_):
        if LinearRingType.subclass:
            return LinearRingType.subclass(*args_, **kwargs_)
        else:
            return LinearRingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def export(self, outfile, level, namespace_='', name_='LinearRingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearRingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearRingType'):
        super(LinearRingType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LinearRingType')
    def exportChildren(self, outfile, level, namespace_='', name_='LinearRingType', fromsubclass_=False):
        super(LinearRingType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            super(LinearRingType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearRingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LinearRingType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LinearRingType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LinearRingType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        super(LinearRingType, self).buildChildren(child_, node, nodeName_, True)
# end class LinearRingType


class LinearRingPropertyType(GeneratedsSuper):
    """A property with the content model of gml:LinearRingPropertyType
    encapsulates a linear ring to represent a component of a surface
    boundary."""
    subclass = None
    superclass = None
    def __init__(self, LinearRing=None):
        self.LinearRing = LinearRing
    def factory(*args_, **kwargs_):
        if LinearRingPropertyType.subclass:
            return LinearRingPropertyType.subclass(*args_, **kwargs_)
        else:
            return LinearRingPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinearRing(self): return self.LinearRing
    def set_LinearRing(self, LinearRing): self.LinearRing = LinearRing
    def export(self, outfile, level, namespace_='', name_='LinearRingPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearRingPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearRingPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinearRingPropertyType', fromsubclass_=False):
        if self.LinearRing is not None:
            self.LinearRing.export(outfile, level, namespace_, name_='LinearRing', )
    def hasContent_(self):
        if (
            self.LinearRing is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearRingPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LinearRing is not None:
            showIndent(outfile, level)
            outfile.write('LinearRing=model_.LinearRing(\n')
            self.LinearRing.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinearRing':
            obj_ = LinearRingType.factory()
            obj_.build(child_)
            self.set_LinearRing(obj_)
# end class LinearRingPropertyType


class GeometryPropertyType(GeneratedsSuper):
    """A geometric property may either be any geometry element encapsulated
    in an element of this type or an XLink reference to a remote
    geometry element (where remote includes geometry elements
    located elsewhere in the same or another document). Note that
    either the reference or the contained element shall be given,
    but not both or none. If a feature has a property that takes a
    geometry element as its value, this is called a geometry
    property. A generic type for such a geometry property is
    GeometryPropertyType."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractGeometry=None):
        self.owns = _cast(None, owns)
        self.AbstractGeometry = AbstractGeometry
    def factory(*args_, **kwargs_):
        if GeometryPropertyType.subclass:
            return GeometryPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeometryPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='GeometryPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeometryPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeometryPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GeometryPropertyType', fromsubclass_=False):
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
    def hasContent_(self):
        if (
            self.AbstractGeometry is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeometryPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
# end class GeometryPropertyType


class GeometryArrayPropertyType(GeneratedsSuper):
    """If a feature has a property which takes an array of geometry
    elements as its value, this is called a geometry array property.
    A generic type for such a geometry property is
    GeometryArrayPropertyType. The elements are always contained
    inline in the array property, referencing geometry elements or
    arrays of geometry elements via XLinks is not supported."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractGeometry=None):
        self.owns = _cast(None, owns)
        self.AbstractGeometry = AbstractGeometry
    def factory(*args_, **kwargs_):
        if GeometryArrayPropertyType.subclass:
            return GeometryArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeometryArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='GeometryArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeometryArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeometryArrayPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GeometryArrayPropertyType', fromsubclass_=False):
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
    def hasContent_(self):
        if (
            self.AbstractGeometry is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeometryArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
# end class GeometryArrayPropertyType


class DirectPositionType(GeneratedsSuper):
    """Direct position instances hold the coordinates for a position within
    some coordinate reference system (CRS). Since direct positions,
    as data types, will often be included in larger objects (such as
    geometry elements) that have references to CRS, the srsName
    attribute will in general be missing, if this particular direct
    position is included in a larger element with such a reference
    to a CRS. In this case, the CRS is implicitly assumed to take on
    the value of the containing object's CRS. if no srsName
    attribute is given, the CRS shall be specified as part of the
    larger context this geometry element is part of, typically a
    geometric object like a point, curve, etc."""
    subclass = None
    superclass = None
    def __init__(self, srsName=None, srsDimension=None, valueOf_=None, extensiontype_=None):
        self.srsName = _cast(None, srsName)
        self.srsDimension = _cast(None, srsDimension)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DirectPositionType.subclass:
            return DirectPositionType.subclass(*args_, **kwargs_)
        else:
            return DirectPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_srsName(self): return self.srsName
    def set_srsName(self, srsName): self.srsName = srsName
    def get_srsDimension(self): return self.srsDimension
    def set_srsDimension(self, srsDimension): self.srsDimension = srsDimension
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DirectPositionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectPositionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectPositionType'):
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            outfile.write(' srsName=%s' % (quote_attrib(self.srsName), ))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            outfile.write(' srsDimension=%s' % (quote_attrib(self.srsDimension), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DirectPositionType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectPositionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            showIndent(outfile, level)
            outfile.write('srsName = %s,\n' % (self.srsName,))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            showIndent(outfile, level)
            outfile.write('srsDimension = %s,\n' % (self.srsDimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('srsName', node)
        if value is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            self.srsName = value
        value = find_attr_value_('srsDimension', node)
        if value is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            self.srsDimension = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DirectPositionType


class DirectPositionListType(GeneratedsSuper):
    """posList instances (and other instances with the content model
    specified by DirectPositionListType) hold the coordinates for a
    sequence of direct positions within the same coordinate
    reference system (CRS). if no srsName attribute is given, the
    CRS shall be specified as part of the larger context this
    geometry element is part of, typically a geometric object like a
    point, curve, etc. The optional attribute count specifies the
    number of direct positions in the list. If the attribute count
    is present then the attribute srsDimension shall be present,
    too. The number of entries in the list is equal to the product
    of the dimensionality of the coordinate reference system (i.e.
    it is a derived value of the coordinate reference system
    definition) and the number of direct positions."""
    subclass = None
    superclass = None
    def __init__(self, count=None, srsName=None, srsDimension=None, valueOf_=None):
        self.count = _cast(None, count)
        self.srsName = _cast(None, srsName)
        self.srsDimension = _cast(None, srsDimension)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DirectPositionListType.subclass:
            return DirectPositionListType.subclass(*args_, **kwargs_)
        else:
            return DirectPositionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_srsName(self): return self.srsName
    def set_srsName(self, srsName): self.srsName = srsName
    def get_srsDimension(self): return self.srsDimension
    def set_srsDimension(self, srsDimension): self.srsDimension = srsDimension
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='DirectPositionListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectPositionListType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectPositionListType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.append('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            outfile.write(' srsName=%s' % (quote_attrib(self.srsName), ))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            outfile.write(' srsDimension=%s' % (quote_attrib(self.srsDimension), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DirectPositionListType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectPositionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.append('count')
            showIndent(outfile, level)
            outfile.write('count = %s,\n' % (self.count,))
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            showIndent(outfile, level)
            outfile.write('srsName = %s,\n' % (self.srsName,))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            showIndent(outfile, level)
            outfile.write('srsDimension = %s,\n' % (self.srsDimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.append('count')
            self.count = value
        value = find_attr_value_('srsName', node)
        if value is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            self.srsName = value
        value = find_attr_value_('srsDimension', node)
        if value is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            self.srsDimension = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DirectPositionListType


class VectorType(DirectPositionType):
    """For some applications the components of the position may be adjusted
    to yield a unit vector."""
    subclass = None
    superclass = DirectPositionType
    def __init__(self, srsName=None, srsDimension=None, valueOf_=None):
        super(VectorType, self).__init__(srsName, srsDimension, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if VectorType.subclass:
            return VectorType.subclass(*args_, **kwargs_)
        else:
            return VectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='VectorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VectorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VectorType'):
        super(VectorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VectorType')
    def exportChildren(self, outfile, level, namespace_='', name_='VectorType', fromsubclass_=False):
        super(VectorType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(VectorType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VectorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VectorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VectorType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VectorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VectorType


class EnvelopeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, srsName=None, srsDimension=None, lowerCorner=None, upperCorner=None, pos=None, coordinates=None, extensiontype_=None):
        self.srsName = _cast(None, srsName)
        self.srsDimension = _cast(None, srsDimension)
        self.lowerCorner = lowerCorner
        self.upperCorner = upperCorner
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        self.coordinates = coordinates
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EnvelopeType.subclass:
            return EnvelopeType.subclass(*args_, **kwargs_)
        else:
            return EnvelopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lowerCorner(self): return self.lowerCorner
    def set_lowerCorner(self, lowerCorner): self.lowerCorner = lowerCorner
    def get_upperCorner(self): return self.upperCorner
    def set_upperCorner(self, upperCorner): self.upperCorner = upperCorner
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_srsName(self): return self.srsName
    def set_srsName(self, srsName): self.srsName = srsName
    def get_srsDimension(self): return self.srsDimension
    def set_srsDimension(self, srsDimension): self.srsDimension = srsDimension
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='EnvelopeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvelopeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvelopeType'):
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            outfile.write(' srsName=%s' % (quote_attrib(self.srsName), ))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            outfile.write(' srsDimension=%s' % (quote_attrib(self.srsDimension), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EnvelopeType', fromsubclass_=False):
        if self.lowerCorner is not None:
            self.lowerCorner.export(outfile, level, namespace_, name_='lowerCorner', )
        if self.upperCorner is not None:
            self.upperCorner.export(outfile, level, namespace_, name_='upperCorner', )
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
    def hasContent_(self):
        if (
            self.lowerCorner is not None or
            self.upperCorner is not None or
            self.pos or
            self.coordinates is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EnvelopeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            showIndent(outfile, level)
            outfile.write('srsName = %s,\n' % (self.srsName,))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            showIndent(outfile, level)
            outfile.write('srsDimension = %s,\n' % (self.srsDimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.lowerCorner is not None:
            showIndent(outfile, level)
            outfile.write('lowerCorner=model_.DirectPositionType(\n')
            self.lowerCorner.exportLiteral(outfile, level, name_='lowerCorner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.upperCorner is not None:
            showIndent(outfile, level)
            outfile.write('upperCorner=model_.DirectPositionType(\n')
            self.upperCorner.exportLiteral(outfile, level, name_='upperCorner')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('srsName', node)
        if value is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            self.srsName = value
        value = find_attr_value_('srsDimension', node)
        if value is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            self.srsDimension = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lowerCorner':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_lowerCorner(obj_)
        elif nodeName_ == 'upperCorner':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_upperCorner(obj_)
        elif nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
# end class EnvelopeType


class GeometricPrimitivePropertyType(GeneratedsSuper):
    """A property that has a geometric primitive as its value domain may
    either be an appropriate geometry element encapsulated in an
    element of this type or an XLink reference to a remote geometry
    element (where remote includes geometry elements located
    elsewhere in the same document). Either the reference or the
    contained element shall be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractGeometricPrimitive=None):
        self.owns = _cast(None, owns)
        self.AbstractGeometricPrimitive = AbstractGeometricPrimitive
    def factory(*args_, **kwargs_):
        if GeometricPrimitivePropertyType.subclass:
            return GeometricPrimitivePropertyType.subclass(*args_, **kwargs_)
        else:
            return GeometricPrimitivePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeometricPrimitive(self): return self.AbstractGeometricPrimitive
    def set_AbstractGeometricPrimitive(self, AbstractGeometricPrimitive): self.AbstractGeometricPrimitive = AbstractGeometricPrimitive
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='GeometricPrimitivePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeometricPrimitivePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeometricPrimitivePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GeometricPrimitivePropertyType', fromsubclass_=False):
        if self.AbstractGeometricPrimitive is not None:
            self.AbstractGeometricPrimitive.export(outfile, level, namespace_, name_='AbstractGeometricPrimitive')
    def hasContent_(self):
        if (
            self.AbstractGeometricPrimitive is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeometricPrimitivePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeometricPrimitive is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometricPrimitive=model_.AbstractGeometricPrimitive(\n')
            self.AbstractGeometricPrimitive.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeometricPrimitive':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometricPrimitive> element')
            self.set_AbstractGeometricPrimitive(obj_)
# end class GeometricPrimitivePropertyType


class PointPropertyType(GeneratedsSuper):
    """A property that has a point as its value domain may either be an
    appropriate geometry element encapsulated in an element of this
    type or an XLink reference to a remote geometry element (where
    remote includes geometry elements located elsewhere in the same
    document). Either the reference or the contained element shall
    be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', Point=None):
        self.owns = _cast(None, owns)
        self.Point = Point
    def factory(*args_, **kwargs_):
        if PointPropertyType.subclass:
            return PointPropertyType.subclass(*args_, **kwargs_)
        else:
            return PointPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point(self): return self.Point
    def set_Point(self, Point): self.Point = Point
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='PointPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PointPropertyType', fromsubclass_=False):
        if self.Point is not None:
            self.Point.export(outfile, level, namespace_, name_='Point', )
    def hasContent_(self):
        if (
            self.Point is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Point is not None:
            showIndent(outfile, level)
            outfile.write('Point=model_.Point(\n')
            self.Point.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point':
            obj_ = PointType.factory()
            obj_.build(child_)
            self.set_Point(obj_)
# end class PointPropertyType


class PointArrayPropertyType(GeneratedsSuper):
    """gml:PointArrayPropertyType is a container for an array of points.
    The elements are always contained inline in the array property,
    referencing geometry elements or arrays of geometry elements via
    XLinks is not supported."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', Point=None):
        self.owns = _cast(None, owns)
        self.Point = Point
    def factory(*args_, **kwargs_):
        if PointArrayPropertyType.subclass:
            return PointArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return PointArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point(self): return self.Point
    def set_Point(self, Point): self.Point = Point
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='PointArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointArrayPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PointArrayPropertyType', fromsubclass_=False):
        if self.Point is not None:
            self.Point.export(outfile, level, namespace_, name_='Point', )
    def hasContent_(self):
        if (
            self.Point is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Point is not None:
            showIndent(outfile, level)
            outfile.write('Point=model_.Point(\n')
            self.Point.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point':
            obj_ = PointType.factory()
            obj_.build(child_)
            self.set_Point(obj_)
# end class PointArrayPropertyType


class CurvePropertyType(GeneratedsSuper):
    """A property that has a curve as its value domain may either be an
    appropriate geometry element encapsulated in an element of this
    type or an XLink reference to a remote geometry element (where
    remote includes geometry elements located elsewhere in the same
    document). Either the reference or the contained element shall
    be given, but neither both nor none."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractCurve=None):
        self.owns = _cast(None, owns)
        self.AbstractCurve = AbstractCurve
    def factory(*args_, **kwargs_):
        if CurvePropertyType.subclass:
            return CurvePropertyType.subclass(*args_, **kwargs_)
        else:
            return CurvePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCurve(self): return self.AbstractCurve
    def set_AbstractCurve(self, AbstractCurve): self.AbstractCurve = AbstractCurve
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='CurvePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurvePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurvePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CurvePropertyType', fromsubclass_=False):
        if self.AbstractCurve is not None:
            self.AbstractCurve.export(outfile, level, namespace_, name_='AbstractCurve')
    def hasContent_(self):
        if (
            self.AbstractCurve is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CurvePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractCurve is not None:
            showIndent(outfile, level)
            outfile.write('AbstractCurve=model_.AbstractCurve(\n')
            self.AbstractCurve.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCurve':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCurve> element')
            self.set_AbstractCurve(obj_)
# end class CurvePropertyType


class CurveArrayPropertyType(GeneratedsSuper):
    """A container for an array of curves. The elements are always
    contained in the array property, referencing geometry elements
    or arrays of geometry elements via XLinks is not supported."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractCurve=None):
        self.owns = _cast(None, owns)
        self.AbstractCurve = AbstractCurve
    def factory(*args_, **kwargs_):
        if CurveArrayPropertyType.subclass:
            return CurveArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return CurveArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCurve(self): return self.AbstractCurve
    def set_AbstractCurve(self, AbstractCurve): self.AbstractCurve = AbstractCurve
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='CurveArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurveArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurveArrayPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CurveArrayPropertyType', fromsubclass_=False):
        if self.AbstractCurve is not None:
            self.AbstractCurve.export(outfile, level, namespace_, name_='AbstractCurve')
    def hasContent_(self):
        if (
            self.AbstractCurve is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CurveArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractCurve is not None:
            showIndent(outfile, level)
            outfile.write('AbstractCurve=model_.AbstractCurve(\n')
            self.AbstractCurve.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCurve':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCurve> element')
            self.set_AbstractCurve(obj_)
# end class CurveArrayPropertyType


class UnitOfMeasureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uom=None, extensiontype_=None):
        self.uom = _cast(None, uom)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if UnitOfMeasureType.subclass:
            return UnitOfMeasureType.subclass(*args_, **kwargs_)
        else:
            return UnitOfMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='UnitOfMeasureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitOfMeasureType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitOfMeasureType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='UnitOfMeasureType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnitOfMeasureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            showIndent(outfile, level)
            outfile.write('uom = %s,\n' % (self.uom,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            self.uom = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnitOfMeasureType


class DerivationUnitTermType(UnitOfMeasureType):
    subclass = None
    superclass = UnitOfMeasureType
    def __init__(self, uom=None, exponent=None):
        super(DerivationUnitTermType, self).__init__(uom, )
        self.exponent = _cast(None, exponent)
        pass
    def factory(*args_, **kwargs_):
        if DerivationUnitTermType.subclass:
            return DerivationUnitTermType.subclass(*args_, **kwargs_)
        else:
            return DerivationUnitTermType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exponent(self): return self.exponent
    def set_exponent(self, exponent): self.exponent = exponent
    def export(self, outfile, level, namespace_='', name_='DerivationUnitTermType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivationUnitTermType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivationUnitTermType'):
        super(DerivationUnitTermType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DerivationUnitTermType')
        if self.exponent is not None and 'exponent' not in already_processed:
            already_processed.append('exponent')
            outfile.write(' exponent=%s' % (quote_attrib(self.exponent), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DerivationUnitTermType', fromsubclass_=False):
        super(DerivationUnitTermType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(DerivationUnitTermType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DerivationUnitTermType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.exponent is not None and 'exponent' not in already_processed:
            already_processed.append('exponent')
            showIndent(outfile, level)
            outfile.write('exponent = %s,\n' % (self.exponent,))
        super(DerivationUnitTermType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DerivationUnitTermType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exponent', node)
        if value is not None and 'exponent' not in already_processed:
            already_processed.append('exponent')
            self.exponent = value
        super(DerivationUnitTermType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DerivationUnitTermType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DerivationUnitTermType


class ConversionToPreferredUnitType(UnitOfMeasureType):
    """The inherited attribute uom references the preferred unit that this
    conversion applies to. The conversion of a unit to the preferred
    unit for this physical quantity type is specified by an
    arithmetic conversion (scaling and/or offset). The content model
    extends gml:UnitOfMeasureType, which has a mandatory attribute
    uom which identifies the preferred unit for the physical
    quantity type that this conversion applies to. The conversion is
    specified by a choice of - gml:factor, which defines the scale
    factor, or - gml:formula, which defines a formula by which a
    value using the conventional unit of measure can be converted to
    obtain the corresponding value using the preferred unit of
    measure. The formula defines the parameters of a simple formula
    by which a value using the conventional unit of measure can be
    converted to the corresponding value using the preferred unit of
    measure. The formula element contains elements a, b, c and d,
    whose values use the XML Schema type double. These values are
    used in the formula y = (a + bx) / (c + dx), where x is a value
    using this unit, and y is the corresponding value using the base
    unit. The elements a and d are optional, and if values are not
    provided, those parameters are considered to be zero. If values
    are not provided for both a and d, the formula is equivalent to
    a fraction with numerator and denominator parameters."""
    subclass = None
    superclass = UnitOfMeasureType
    def __init__(self, uom=None, factor=None, formula=None):
        super(ConversionToPreferredUnitType, self).__init__(uom, )
        self.factor = factor
        self.formula = formula
    def factory(*args_, **kwargs_):
        if ConversionToPreferredUnitType.subclass:
            return ConversionToPreferredUnitType.subclass(*args_, **kwargs_)
        else:
            return ConversionToPreferredUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_factor(self): return self.factor
    def set_factor(self, factor): self.factor = factor
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def export(self, outfile, level, namespace_='', name_='ConversionToPreferredUnitType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConversionToPreferredUnitType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConversionToPreferredUnitType'):
        super(ConversionToPreferredUnitType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConversionToPreferredUnitType')
    def exportChildren(self, outfile, level, namespace_='', name_='ConversionToPreferredUnitType', fromsubclass_=False):
        super(ConversionToPreferredUnitType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.factor is not None:
            showIndent(outfile, level)
            outfile.write('<%sfactor>%s</%sfactor>\n' % (namespace_, self.gds_format_string(quote_xml(self.factor).encode(ExternalEncoding), input_name='factor'), namespace_))
        if self.formula is not None:
            self.formula.export(outfile, level, namespace_, name_='formula', )
    def hasContent_(self):
        if (
            self.factor is not None or
            self.formula is not None or
            super(ConversionToPreferredUnitType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConversionToPreferredUnitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConversionToPreferredUnitType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConversionToPreferredUnitType, self).exportLiteralChildren(outfile, level, name_)
        if self.factor is not None:
            showIndent(outfile, level)
            outfile.write('factor=%s,\n' % quote_python(self.factor).encode(ExternalEncoding))
        if self.formula is not None:
            showIndent(outfile, level)
            outfile.write('formula=model_.FormulaType(\n')
            self.formula.exportLiteral(outfile, level, name_='formula')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ConversionToPreferredUnitType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'factor':
            factor_ = child_.text
            factor_ = self.gds_validate_string(factor_, node, 'factor')
            self.factor = factor_
        elif nodeName_ == 'formula':
            obj_ = FormulaType.factory()
            obj_.build(child_)
            self.set_formula(obj_)
        super(ConversionToPreferredUnitType, self).buildChildren(child_, node, nodeName_, True)
# end class ConversionToPreferredUnitType


class FormulaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, a=None, b=None, c=None, d=None):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
    def factory(*args_, **kwargs_):
        if FormulaType.subclass:
            return FormulaType.subclass(*args_, **kwargs_)
        else:
            return FormulaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_a(self): return self.a
    def set_a(self, a): self.a = a
    def get_b(self): return self.b
    def set_b(self, b): self.b = b
    def get_c(self): return self.c
    def set_c(self, c): self.c = c
    def get_d(self): return self.d
    def set_d(self, d): self.d = d
    def export(self, outfile, level, namespace_='', name_='FormulaType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormulaType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FormulaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FormulaType', fromsubclass_=False):
        if self.a is not None:
            showIndent(outfile, level)
            outfile.write('<%sa>%s</%sa>\n' % (namespace_, self.gds_format_string(quote_xml(self.a).encode(ExternalEncoding), input_name='a'), namespace_))
        if self.b is not None:
            showIndent(outfile, level)
            outfile.write('<%sb>%s</%sb>\n' % (namespace_, self.gds_format_string(quote_xml(self.b).encode(ExternalEncoding), input_name='b'), namespace_))
        if self.c is not None:
            showIndent(outfile, level)
            outfile.write('<%sc>%s</%sc>\n' % (namespace_, self.gds_format_string(quote_xml(self.c).encode(ExternalEncoding), input_name='c'), namespace_))
        if self.d is not None:
            showIndent(outfile, level)
            outfile.write('<%sd>%s</%sd>\n' % (namespace_, self.gds_format_string(quote_xml(self.d).encode(ExternalEncoding), input_name='d'), namespace_))
    def hasContent_(self):
        if (
            self.a is not None or
            self.b is not None or
            self.c is not None or
            self.d is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FormulaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.a is not None:
            showIndent(outfile, level)
            outfile.write('a=%s,\n' % quote_python(self.a).encode(ExternalEncoding))
        if self.b is not None:
            showIndent(outfile, level)
            outfile.write('b=%s,\n' % quote_python(self.b).encode(ExternalEncoding))
        if self.c is not None:
            showIndent(outfile, level)
            outfile.write('c=%s,\n' % quote_python(self.c).encode(ExternalEncoding))
        if self.d is not None:
            showIndent(outfile, level)
            outfile.write('d=%s,\n' % quote_python(self.d).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'a':
            a_ = child_.text
            a_ = self.gds_validate_string(a_, node, 'a')
            self.a = a_
        elif nodeName_ == 'b':
            b_ = child_.text
            b_ = self.gds_validate_string(b_, node, 'b')
            self.b = b_
        elif nodeName_ == 'c':
            c_ = child_.text
            c_ = self.gds_validate_string(c_, node, 'c')
            self.c = c_
        elif nodeName_ == 'd':
            d_ = child_.text
            d_ = self.gds_validate_string(d_, node, 'd')
            self.d = d_
# end class FormulaType


class DefinitionBaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        self.id = _cast(None, id)
        if metaDataProperty is None:
            self.metaDataProperty = []
        else:
            self.metaDataProperty = metaDataProperty
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DefinitionBaseType.subclass:
            return DefinitionBaseType.subclass(*args_, **kwargs_)
        else:
            return DefinitionBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaDataProperty(self): return self.metaDataProperty
    def set_metaDataProperty(self, metaDataProperty): self.metaDataProperty = metaDataProperty
    def add_metaDataProperty(self, value): self.metaDataProperty.append(value)
    def insert_metaDataProperty(self, index, value): self.metaDataProperty[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name(self, index, value): self.name[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DefinitionBaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionBaseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefinitionBaseType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DefinitionBaseType', fromsubclass_=False):
        for metaDataProperty_ in self.metaDataProperty:
            metaDataProperty_.export(outfile, level, namespace_, name_='metaDataProperty')
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_, name_='descriptionReference')
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', )
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name')
    def hasContent_(self):
        if (
            self.metaDataProperty or
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefinitionBaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metaDataProperty=[\n')
        level += 1
        for metaDataProperty_ in self.metaDataProperty:
            showIndent(outfile, level)
            outfile.write('model_.metaDataProperty(\n')
            metaDataProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptionReference is not None:
            showIndent(outfile, level)
            outfile.write('descriptionReference=model_.descriptionReference(\n')
            self.descriptionReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.identifier(\n')
            self.identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.name(\n')
            name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaDataProperty':
            obj_ = MetaDataPropertyType.factory()
            obj_.build(child_)
            self.metaDataProperty.append(obj_)
        elif nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_descriptionReference(obj_)
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
# end class DefinitionBaseType


class DefinitionType(DefinitionBaseType):
    subclass = None
    superclass = DefinitionBaseType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, extensiontype_=None):
        super(DefinitionType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.remarks = remarks
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DefinitionType.subclass:
            return DefinitionType.subclass(*args_, **kwargs_)
        else:
            return DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remarks(self): return self.remarks
    def set_remarks(self, remarks): self.remarks = remarks
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefinitionType'):
        super(DefinitionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DefinitionType', fromsubclass_=False):
        super(DefinitionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('<%sremarks>%s</%sremarks>\n' % (namespace_, self.gds_format_string(quote_xml(self.remarks).encode(ExternalEncoding), input_name='remarks'), namespace_))
    def hasContent_(self):
        if (
            self.remarks is not None or
            super(DefinitionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DefinitionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DefinitionType, self).exportLiteralChildren(outfile, level, name_)
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('remarks=%s,\n' % quote_python(self.remarks).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(DefinitionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'remarks':
            remarks_ = child_.text
            remarks_ = self.gds_validate_string(remarks_, node, 'remarks')
            self.remarks = remarks_
        super(DefinitionType, self).buildChildren(child_, node, nodeName_, True)
# end class DefinitionType


class DictionaryType(DefinitionType):
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, dictionaryEntry=None, indirectEntry=None):
        super(DictionaryType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        self.aggregationType = _cast(None, aggregationType)
        if dictionaryEntry is None:
            self.dictionaryEntry = []
        else:
            self.dictionaryEntry = dictionaryEntry
        if indirectEntry is None:
            self.indirectEntry = []
        else:
            self.indirectEntry = indirectEntry
    def factory(*args_, **kwargs_):
        if DictionaryType.subclass:
            return DictionaryType.subclass(*args_, **kwargs_)
        else:
            return DictionaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dictionaryEntry(self): return self.dictionaryEntry
    def set_dictionaryEntry(self, dictionaryEntry): self.dictionaryEntry = dictionaryEntry
    def add_dictionaryEntry(self, value): self.dictionaryEntry.append(value)
    def insert_dictionaryEntry(self, index, value): self.dictionaryEntry[index] = value
    def get_indirectEntry(self): return self.indirectEntry
    def set_indirectEntry(self, indirectEntry): self.indirectEntry = indirectEntry
    def add_indirectEntry(self, value): self.indirectEntry.append(value)
    def insert_indirectEntry(self, index, value): self.indirectEntry[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='DictionaryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DictionaryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DictionaryType'):
        super(DictionaryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DictionaryType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DictionaryType', fromsubclass_=False):
        super(DictionaryType, self).exportChildren(outfile, level, namespace_, name_, True)
        for dictionaryEntry_ in self.dictionaryEntry:
            dictionaryEntry_.export(outfile, level, namespace_, name_='dictionaryEntry')
        for indirectEntry_ in self.indirectEntry:
            indirectEntry_.export(outfile, level, namespace_, name_='indirectEntry')
    def hasContent_(self):
        if (
            self.dictionaryEntry or
            self.indirectEntry or
            super(DictionaryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DictionaryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(DictionaryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DictionaryType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('dictionaryEntry=[\n')
        level += 1
        for dictionaryEntry_ in self.dictionaryEntry:
            showIndent(outfile, level)
            outfile.write('model_.dictionaryEntry(\n')
            dictionaryEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('indirectEntry=[\n')
        level += 1
        for indirectEntry_ in self.indirectEntry:
            showIndent(outfile, level)
            outfile.write('model_.indirectEntry(\n')
            indirectEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(DictionaryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dictionaryEntry':
            obj_ = DictionaryEntryType.factory()
            obj_.build(child_)
            self.dictionaryEntry.append(obj_)
        elif nodeName_ == 'indirectEntry':
            obj_ = IndirectEntryType.factory()
            obj_.build(child_)
            self.indirectEntry.append(obj_)
        super(DictionaryType, self).buildChildren(child_, node, nodeName_, True)
# end class DictionaryType


class AbstractObject(GeneratedsSuper):
    """This element has no type defined, and is therefore implicitly
    (according to the rules of W3C XML Schema) an XML Schema
    anyType. It is used as the head of an XML Schema substitution
    group which unifies complex content and certain simple content
    elements used for datatypes in GML, including the
    gml:AbstractGML substitution group."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if AbstractObject.subclass:
            return AbstractObject.subclass(*args_, **kwargs_)
        else:
            return AbstractObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='AbstractObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractObject'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractObject', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractObject


class AbstractGMLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        self.id = _cast(None, id)
        if metaDataProperty is None:
            self.metaDataProperty = []
        else:
            self.metaDataProperty = metaDataProperty
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGMLType.subclass:
            return AbstractGMLType.subclass(*args_, **kwargs_)
        else:
            return AbstractGMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaDataProperty(self): return self.metaDataProperty
    def set_metaDataProperty(self, metaDataProperty): self.metaDataProperty = metaDataProperty
    def add_metaDataProperty(self, value): self.metaDataProperty.append(value)
    def insert_metaDataProperty(self, index, value): self.metaDataProperty[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name(self, index, value): self.name[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGMLType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGMLType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGMLType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGMLType', fromsubclass_=False):
        for metaDataProperty_ in self.metaDataProperty:
            metaDataProperty_.export(outfile, level, namespace_, name_='metaDataProperty')
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_, name_='descriptionReference')
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier')
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name')
    def hasContent_(self):
        if (
            self.metaDataProperty or
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGMLType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metaDataProperty=[\n')
        level += 1
        for metaDataProperty_ in self.metaDataProperty:
            showIndent(outfile, level)
            outfile.write('model_.metaDataProperty(\n')
            metaDataProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptionReference is not None:
            showIndent(outfile, level)
            outfile.write('descriptionReference=model_.descriptionReference(\n')
            self.descriptionReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.identifier(\n')
            self.identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.name(\n')
            name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaDataProperty':
            obj_ = MetaDataPropertyType.factory()
            obj_.build(child_)
            self.metaDataProperty.append(obj_)
        elif nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_descriptionReference(obj_)
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
# end class AbstractGMLType


class AssociationRoleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', anytypeobjs_=None):
        self.owns = _cast(None, owns)
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if AssociationRoleType.subclass:
            return AssociationRoleType.subclass(*args_, **kwargs_)
        else:
            return AssociationRoleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='AssociationRoleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociationRoleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssociationRoleType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssociationRoleType', fromsubclass_=False):
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssociationRoleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'AssociationRoleType')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class AssociationRoleType


class ReferenceType(GeneratedsSuper):
    """gml:ReferenceType is intended to be used in application schemas
    directly, if a property element shall use a "by-reference only"
    encoding."""
    subclass = None
    superclass = None
    def __init__(self, owns='false'):
        self.owns = _cast(None, owns)
        pass
    def factory(*args_, **kwargs_):
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceType


class InlinePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', anytypeobjs_=None):
        self.owns = _cast(None, owns)
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if InlinePropertyType.subclass:
            return InlinePropertyType.subclass(*args_, **kwargs_)
        else:
            return InlinePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='InlinePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InlinePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InlinePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InlinePropertyType', fromsubclass_=False):
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InlinePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'InlinePropertyType')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class InlinePropertyType


class AbstractMemberType(GeneratedsSuper):
    """To create a collection of GML Objects that are not all features, a
    property type shall be derived by extension from
    gml:AbstractMemberType. This abstract property type is intended
    to be used only in object types where software shall be able to
    identify that an instance of such an object type is to be
    interpreted as a collection of objects. By default, this
    abstract property type does not imply any ownership of the
    objects in the collection. The owns attribute of
    gml:OwnershipAttributeGroup may be used on a property element
    instance to assert ownership of an object in the collection. A
    collection shall not own an object already owned by another
    object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', extensiontype_=None):
        self.owns = _cast(None, owns)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractMemberType.subclass:
            return AbstractMemberType.subclass(*args_, **kwargs_)
        else:
            return AbstractMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractMemberType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractMemberType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractMemberType


class AbstractMetadataPropertyType(GeneratedsSuper):
    """To associate metadata described by any XML Schema with a GML object,
    a property element shall be defined whose content model is
    derived by extension from gml:AbstractMetadataPropertyType. The
    value of such a property shall be metadata. The content model of
    such a property type, i.e. the metadata application schema shall
    be specified by the GML Application Schema. By default, this
    abstract property type does not imply any ownership of the
    metadata. The owns attribute of gml:OwnershipAttributeGroup may
    be used on a metadata property element instance to assert
    ownership of the metadata. If metadata following the conceptual
    model of ISO 19115 is to be encoded in a GML document, the
    corresponding Implementation Specification specified in ISO/TS
    19139 shall be used to encode the metadata information."""
    subclass = None
    superclass = None
    def __init__(self, owns='false'):
        self.owns = _cast(None, owns)
        pass
    def factory(*args_, **kwargs_):
        if AbstractMetadataPropertyType.subclass:
            return AbstractMetadataPropertyType.subclass(*args_, **kwargs_)
        else:
            return AbstractMetadataPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='AbstractMetadataPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMetadataPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractMetadataPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractMetadataPropertyType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractMetadataPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractMetadataPropertyType


class CodeType(GeneratedsSuper):
    """gml:CodeType is a generalized type to be used for a term, keyword or
    name. It adds a XML attribute codeSpace to a term, where the
    value of the codeSpace attribute (if present) shall indicate a
    dictionary, thesaurus, classification scheme, authority, or
    pattern for the term."""
    subclass = None
    superclass = None
    def __init__(self, codeSpace=None, valueOf_=None, extensiontype_=None):
        self.codeSpace = _cast(None, codeSpace)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CodeType.subclass:
            return CodeType.subclass(*args_, **kwargs_)
        else:
            return CodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='CodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeType'):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            outfile.write(' codeSpace=%s' % (quote_attrib(self.codeSpace), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CodeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            showIndent(outfile, level)
            outfile.write('codeSpace = %s,\n' % (self.codeSpace,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            self.codeSpace = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeType


class CodeWithAuthorityType(CodeType):
    """gml:CodeWithAuthorityType requires that the codeSpace attribute is
    provided in an instance."""
    subclass = None
    superclass = CodeType
    def __init__(self, codeSpace=None, valueOf_=None):
        super(CodeWithAuthorityType, self).__init__(codeSpace, valueOf_, )
        self.codeSpace = _cast(None, codeSpace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodeWithAuthorityType.subclass:
            return CodeWithAuthorityType.subclass(*args_, **kwargs_)
        else:
            return CodeWithAuthorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='CodeWithAuthorityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeWithAuthorityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeWithAuthorityType'):
        super(CodeWithAuthorityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CodeWithAuthorityType')
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            outfile.write(' codeSpace=%s' % (quote_attrib(self.codeSpace), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CodeWithAuthorityType', fromsubclass_=False):
        super(CodeWithAuthorityType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CodeWithAuthorityType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CodeWithAuthorityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            showIndent(outfile, level)
            outfile.write('codeSpace = %s,\n' % (self.codeSpace,))
        super(CodeWithAuthorityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CodeWithAuthorityType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            self.codeSpace = value
        super(CodeWithAuthorityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeWithAuthorityType


class MeasureType(GeneratedsSuper):
    """gml:MeasureType supports recording an amount encoded as a value of
    XML Schema double, together with a units of measure indicated by
    an attribute uom, short for "units Of measure". The value of the
    uom attribute identifies a reference system for the amount,
    usually a ratio or interval scale."""
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, extensiontype_=None):
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MeasureType.subclass:
            return MeasureType.subclass(*args_, **kwargs_)
        else:
            return MeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MeasureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasureType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MeasureType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MeasureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            showIndent(outfile, level)
            outfile.write('uom = %s,\n' % (self.uom,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            self.uom = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureType


class CoordinatesType(GeneratedsSuper):
    """This type is deprecated for tuples with ordinate values that are
    numbers. CoordinatesType is a text string, intended to be used
    to record an array of tuples or coordinates. While it is not
    possible to enforce the internal structure of the string through
    schema validation, some optional attributes have been provided
    in previous versions of GML to support a description of the
    internal structure. These attributes are deprecated. The
    attributes were intended to be used as follows: Decimal symbol
    used for a decimal point (default="." a stop or period) cs
    symbol used to separate components within a tuple or coordinate
    string (default="," a comma) ts symbol used to separate tuples
    or coordinate strings (default=" " a space) Since it is based on
    the XML Schema string type, CoordinatesType may be used in the
    construction of tables of tuples or arrays of tuples, including
    ones that contain mixed text and numeric values."""
    subclass = None
    superclass = None
    def __init__(self, cs=',', decimal='.', ts=' ', valueOf_=None):
        self.cs = _cast(None, cs)
        self.decimal = _cast(None, decimal)
        self.ts = _cast(None, ts)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CoordinatesType.subclass:
            return CoordinatesType.subclass(*args_, **kwargs_)
        else:
            return CoordinatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cs(self): return self.cs
    def set_cs(self, cs): self.cs = cs
    def get_decimal(self): return self.decimal
    def set_decimal(self, decimal): self.decimal = decimal
    def get_ts(self): return self.ts
    def set_ts(self, ts): self.ts = ts
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='CoordinatesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinatesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoordinatesType'):
        if self.cs is not None and 'cs' not in already_processed:
            already_processed.append('cs')
            outfile.write(' cs=%s' % (quote_attrib(self.cs), ))
        if self.decimal is not None and 'decimal' not in already_processed:
            already_processed.append('decimal')
            outfile.write(' decimal=%s' % (quote_attrib(self.decimal), ))
        if self.ts is not None and 'ts' not in already_processed:
            already_processed.append('ts')
            outfile.write(' ts=%s' % (quote_attrib(self.ts), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoordinatesType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoordinatesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cs is not None and 'cs' not in already_processed:
            already_processed.append('cs')
            showIndent(outfile, level)
            outfile.write('cs = %s,\n' % (self.cs,))
        if self.decimal is not None and 'decimal' not in already_processed:
            already_processed.append('decimal')
            showIndent(outfile, level)
            outfile.write('decimal = %s,\n' % (self.decimal,))
        if self.ts is not None and 'ts' not in already_processed:
            already_processed.append('ts')
            showIndent(outfile, level)
            outfile.write('ts = %s,\n' % (self.ts,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cs', node)
        if value is not None and 'cs' not in already_processed:
            already_processed.append('cs')
            self.cs = value
        value = find_attr_value_('decimal', node)
        if value is not None and 'decimal' not in already_processed:
            already_processed.append('decimal')
            self.decimal = value
        value = find_attr_value_('ts', node)
        if value is not None and 'ts' not in already_processed:
            already_processed.append('ts')
            self.ts = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoordinatesType


class CodeListType(GeneratedsSuper):
    """gml:CodeListType provides for lists of terms. The values in an
    instance element shall all be valid according to the rules of
    the dictionary, classification scheme, or authority identified
    by the value of its codeSpace attribute."""
    subclass = None
    superclass = None
    def __init__(self, codeSpace=None, valueOf_=None):
        self.codeSpace = _cast(None, codeSpace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodeListType.subclass:
            return CodeListType.subclass(*args_, **kwargs_)
        else:
            return CodeListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='CodeListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeListType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeListType'):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            outfile.write(' codeSpace=%s' % (quote_attrib(self.codeSpace), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CodeListType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CodeListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            showIndent(outfile, level)
            outfile.write('codeSpace = %s,\n' % (self.codeSpace,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            self.codeSpace = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeListType


class CodeOrNilReasonListType(GeneratedsSuper):
    """gml:CodeOrNilReasonListType provides for lists of terms. The values
    in an instance element shall all be valid according to the rules
    of the dictionary, classification scheme, or authority
    identified by the value of its codeSpace attribute. An instance
    element may also include embedded values from NilReasonType. It
    is intended to be used in situations where a term or
    classification is expected, but the value may be absent for some
    reason."""
    subclass = None
    superclass = None
    def __init__(self, codeSpace=None, valueOf_=None, extensiontype_=None):
        self.codeSpace = _cast(None, codeSpace)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CodeOrNilReasonListType.subclass:
            return CodeOrNilReasonListType.subclass(*args_, **kwargs_)
        else:
            return CodeOrNilReasonListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='CodeOrNilReasonListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeOrNilReasonListType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeOrNilReasonListType'):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            outfile.write(' codeSpace=%s' % (quote_attrib(self.codeSpace), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CodeOrNilReasonListType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CodeOrNilReasonListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            showIndent(outfile, level)
            outfile.write('codeSpace = %s,\n' % (self.codeSpace,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            self.codeSpace = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeOrNilReasonListType


class MeasureListType(GeneratedsSuper):
    """gml:MeasureListType provides for a list of quantities."""
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None):
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MeasureListType.subclass:
            return MeasureListType.subclass(*args_, **kwargs_)
        else:
            return MeasureListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='MeasureListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureListType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasureListType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MeasureListType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MeasureListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            showIndent(outfile, level)
            outfile.write('uom = %s,\n' % (self.uom,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            self.uom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureListType


class MeasureOrNilReasonListType(GeneratedsSuper):
    """gml:MeasureOrNilReasonListType provides for a list of quantities. An
    instance element may also include embedded values from
    NilReasonType. It is intended to be used in situations where a
    value is expected, but the value may be absent for some reason."""
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, extensiontype_=None):
        self.uom = _cast(None, uom)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MeasureOrNilReasonListType.subclass:
            return MeasureOrNilReasonListType.subclass(*args_, **kwargs_)
        else:
            return MeasureOrNilReasonListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MeasureOrNilReasonListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureOrNilReasonListType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasureOrNilReasonListType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MeasureOrNilReasonListType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MeasureOrNilReasonListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            showIndent(outfile, level)
            outfile.write('uom = %s,\n' % (self.uom,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            self.uom = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureOrNilReasonListType


class simple(GeneratedsSuper):
    """Intended for use as the type of user-declared elements to make them
    simple links."""
    subclass = None
    superclass = None
    def __init__(self, title=None, arcrole=None, actuate=None, href=None, role=None, show=None, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.title = _cast(None, title)
        self.arcrole = _cast(None, arcrole)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.show = _cast(None, show)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if simple.subclass:
            return simple.subclass(*args_, **kwargs_)
        else:
            return simple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='simple', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simple')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='simple'):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simple', fromsubclass_=False):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simple'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class simple


class extended(GeneratedsSuper):
    """Intended for use as the type of user-declared elements to make them
    extended links. Note that the elements referenced in the content
    model are all abstract. The intention is that by simply
    declaring elements with these as their substitutionGroup, all
    the right things will happen."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, role=None, title_attr=None, title=None, resource=None, locator=None, arc=None):
        self.type_ = _cast(None, type_)
        self.role = _cast(None, role)
        self.title_attr = _cast(None, title_attr)
        if title is None:
            self.title = []
        else:
            self.title = title
        if resource is None:
            self.resource = []
        else:
            self.resource = resource
        if locator is None:
            self.locator = []
        else:
            self.locator = locator
        if arc is None:
            self.arc = []
        else:
            self.arc = arc
    def factory(*args_, **kwargs_):
        if extended.subclass:
            return extended.subclass(*args_, **kwargs_)
        else:
            return extended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def add_resource(self, value): self.resource.append(value)
    def insert_resource(self, index, value): self.resource[index] = value
    def get_locator(self): return self.locator
    def set_locator(self, locator): self.locator = locator
    def add_locator(self, value): self.locator.append(value)
    def insert_locator(self, index, value): self.locator[index] = value
    def get_arc(self): return self.arc
    def set_arc(self, arc): self.arc = arc
    def add_arc(self, value): self.arc.append(value)
    def insert_arc(self, index, value): self.arc[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def export(self, outfile, level, namespace_='', name_='extended', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extended')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='extended'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            outfile.write(' title_attr=%s' % (self.gds_format_string(quote_attrib(self.title_attr).encode(ExternalEncoding), input_name='title_attr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='extended', fromsubclass_=False):
        for title_ in self.get_title():
            title_.export(outfile, level, namespace_, name_='title')
        for resource_ in self.get_resource():
            resource_.export(outfile, level, namespace_, name_='resource')
        for locator_ in self.get_locator():
            locator_.export(outfile, level, namespace_, name_='locator')
        for arc_ in self.get_arc():
            arc_.export(outfile, level, namespace_, name_='arc')
    def hasContent_(self):
        if (
            self.title or
            self.resource or
            self.locator or
            self.arc
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='extended'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            showIndent(outfile, level)
            outfile.write('title_attr = "%s",\n' % (self.title_attr,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resource=[\n')
        level += 1
        for resource_ in self.resource:
            showIndent(outfile, level)
            outfile.write('model_.resource(\n')
            resource_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('locator=[\n')
        level += 1
        for locator_ in self.locator:
            showIndent(outfile, level)
            outfile.write('model_.locator(\n')
            locator_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('arc=[\n')
        level += 1
        for arc_ in self.arc:
            showIndent(outfile, level)
            outfile.write('model_.arc(\n')
            arc_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('title_attr', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            self.title_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
        elif nodeName_ == 'resource':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <resource> element')
            self.resource.append(obj_)
        elif nodeName_ == 'locator':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <locator> element')
            self.locator.append(obj_)
        elif nodeName_ == 'arc':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <arc> element')
            self.arc.append(obj_)
# end class extended


class titleEltType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if titleEltType.subclass:
            return titleEltType.subclass(*args_, **kwargs_)
        else:
            return titleEltType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='titleEltType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='titleEltType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='titleEltType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='titleEltType', fromsubclass_=False):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='titleEltType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class titleEltType


class resourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, title=None, role=None, label=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.type_ = _cast(None, type_)
        self.title = _cast(None, title)
        self.role = _cast(None, role)
        self.label = _cast(None, label)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resourceType.subclass:
            return resourceType.subclass(*args_, **kwargs_)
        else:
            return resourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='resourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='resourceType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='resourceType', fromsubclass_=False):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class resourceType


class locatorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title_attr=None, label=None, href=None, role=None, type_=None, title=None):
        self.title_attr = _cast(None, title_attr)
        self.label = _cast(None, label)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.type_ = _cast(None, type_)
        if title is None:
            self.title = []
        else:
            self.title = title
    def factory(*args_, **kwargs_):
        if locatorType.subclass:
            return locatorType.subclass(*args_, **kwargs_)
        else:
            return locatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='locatorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='locatorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='locatorType'):
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            outfile.write(' title_attr=%s' % (self.gds_format_string(quote_attrib(self.title_attr).encode(ExternalEncoding), input_name='title_attr'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='locatorType', fromsubclass_=False):
        for title_ in self.get_title():
            title_.export(outfile, level, namespace_, name_='title')
    def hasContent_(self):
        if (
            self.title
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='locatorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            showIndent(outfile, level)
            outfile.write('title_attr = "%s",\n' % (self.title_attr,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title_attr', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            self.title_attr = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
# end class locatorType


class arcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fromxx=None, title_attr=None, arcrole=None, actuate=None, to=None, show=None, type_=None, title=None):
        self.fromxx = _cast(None, fromxx)
        self.title_attr = _cast(None, title_attr)
        self.arcrole = _cast(None, arcrole)
        self.actuate = _cast(None, actuate)
        self.to = _cast(None, to)
        self.show = _cast(None, show)
        self.type_ = _cast(None, type_)
        if title is None:
            self.title = []
        else:
            self.title = title
    def factory(*args_, **kwargs_):
        if arcType.subclass:
            return arcType.subclass(*args_, **kwargs_)
        else:
            return arcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_from(self): return self.fromxx
    def set_from(self, fromxx): self.fromxx = fromxx
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='arcType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arcType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='arcType'):
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            outfile.write(' title_attr=%s' % (self.gds_format_string(quote_attrib(self.title_attr).encode(ExternalEncoding), input_name='title_attr'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='arcType', fromsubclass_=False):
        for title_ in self.get_title():
            title_.export(outfile, level, namespace_, name_='title')
    def hasContent_(self):
        if (
            self.title
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='arcType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            showIndent(outfile, level)
            outfile.write('title_attr = "%s",\n' % (self.title_attr,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('title_attr', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.append('title_attr')
            self.title_attr = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
# end class arcType


class DomainSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractGeometry=None, AbstractTimeObject=None):
        self.owns = _cast(None, owns)
        self.AbstractGeometry = AbstractGeometry
        self.AbstractTimeObject = AbstractTimeObject
    def factory(*args_, **kwargs_):
        if DomainSetType.subclass:
            return DomainSetType.subclass(*args_, **kwargs_)
        else:
            return DomainSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_AbstractTimeObject(self): return self.AbstractTimeObject
    def set_AbstractTimeObject(self, AbstractTimeObject): self.AbstractTimeObject = AbstractTimeObject
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='DomainSetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainSetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DomainSetType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DomainSetType', fromsubclass_=False):
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
        if self.AbstractTimeObject is not None:
            self.AbstractTimeObject.export(outfile, level, namespace_, name_='AbstractTimeObject')
    def hasContent_(self):
        if (
            self.AbstractGeometry is not None or
            self.AbstractTimeObject is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DomainSetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbstractTimeObject is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTimeObject=model_.AbstractTimeObject(\n')
            self.AbstractTimeObject.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
        elif nodeName_ == 'AbstractTimeObject':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimeObject> element')
            self.set_AbstractTimeObject(obj_)
# end class DomainSetType


class RangeSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValueArray=None, AbstractScalarValueList=None, DataBlock=None, File=None):
        if ValueArray is None:
            self.ValueArray = []
        else:
            self.ValueArray = ValueArray
        if AbstractScalarValueList is None:
            self.AbstractScalarValueList = []
        else:
            self.AbstractScalarValueList = AbstractScalarValueList
        self.DataBlock = DataBlock
        self.File = File
    def factory(*args_, **kwargs_):
        if RangeSetType.subclass:
            return RangeSetType.subclass(*args_, **kwargs_)
        else:
            return RangeSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValueArray(self): return self.ValueArray
    def set_ValueArray(self, ValueArray): self.ValueArray = ValueArray
    def add_ValueArray(self, value): self.ValueArray.append(value)
    def insert_ValueArray(self, index, value): self.ValueArray[index] = value
    def get_AbstractScalarValueList(self): return self.AbstractScalarValueList
    def set_AbstractScalarValueList(self, AbstractScalarValueList): self.AbstractScalarValueList = AbstractScalarValueList
    def add_AbstractScalarValueList(self, value): self.AbstractScalarValueList.append(value)
    def insert_AbstractScalarValueList(self, index, value): self.AbstractScalarValueList[index] = value
    def get_DataBlock(self): return self.DataBlock
    def set_DataBlock(self, DataBlock): self.DataBlock = DataBlock
    def get_File(self): return self.File
    def set_File(self, File): self.File = File
    def export(self, outfile, level, namespace_='', name_='RangeSetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RangeSetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RangeSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RangeSetType', fromsubclass_=False):
        for ValueArray_ in self.ValueArray:
            ValueArray_.export(outfile, level, namespace_, name_='ValueArray')
        for AbstractScalarValueList_ in self.get_AbstractScalarValueList():
            AbstractScalarValueList_.export(outfile, level, namespace_, name_='AbstractScalarValueList')
        if self.DataBlock is not None:
            self.DataBlock.export(outfile, level, namespace_, name_='DataBlock', )
        if self.File is not None:
            self.File.export(outfile, level, namespace_, name_='File', )
    def hasContent_(self):
        if (
            self.ValueArray or
            self.AbstractScalarValueList or
            self.DataBlock is not None or
            self.File is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RangeSetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ValueArray=[\n')
        level += 1
        for ValueArray_ in self.ValueArray:
            showIndent(outfile, level)
            outfile.write('model_.ValueArray(\n')
            ValueArray_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AbstractScalarValueList=[\n')
        level += 1
        for AbstractScalarValueList_ in self.AbstractScalarValueList:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AbstractScalarValueList_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DataBlock is not None:
            showIndent(outfile, level)
            outfile.write('DataBlock=model_.DataBlock(\n')
            self.DataBlock.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.File is not None:
            showIndent(outfile, level)
            outfile.write('File=model_.File(\n')
            self.File.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValueArray':
            obj_ = ValueArrayType.factory()
            obj_.build(child_)
            self.ValueArray.append(obj_)
        elif nodeName_ == 'AbstractScalarValueList':
            AbstractScalarValueList_ = child_.text
            AbstractScalarValueList_ = self.gds_validate_string(AbstractScalarValueList_, node, 'AbstractScalarValueList')
            self.AbstractScalarValueList.append(AbstractScalarValueList_)
        elif nodeName_ == 'DataBlock':
            obj_ = DataBlockType.factory()
            obj_.build(child_)
            self.set_DataBlock(obj_)
        elif nodeName_ == 'File':
            obj_ = FileType.factory()
            obj_.build(child_)
            self.set_File(obj_)
# end class RangeSetType


class DataBlockType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rangeParameters=None, tupleList=None, doubleOrNilReasonTupleList=None):
        self.rangeParameters = rangeParameters
        self.tupleList = tupleList
        self.doubleOrNilReasonTupleList = doubleOrNilReasonTupleList
    def factory(*args_, **kwargs_):
        if DataBlockType.subclass:
            return DataBlockType.subclass(*args_, **kwargs_)
        else:
            return DataBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rangeParameters(self): return self.rangeParameters
    def set_rangeParameters(self, rangeParameters): self.rangeParameters = rangeParameters
    def get_tupleList(self): return self.tupleList
    def set_tupleList(self, tupleList): self.tupleList = tupleList
    def get_doubleOrNilReasonTupleList(self): return self.doubleOrNilReasonTupleList
    def set_doubleOrNilReasonTupleList(self, doubleOrNilReasonTupleList): self.doubleOrNilReasonTupleList = doubleOrNilReasonTupleList
    def export(self, outfile, level, namespace_='', name_='DataBlockType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataBlockType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataBlockType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataBlockType', fromsubclass_=False):
        if self.rangeParameters is not None:
            self.rangeParameters.export(outfile, level, namespace_, name_='rangeParameters', )
        if self.tupleList is not None:
            self.tupleList.export(outfile, level, namespace_, name_='tupleList', )
        if self.doubleOrNilReasonTupleList is not None:
            showIndent(outfile, level)
            outfile.write('<%sdoubleOrNilReasonTupleList>%s</%sdoubleOrNilReasonTupleList>\n' % (namespace_, self.gds_format_string(quote_xml(self.doubleOrNilReasonTupleList).encode(ExternalEncoding), input_name='doubleOrNilReasonTupleList'), namespace_))
    def hasContent_(self):
        if (
            self.rangeParameters is not None or
            self.tupleList is not None or
            self.doubleOrNilReasonTupleList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataBlockType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rangeParameters is not None:
            showIndent(outfile, level)
            outfile.write('rangeParameters=model_.rangeParameters(\n')
            self.rangeParameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tupleList is not None:
            showIndent(outfile, level)
            outfile.write('tupleList=model_.tupleList(\n')
            self.tupleList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.doubleOrNilReasonTupleList is not None:
            showIndent(outfile, level)
            outfile.write('doubleOrNilReasonTupleList=%s,\n' % quote_python(self.doubleOrNilReasonTupleList).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rangeParameters':
            obj_ = AssociationRoleType.factory()
            obj_.build(child_)
            self.set_rangeParameters(obj_)
        elif nodeName_ == 'tupleList':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_tupleList(obj_)
        elif nodeName_ == 'doubleOrNilReasonTupleList':
            doubleOrNilReasonTupleList_ = child_.text
            doubleOrNilReasonTupleList_ = self.gds_validate_string(doubleOrNilReasonTupleList_, node, 'doubleOrNilReasonTupleList')
            self.doubleOrNilReasonTupleList = doubleOrNilReasonTupleList_
# end class DataBlockType


class FileType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rangeParameters=None, fileName=None, fileReference=None, fileStructure=None, mimeType=None, compression=None):
        self.rangeParameters = rangeParameters
        self.fileName = fileName
        self.fileReference = fileReference
        self.fileStructure = fileStructure
        self.mimeType = mimeType
        self.compression = compression
    def factory(*args_, **kwargs_):
        if FileType.subclass:
            return FileType.subclass(*args_, **kwargs_)
        else:
            return FileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rangeParameters(self): return self.rangeParameters
    def set_rangeParameters(self, rangeParameters): self.rangeParameters = rangeParameters
    def get_fileName(self): return self.fileName
    def set_fileName(self, fileName): self.fileName = fileName
    def get_fileReference(self): return self.fileReference
    def set_fileReference(self, fileReference): self.fileReference = fileReference
    def get_fileStructure(self): return self.fileStructure
    def set_fileStructure(self, fileStructure): self.fileStructure = fileStructure
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_compression(self): return self.compression
    def set_compression(self, compression): self.compression = compression
    def export(self, outfile, level, namespace_='', name_='FileType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FileType', fromsubclass_=False):
        if self.rangeParameters is not None:
            self.rangeParameters.export(outfile, level, namespace_, name_='rangeParameters', )
        if self.fileName is not None:
            showIndent(outfile, level)
            outfile.write('<%sfileName>%s</%sfileName>\n' % (namespace_, self.gds_format_string(quote_xml(self.fileName).encode(ExternalEncoding), input_name='fileName'), namespace_))
        if self.fileReference is not None:
            showIndent(outfile, level)
            outfile.write('<%sfileReference>%s</%sfileReference>\n' % (namespace_, self.gds_format_string(quote_xml(self.fileReference).encode(ExternalEncoding), input_name='fileReference'), namespace_))
        if self.fileStructure is not None:
            self.fileStructure.export(outfile, level, namespace_, name_='fileStructure', )
        if self.mimeType is not None:
            showIndent(outfile, level)
            outfile.write('<%smimeType>%s</%smimeType>\n' % (namespace_, self.gds_format_string(quote_xml(self.mimeType).encode(ExternalEncoding), input_name='mimeType'), namespace_))
        if self.compression is not None:
            showIndent(outfile, level)
            outfile.write('<%scompression>%s</%scompression>\n' % (namespace_, self.gds_format_string(quote_xml(self.compression).encode(ExternalEncoding), input_name='compression'), namespace_))
    def hasContent_(self):
        if (
            self.rangeParameters is not None or
            self.fileName is not None or
            self.fileReference is not None or
            self.fileStructure is not None or
            self.mimeType is not None or
            self.compression is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FileType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rangeParameters is not None:
            showIndent(outfile, level)
            outfile.write('rangeParameters=model_.rangeParameters(\n')
            self.rangeParameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fileName is not None:
            showIndent(outfile, level)
            outfile.write('fileName=%s,\n' % quote_python(self.fileName).encode(ExternalEncoding))
        if self.fileReference is not None:
            showIndent(outfile, level)
            outfile.write('fileReference=%s,\n' % quote_python(self.fileReference).encode(ExternalEncoding))
        if self.fileStructure is not None:
            showIndent(outfile, level)
            outfile.write('fileStructure=model_.CodeType(\n')
            self.fileStructure.exportLiteral(outfile, level, name_='fileStructure')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mimeType is not None:
            showIndent(outfile, level)
            outfile.write('mimeType=%s,\n' % quote_python(self.mimeType).encode(ExternalEncoding))
        if self.compression is not None:
            showIndent(outfile, level)
            outfile.write('compression=%s,\n' % quote_python(self.compression).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rangeParameters':
            obj_ = AssociationRoleType.factory()
            obj_.build(child_)
            self.set_rangeParameters(obj_)
        elif nodeName_ == 'fileName':
            fileName_ = child_.text
            fileName_ = self.gds_validate_string(fileName_, node, 'fileName')
            self.fileName = fileName_
        elif nodeName_ == 'fileReference':
            fileReference_ = child_.text
            fileReference_ = self.gds_validate_string(fileReference_, node, 'fileReference')
            self.fileReference = fileReference_
        elif nodeName_ == 'fileStructure':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_fileStructure(obj_)
        elif nodeName_ == 'mimeType':
            mimeType_ = child_.text
            mimeType_ = self.gds_validate_string(mimeType_, node, 'mimeType')
            self.mimeType = mimeType_
        elif nodeName_ == 'compression':
            compression_ = child_.text
            compression_ = self.gds_validate_string(compression_, node, 'compression')
            self.compression = compression_
# end class FileType


class CoverageFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MappingRule=None, CoverageMappingRule=None, GridFunction=None):
        self.MappingRule = MappingRule
        self.CoverageMappingRule = CoverageMappingRule
        self.GridFunction = GridFunction
    def factory(*args_, **kwargs_):
        if CoverageFunctionType.subclass:
            return CoverageFunctionType.subclass(*args_, **kwargs_)
        else:
            return CoverageFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MappingRule(self): return self.MappingRule
    def set_MappingRule(self, MappingRule): self.MappingRule = MappingRule
    def get_CoverageMappingRule(self): return self.CoverageMappingRule
    def set_CoverageMappingRule(self, CoverageMappingRule): self.CoverageMappingRule = CoverageMappingRule
    def get_GridFunction(self): return self.GridFunction
    def set_GridFunction(self, GridFunction): self.GridFunction = GridFunction
    def export(self, outfile, level, namespace_='', name_='CoverageFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoverageFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoverageFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoverageFunctionType', fromsubclass_=False):
        if self.MappingRule is not None:
            self.MappingRule.export(outfile, level, namespace_, name_='MappingRule', )
        if self.CoverageMappingRule is not None:
            self.CoverageMappingRule.export(outfile, level, namespace_, name_='CoverageMappingRule', )
        if self.GridFunction is not None:
            self.GridFunction.export(outfile, level, namespace_, name_='GridFunction', )
    def hasContent_(self):
        if (
            self.MappingRule is not None or
            self.CoverageMappingRule is not None or
            self.GridFunction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoverageFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MappingRule is not None:
            showIndent(outfile, level)
            outfile.write('MappingRule=model_.MappingRule(\n')
            self.MappingRule.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CoverageMappingRule is not None:
            showIndent(outfile, level)
            outfile.write('CoverageMappingRule=model_.CoverageMappingRule(\n')
            self.CoverageMappingRule.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GridFunction is not None:
            showIndent(outfile, level)
            outfile.write('GridFunction=model_.GridFunction(\n')
            self.GridFunction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MappingRule':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_MappingRule(obj_)
        elif nodeName_ == 'CoverageMappingRule':
            obj_ = MappingRuleType.factory()
            obj_.build(child_)
            self.set_CoverageMappingRule(obj_)
        elif nodeName_ == 'GridFunction':
            obj_ = GridFunctionType.factory()
            obj_.build(child_)
            self.set_GridFunction(obj_)
# end class CoverageFunctionType


class MappingRuleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ruleDefinition=None, ruleReference=None):
        self.ruleDefinition = ruleDefinition
        self.ruleReference = ruleReference
    def factory(*args_, **kwargs_):
        if MappingRuleType.subclass:
            return MappingRuleType.subclass(*args_, **kwargs_)
        else:
            return MappingRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ruleDefinition(self): return self.ruleDefinition
    def set_ruleDefinition(self, ruleDefinition): self.ruleDefinition = ruleDefinition
    def get_ruleReference(self): return self.ruleReference
    def set_ruleReference(self, ruleReference): self.ruleReference = ruleReference
    def export(self, outfile, level, namespace_='', name_='MappingRuleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MappingRuleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MappingRuleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MappingRuleType', fromsubclass_=False):
        if self.ruleDefinition is not None:
            showIndent(outfile, level)
            outfile.write('<%sruleDefinition>%s</%sruleDefinition>\n' % (namespace_, self.gds_format_string(quote_xml(self.ruleDefinition).encode(ExternalEncoding), input_name='ruleDefinition'), namespace_))
        if self.ruleReference is not None:
            self.ruleReference.export(outfile, level, namespace_, name_='ruleReference', )
    def hasContent_(self):
        if (
            self.ruleDefinition is not None or
            self.ruleReference is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MappingRuleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ruleDefinition is not None:
            showIndent(outfile, level)
            outfile.write('ruleDefinition=%s,\n' % quote_python(self.ruleDefinition).encode(ExternalEncoding))
        if self.ruleReference is not None:
            showIndent(outfile, level)
            outfile.write('ruleReference=model_.ReferenceType(\n')
            self.ruleReference.exportLiteral(outfile, level, name_='ruleReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ruleDefinition':
            ruleDefinition_ = child_.text
            ruleDefinition_ = self.gds_validate_string(ruleDefinition_, node, 'ruleDefinition')
            self.ruleDefinition = ruleDefinition_
        elif nodeName_ == 'ruleReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_ruleReference(obj_)
# end class MappingRuleType


class GridFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceRule=None, startPoint=None):
        self.sequenceRule = sequenceRule
        self.startPoint = startPoint
    def factory(*args_, **kwargs_):
        if GridFunctionType.subclass:
            return GridFunctionType.subclass(*args_, **kwargs_)
        else:
            return GridFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceRule(self): return self.sequenceRule
    def set_sequenceRule(self, sequenceRule): self.sequenceRule = sequenceRule
    def get_startPoint(self): return self.startPoint
    def set_startPoint(self, startPoint): self.startPoint = startPoint
    def validate_integerList(self, value):
        # Validate type integerList, a restriction on integer.
        pass
    def export(self, outfile, level, namespace_='', name_='GridFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GridFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GridFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GridFunctionType', fromsubclass_=False):
        if self.sequenceRule is not None:
            self.sequenceRule.export(outfile, level, namespace_, name_='sequenceRule')
        if self.startPoint is not None:
            self.startPoint.export(outfile, level, namespace_, name_='startPoint')
    def hasContent_(self):
        if (
            self.sequenceRule is not None or
            self.startPoint is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GridFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sequenceRule is not None:
            showIndent(outfile, level)
            outfile.write('sequenceRule=model_.SequenceRuleType(\n')
            self.sequenceRule.exportLiteral(outfile, level, name_='sequenceRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.startPoint is not None:
            showIndent(outfile, level)
            outfile.write('startPoint=model_.integer(\n')
            self.startPoint.exportLiteral(outfile, level, name_='startPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequenceRule':
            obj_ = SequenceRuleType.factory()
            obj_.build(child_)
            self.set_sequenceRule(obj_)
        elif nodeName_ == 'startPoint':
            startPoint_ = child_.text
            self.startPoint = startPoint_
            self.startPoint = self.startPoint.split()
            self.validate_integerList(self.startPoint)    # validate type integerList
# end class GridFunctionType


class SequenceRuleType(GeneratedsSuper):
    """The gml:SequenceRuleType is derived from the
    gml:SequenceRuleEnumeration through the addition of an axisOrder
    attribute. The gml:SequenceRuleEnumeration is an enumerated
    type. The rule names are defined in ISO 19123. If no rule name
    is specified the default is "Linear"."""
    subclass = None
    superclass = None
    def __init__(self, axisOrder=None, order=None, valueOf_=None):
        self.axisOrder = _cast(None, axisOrder)
        self.order = _cast(None, order)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SequenceRuleType.subclass:
            return SequenceRuleType.subclass(*args_, **kwargs_)
        else:
            return SequenceRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_axisOrder(self): return self.axisOrder
    def set_axisOrder(self, axisOrder): self.axisOrder = axisOrder
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='SequenceRuleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceRuleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceRuleType'):
        if self.axisOrder is not None and 'axisOrder' not in already_processed:
            already_processed.append('axisOrder')
            outfile.write(' axisOrder=%s' % (quote_attrib(self.axisOrder), ))
        if self.order is not None and 'order' not in already_processed:
            already_processed.append('order')
            outfile.write(' order=%s' % (quote_attrib(self.order), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceRuleType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SequenceRuleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.axisOrder is not None and 'axisOrder' not in already_processed:
            already_processed.append('axisOrder')
            showIndent(outfile, level)
            outfile.write('axisOrder = %s,\n' % (self.axisOrder,))
        if self.order is not None and 'order' not in already_processed:
            already_processed.append('order')
            showIndent(outfile, level)
            outfile.write('order = %s,\n' % (self.order,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('axisOrder', node)
        if value is not None and 'axisOrder' not in already_processed:
            already_processed.append('axisOrder')
            self.axisOrder = value
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.append('order')
            self.order = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SequenceRuleType


class AbstractFeatureType(AbstractGMLType):
    """The basic feature model is given by the gml:AbstractFeatureType. The
    content model for gml:AbstractFeatureType adds two specific
    properties suitable for geographic features to the content model
    defined in gml:AbstractGMLType. The value of the gml:boundedBy
    property describes an envelope that encloses the entire feature
    instance, and is primarily useful for supporting rapid searching
    for features that occur in a particular location. The value of
    the gml:location property describes the extent, position or
    relative location of the feature."""
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, extensiontype_=None):
        super(AbstractFeatureType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.boundedBy = boundedBy
        self.location = location
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractFeatureType.subclass:
            return AbstractFeatureType.subclass(*args_, **kwargs_)
        else:
            return AbstractFeatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boundedBy(self): return self.boundedBy
    def set_boundedBy(self, boundedBy): self.boundedBy = boundedBy
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractFeatureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFeatureType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractFeatureType'):
        super(AbstractFeatureType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFeatureType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractFeatureType', fromsubclass_=False):
        super(AbstractFeatureType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.boundedBy is not None:
            self.boundedBy.export(outfile, level, namespace_, name_='boundedBy')
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location')
    def hasContent_(self):
        if (
            self.boundedBy is not None or
            self.location is not None or
            super(AbstractFeatureType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractFeatureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractFeatureType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractFeatureType, self).exportLiteralChildren(outfile, level, name_)
        if self.boundedBy is not None:
            showIndent(outfile, level)
            outfile.write('boundedBy=model_.boundedBy(\n')
            self.boundedBy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.location(\n')
            self.location.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractFeatureType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boundedBy':
            obj_ = BoundingShapeType.factory()
            obj_.build(child_)
            self.set_boundedBy(obj_)
        elif nodeName_ == 'location':
            class_obj_ = self.get_class_obj_(child_, LocationPropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_location(obj_)
        super(AbstractFeatureType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractFeatureType


class FeaturePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractFeature=None):
        self.owns = _cast(None, owns)
        self.AbstractFeature = AbstractFeature
    def factory(*args_, **kwargs_):
        if FeaturePropertyType.subclass:
            return FeaturePropertyType.subclass(*args_, **kwargs_)
        else:
            return FeaturePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractFeature(self): return self.AbstractFeature
    def set_AbstractFeature(self, AbstractFeature): self.AbstractFeature = AbstractFeature
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='FeaturePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeaturePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeaturePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FeaturePropertyType', fromsubclass_=False):
        if self.AbstractFeature is not None:
            self.AbstractFeature.export(outfile, level, namespace_, name_='AbstractFeature')
    def hasContent_(self):
        if (
            self.AbstractFeature is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FeaturePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractFeature is not None:
            showIndent(outfile, level)
            outfile.write('AbstractFeature=model_.AbstractFeature(\n')
            self.AbstractFeature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractFeature':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractFeature> element')
            self.set_AbstractFeature(obj_)
# end class FeaturePropertyType


class BoundingShapeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Envelope=None, Null=None):
        self.nilReason = _cast(None, nilReason)
        self.Envelope = Envelope
        self.Null = Null
    def factory(*args_, **kwargs_):
        if BoundingShapeType.subclass:
            return BoundingShapeType.subclass(*args_, **kwargs_)
        else:
            return BoundingShapeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Envelope(self): return self.Envelope
    def set_Envelope(self, Envelope): self.Envelope = Envelope
    def get_Null(self): return self.Null
    def set_Null(self, Null): self.Null = Null
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='BoundingShapeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoundingShapeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundingShapeType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BoundingShapeType', fromsubclass_=False):
        if self.Envelope is not None:
            self.Envelope.export(outfile, level, namespace_, name_='Envelope', )
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('<%sNull>%s</%sNull>\n' % (namespace_, self.gds_format_string(quote_xml(self.Null).encode(ExternalEncoding), input_name='Null'), namespace_))
    def hasContent_(self):
        if (
            self.Envelope is not None or
            self.Null is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BoundingShapeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = %s,\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Envelope is not None:
            showIndent(outfile, level)
            outfile.write('Envelope=model_.Envelope(\n')
            self.Envelope.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('Null=%s,\n' % quote_python(self.Null).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Envelope':
            class_obj_ = self.get_class_obj_(child_, EnvelopeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Envelope(obj_)
        elif nodeName_ == 'Null':
            Null_ = child_.text
            Null_ = self.gds_validate_string(Null_, node, 'Null')
            self.Null = Null_
# end class BoundingShapeType


class EnvelopeWithTimePeriodType(EnvelopeType):
    subclass = None
    superclass = EnvelopeType
    def __init__(self, srsName=None, srsDimension=None, lowerCorner=None, upperCorner=None, pos=None, coordinates=None, frame='#ISO-8601', beginPosition=None, endPosition=None):
        super(EnvelopeWithTimePeriodType, self).__init__(srsName, srsDimension, lowerCorner, upperCorner, pos, coordinates, )
        self.frame = _cast(None, frame)
        self.beginPosition = beginPosition
        self.endPosition = endPosition
    def factory(*args_, **kwargs_):
        if EnvelopeWithTimePeriodType.subclass:
            return EnvelopeWithTimePeriodType.subclass(*args_, **kwargs_)
        else:
            return EnvelopeWithTimePeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_beginPosition(self): return self.beginPosition
    def set_beginPosition(self, beginPosition): self.beginPosition = beginPosition
    def get_endPosition(self): return self.endPosition
    def set_endPosition(self, endPosition): self.endPosition = endPosition
    def get_frame(self): return self.frame
    def set_frame(self, frame): self.frame = frame
    def export(self, outfile, level, namespace_='', name_='EnvelopeWithTimePeriodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvelopeWithTimePeriodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvelopeWithTimePeriodType'):
        super(EnvelopeWithTimePeriodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EnvelopeWithTimePeriodType')
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            outfile.write(' frame=%s' % (quote_attrib(self.frame), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EnvelopeWithTimePeriodType', fromsubclass_=False):
        super(EnvelopeWithTimePeriodType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.beginPosition is not None:
            self.beginPosition.export(outfile, level, namespace_, name_='beginPosition', )
        if self.endPosition is not None:
            self.endPosition.export(outfile, level, namespace_, name_='endPosition', )
    def hasContent_(self):
        if (
            self.beginPosition is not None or
            self.endPosition is not None or
            super(EnvelopeWithTimePeriodType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EnvelopeWithTimePeriodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            showIndent(outfile, level)
            outfile.write('frame = %s,\n' % (self.frame,))
        super(EnvelopeWithTimePeriodType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EnvelopeWithTimePeriodType, self).exportLiteralChildren(outfile, level, name_)
        if self.beginPosition is not None:
            showIndent(outfile, level)
            outfile.write('beginPosition=model_.TimePositionType(\n')
            self.beginPosition.exportLiteral(outfile, level, name_='beginPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.endPosition is not None:
            showIndent(outfile, level)
            outfile.write('endPosition=model_.TimePositionType(\n')
            self.endPosition.exportLiteral(outfile, level, name_='endPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frame', node)
        if value is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            self.frame = value
        super(EnvelopeWithTimePeriodType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'beginPosition':
            obj_ = TimePositionType.factory()
            obj_.build(child_)
            self.set_beginPosition(obj_)
        elif nodeName_ == 'endPosition':
            obj_ = TimePositionType.factory()
            obj_.build(child_)
            self.set_endPosition(obj_)
        super(EnvelopeWithTimePeriodType, self).buildChildren(child_, node, nodeName_, True)
# end class EnvelopeWithTimePeriodType


class AbstractFeatureMemberType(GeneratedsSuper):
    """To create a collection of GML features, a property type shall be
    derived by extension from gml:AbstractFeatureMemberType. By
    default, this abstract property type does not imply any
    ownership of the features in the collection. The owns attribute
    of gml:OwnershipAttributeGroup may be used on a property element
    instance to assert ownership of a feature in the collection. A
    collection shall not own a feature already owned by another
    object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', extensiontype_=None):
        self.owns = _cast(None, owns)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractFeatureMemberType.subclass:
            return AbstractFeatureMemberType.subclass(*args_, **kwargs_)
        else:
            return AbstractFeatureMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractFeatureMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFeatureMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractFeatureMemberType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractFeatureMemberType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractFeatureMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractFeatureMemberType


class AbstractTimeObjectType(AbstractGMLType):
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        super(AbstractTimeObjectType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTimeObjectType.subclass:
            return AbstractTimeObjectType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimeObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTimeObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeObjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTimeObjectType'):
        super(AbstractTimeObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeObjectType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTimeObjectType', fromsubclass_=False):
        super(AbstractTimeObjectType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractTimeObjectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTimeObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractTimeObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTimeObjectType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTimeObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractTimeObjectType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractTimeObjectType


class AbstractTimePrimitiveType(AbstractTimeObjectType):
    subclass = None
    superclass = AbstractTimeObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None, extensiontype_=None):
        super(AbstractTimePrimitiveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        if relatedTime is None:
            self.relatedTime = []
        else:
            self.relatedTime = relatedTime
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTimePrimitiveType.subclass:
            return AbstractTimePrimitiveType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimePrimitiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedTime(self): return self.relatedTime
    def set_relatedTime(self, relatedTime): self.relatedTime = relatedTime
    def add_relatedTime(self, value): self.relatedTime.append(value)
    def insert_relatedTime(self, index, value): self.relatedTime[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTimePrimitiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimePrimitiveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTimePrimitiveType'):
        super(AbstractTimePrimitiveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimePrimitiveType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTimePrimitiveType', fromsubclass_=False):
        super(AbstractTimePrimitiveType, self).exportChildren(outfile, level, namespace_, name_, True)
        for relatedTime_ in self.relatedTime:
            relatedTime_.export(outfile, level, namespace_, name_='relatedTime')
    def hasContent_(self):
        if (
            self.relatedTime or
            super(AbstractTimePrimitiveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTimePrimitiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractTimePrimitiveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTimePrimitiveType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('relatedTime=[\n')
        level += 1
        for relatedTime_ in self.relatedTime:
            showIndent(outfile, level)
            outfile.write('model_.RelatedTimeType(\n')
            relatedTime_.exportLiteral(outfile, level, name_='RelatedTimeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTimePrimitiveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedTime':
            obj_ = RelatedTimeType.factory()
            obj_.build(child_)
            self.relatedTime.append(obj_)
        super(AbstractTimePrimitiveType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractTimePrimitiveType


class TimePrimitivePropertyType(GeneratedsSuper):
    """gml:TimePrimitivePropertyType provides a standard content model for
    associations between an arbitrary member of the substitution
    group whose head is gml:AbstractTimePrimitive and another
    object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractTimePrimitive=None, extensiontype_=None):
        self.owns = _cast(None, owns)
        self.AbstractTimePrimitive = AbstractTimePrimitive
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if TimePrimitivePropertyType.subclass:
            return TimePrimitivePropertyType.subclass(*args_, **kwargs_)
        else:
            return TimePrimitivePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTimePrimitive(self): return self.AbstractTimePrimitive
    def set_AbstractTimePrimitive(self, AbstractTimePrimitive): self.AbstractTimePrimitive = AbstractTimePrimitive
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='TimePrimitivePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePrimitivePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimePrimitivePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='TimePrimitivePropertyType', fromsubclass_=False):
        if self.AbstractTimePrimitive is not None:
            self.AbstractTimePrimitive.export(outfile, level, namespace_, name_='AbstractTimePrimitive')
    def hasContent_(self):
        if (
            self.AbstractTimePrimitive is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimePrimitivePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractTimePrimitive is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTimePrimitive=model_.AbstractTimePrimitive(\n')
            self.AbstractTimePrimitive.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTimePrimitive':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimePrimitive> element')
            self.set_AbstractTimePrimitive(obj_)
# end class TimePrimitivePropertyType


class RelatedTimeType(TimePrimitivePropertyType):
    """gml:RelatedTimeType provides a content model for indicating the
    relative position of an arbitrary member of the substitution
    group whose head is gml:AbstractTimePrimitive. It extends the
    generic gml:TimePrimitivePropertyType with an XML attribute
    relativePosition, whose value is selected from the set of 13
    temporal relationships identified by Allen (1983)"""
    subclass = None
    superclass = TimePrimitivePropertyType
    def __init__(self, owns='false', AbstractTimePrimitive=None, relativePosition=None):
        super(RelatedTimeType, self).__init__(owns, AbstractTimePrimitive, )
        self.relativePosition = _cast(None, relativePosition)
        pass
    def factory(*args_, **kwargs_):
        if RelatedTimeType.subclass:
            return RelatedTimeType.subclass(*args_, **kwargs_)
        else:
            return RelatedTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relativePosition(self): return self.relativePosition
    def set_relativePosition(self, relativePosition): self.relativePosition = relativePosition
    def export(self, outfile, level, namespace_='', name_='RelatedTimeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedTimeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedTimeType'):
        super(RelatedTimeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedTimeType')
        if self.relativePosition is not None and 'relativePosition' not in already_processed:
            already_processed.append('relativePosition')
            outfile.write(' relativePosition=%s' % (quote_attrib(self.relativePosition), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedTimeType', fromsubclass_=False):
        super(RelatedTimeType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(RelatedTimeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RelatedTimeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.relativePosition is not None and 'relativePosition' not in already_processed:
            already_processed.append('relativePosition')
            showIndent(outfile, level)
            outfile.write('relativePosition = %s,\n' % (self.relativePosition,))
        super(RelatedTimeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RelatedTimeType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('relativePosition', node)
        if value is not None and 'relativePosition' not in already_processed:
            already_processed.append('relativePosition')
            self.relativePosition = value
        super(RelatedTimeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RelatedTimeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RelatedTimeType


class AbstractTimeComplexType(AbstractTimeObjectType):
    subclass = None
    superclass = AbstractTimeObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        super(AbstractTimeComplexType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTimeComplexType.subclass:
            return AbstractTimeComplexType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimeComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTimeComplexType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeComplexType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTimeComplexType'):
        super(AbstractTimeComplexType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeComplexType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTimeComplexType', fromsubclass_=False):
        super(AbstractTimeComplexType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractTimeComplexType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTimeComplexType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractTimeComplexType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTimeComplexType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTimeComplexType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractTimeComplexType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractTimeComplexType


class AbstractTimeGeometricPrimitiveType(AbstractTimePrimitiveType):
    subclass = None
    superclass = AbstractTimePrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None, frame='#ISO-8601', extensiontype_=None):
        super(AbstractTimeGeometricPrimitiveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, relatedTime, extensiontype_, )
        self.frame = _cast(None, frame)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTimeGeometricPrimitiveType.subclass:
            return AbstractTimeGeometricPrimitiveType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimeGeometricPrimitiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frame(self): return self.frame
    def set_frame(self, frame): self.frame = frame
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTimeGeometricPrimitiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeGeometricPrimitiveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTimeGeometricPrimitiveType'):
        super(AbstractTimeGeometricPrimitiveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeGeometricPrimitiveType')
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            outfile.write(' frame=%s' % (quote_attrib(self.frame), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTimeGeometricPrimitiveType', fromsubclass_=False):
        super(AbstractTimeGeometricPrimitiveType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractTimeGeometricPrimitiveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTimeGeometricPrimitiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            showIndent(outfile, level)
            outfile.write('frame = %s,\n' % (self.frame,))
        super(AbstractTimeGeometricPrimitiveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTimeGeometricPrimitiveType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frame', node)
        if value is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            self.frame = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTimeGeometricPrimitiveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractTimeGeometricPrimitiveType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractTimeGeometricPrimitiveType


class TimeInstantType(AbstractTimeGeometricPrimitiveType):
    subclass = None
    superclass = AbstractTimeGeometricPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None, frame='#ISO-8601', timePosition=None):
        super(TimeInstantType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, relatedTime, frame, )
        self.timePosition = timePosition
    def factory(*args_, **kwargs_):
        if TimeInstantType.subclass:
            return TimeInstantType.subclass(*args_, **kwargs_)
        else:
            return TimeInstantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timePosition(self): return self.timePosition
    def set_timePosition(self, timePosition): self.timePosition = timePosition
    def export(self, outfile, level, namespace_='', name_='TimeInstantType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeInstantType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeInstantType'):
        super(TimeInstantType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeInstantType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeInstantType', fromsubclass_=False):
        super(TimeInstantType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.timePosition is not None:
            self.timePosition.export(outfile, level, namespace_, name_='timePosition', )
    def hasContent_(self):
        if (
            self.timePosition is not None or
            super(TimeInstantType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeInstantType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeInstantType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeInstantType, self).exportLiteralChildren(outfile, level, name_)
        if self.timePosition is not None:
            showIndent(outfile, level)
            outfile.write('timePosition=model_.timePosition(\n')
            self.timePosition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeInstantType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timePosition':
            obj_ = TimePositionType.factory()
            obj_.build(child_)
            self.set_timePosition(obj_)
        super(TimeInstantType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeInstantType


class TimeInstantPropertyType(GeneratedsSuper):
    """gml:TimeInstantPropertyType provides for associating a
    gml:TimeInstant with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeInstant=None):
        self.owns = _cast(None, owns)
        self.TimeInstant = TimeInstant
    def factory(*args_, **kwargs_):
        if TimeInstantPropertyType.subclass:
            return TimeInstantPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeInstantPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeInstant(self): return self.TimeInstant
    def set_TimeInstant(self, TimeInstant): self.TimeInstant = TimeInstant
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeInstantPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeInstantPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeInstantPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeInstantPropertyType', fromsubclass_=False):
        if self.TimeInstant is not None:
            self.TimeInstant.export(outfile, level, namespace_, name_='TimeInstant', )
    def hasContent_(self):
        if (
            self.TimeInstant is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeInstantPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeInstant is not None:
            showIndent(outfile, level)
            outfile.write('TimeInstant=model_.TimeInstant(\n')
            self.TimeInstant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeInstant':
            obj_ = TimeInstantType.factory()
            obj_.build(child_)
            self.set_TimeInstant(obj_)
# end class TimeInstantPropertyType


class TimePeriodType(AbstractTimeGeometricPrimitiveType):
    subclass = None
    superclass = AbstractTimeGeometricPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None, frame='#ISO-8601', beginPosition=None, begin=None, endPosition=None, end=None, duration=None, timeInterval=None):
        super(TimePeriodType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, relatedTime, frame, )
        self.beginPosition = beginPosition
        self.begin = begin
        self.endPosition = endPosition
        self.end = end
        self.duration = duration
        self.timeInterval = timeInterval
    def factory(*args_, **kwargs_):
        if TimePeriodType.subclass:
            return TimePeriodType.subclass(*args_, **kwargs_)
        else:
            return TimePeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_beginPosition(self): return self.beginPosition
    def set_beginPosition(self, beginPosition): self.beginPosition = beginPosition
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_endPosition(self): return self.endPosition
    def set_endPosition(self, endPosition): self.endPosition = endPosition
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_timeInterval(self): return self.timeInterval
    def set_timeInterval(self, timeInterval): self.timeInterval = timeInterval
    def export(self, outfile, level, namespace_='', name_='TimePeriodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePeriodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimePeriodType'):
        super(TimePeriodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimePeriodType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimePeriodType', fromsubclass_=False):
        super(TimePeriodType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.beginPosition is not None:
            self.beginPosition.export(outfile, level, namespace_, name_='beginPosition', )
        if self.begin is not None:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.endPosition is not None:
            self.endPosition.export(outfile, level, namespace_, name_='endPosition', )
        if self.end is not None:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.duration is not None:
            self.duration.export(outfile, level, namespace_, name_='duration')
        if self.timeInterval is not None:
            self.timeInterval.export(outfile, level, namespace_, name_='timeInterval')
    def hasContent_(self):
        if (
            self.beginPosition is not None or
            self.begin is not None or
            self.endPosition is not None or
            self.end is not None or
            self.duration is not None or
            self.timeInterval is not None or
            super(TimePeriodType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimePeriodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimePeriodType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimePeriodType, self).exportLiteralChildren(outfile, level, name_)
        if self.beginPosition is not None:
            showIndent(outfile, level)
            outfile.write('beginPosition=model_.TimePositionType(\n')
            self.beginPosition.exportLiteral(outfile, level, name_='beginPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.TimeInstantPropertyType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.endPosition is not None:
            showIndent(outfile, level)
            outfile.write('endPosition=model_.TimePositionType(\n')
            self.endPosition.exportLiteral(outfile, level, name_='endPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.TimeInstantPropertyType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=model_.duration(\n')
            self.duration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeInterval is not None:
            showIndent(outfile, level)
            outfile.write('timeInterval=model_.timeInterval(\n')
            self.timeInterval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimePeriodType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'beginPosition':
            obj_ = TimePositionType.factory()
            obj_.build(child_)
            self.set_beginPosition(obj_)
        elif nodeName_ == 'begin':
            obj_ = TimeInstantPropertyType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'endPosition':
            obj_ = TimePositionType.factory()
            obj_.build(child_)
            self.set_endPosition(obj_)
        elif nodeName_ == 'end':
            obj_ = TimeInstantPropertyType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'duration':
            obj_ = duration.factory()
            obj_.build(child_)
            self.set_duration(obj_)
        elif nodeName_ == 'timeInterval':
            obj_ = TimeIntervalLengthType.factory()
            obj_.build(child_)
            self.set_timeInterval(obj_)
        super(TimePeriodType, self).buildChildren(child_, node, nodeName_, True)
# end class TimePeriodType


class TimePeriodPropertyType(GeneratedsSuper):
    """gml:TimePeriodPropertyType provides for associating a gml:TimePeriod
    with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimePeriod=None):
        self.owns = _cast(None, owns)
        self.TimePeriod = TimePeriod
    def factory(*args_, **kwargs_):
        if TimePeriodPropertyType.subclass:
            return TimePeriodPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimePeriodPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimePeriod(self): return self.TimePeriod
    def set_TimePeriod(self, TimePeriod): self.TimePeriod = TimePeriod
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimePeriodPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePeriodPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimePeriodPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimePeriodPropertyType', fromsubclass_=False):
        if self.TimePeriod is not None:
            self.TimePeriod.export(outfile, level, namespace_, name_='TimePeriod', )
    def hasContent_(self):
        if (
            self.TimePeriod is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimePeriodPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimePeriod is not None:
            showIndent(outfile, level)
            outfile.write('TimePeriod=model_.TimePeriod(\n')
            self.TimePeriod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimePeriod':
            obj_ = TimePeriodType.factory()
            obj_.build(child_)
            self.set_TimePeriod(obj_)
# end class TimePeriodPropertyType


class TimePositionType(GeneratedsSuper):
    """The method for identifying a temporal position is specific to each
    temporal reference system. gml:TimePositionType supports the
    description of temporal position according to the subtypes
    described in ISO 19108. Values based on calendars and clocks use
    lexical formats that are based on ISO 8601, as described in XML
    Schema Part 2:2001. A decimal value may be used with coordinate
    systems such as GPS time or UNIX time. A URI may be used to
    provide a reference to some era in an ordinal reference system .
    In common with many of the components modelled as data types in
    the ISO 19100 series of International Standards, the
    corresponding GML component has simple content. However, the
    content model gml:TimePositionType is defined in several steps.
    Three XML attributes appear on gml:TimePositionType: A time
    value shall be associated with a temporal reference system
    through the frame attribute that provides a URI reference that
    identifies a description of the reference system. Following ISO
    19108, the Gregorian calendar with UTC is the default reference
    system, but others may also be used. Components for describing
    temporal reference systems are described in 14.4, but it is not
    required that the reference system be described in this, as the
    reference may refer to anything that may be indentified with a
    URI. For time values using a calendar containing more than one
    era, the (optional) calendarEraName attribute provides the name
    of the calendar era. Inexact temporal positions may be expressed
    using the optional indeterminatePosition attribute. This takes a
    value from an enumeration."""
    subclass = None
    superclass = None
    def __init__(self, frame='#ISO-8601', indeterminatePosition=None, calendarEraName=None, valueOf_=None):
        self.frame = _cast(None, frame)
        self.indeterminatePosition = _cast(None, indeterminatePosition)
        self.calendarEraName = _cast(None, calendarEraName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimePositionType.subclass:
            return TimePositionType.subclass(*args_, **kwargs_)
        else:
            return TimePositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frame(self): return self.frame
    def set_frame(self, frame): self.frame = frame
    def get_indeterminatePosition(self): return self.indeterminatePosition
    def set_indeterminatePosition(self, indeterminatePosition): self.indeterminatePosition = indeterminatePosition
    def get_calendarEraName(self): return self.calendarEraName
    def set_calendarEraName(self, calendarEraName): self.calendarEraName = calendarEraName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='TimePositionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimePositionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimePositionType'):
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            outfile.write(' frame=%s' % (quote_attrib(self.frame), ))
        if self.indeterminatePosition is not None and 'indeterminatePosition' not in already_processed:
            already_processed.append('indeterminatePosition')
            outfile.write(' indeterminatePosition=%s' % (quote_attrib(self.indeterminatePosition), ))
        if self.calendarEraName is not None and 'calendarEraName' not in already_processed:
            already_processed.append('calendarEraName')
            outfile.write(' calendarEraName=%s' % (quote_attrib(self.calendarEraName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimePositionType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimePositionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            showIndent(outfile, level)
            outfile.write('frame = %s,\n' % (self.frame,))
        if self.indeterminatePosition is not None and 'indeterminatePosition' not in already_processed:
            already_processed.append('indeterminatePosition')
            showIndent(outfile, level)
            outfile.write('indeterminatePosition = %s,\n' % (self.indeterminatePosition,))
        if self.calendarEraName is not None and 'calendarEraName' not in already_processed:
            already_processed.append('calendarEraName')
            showIndent(outfile, level)
            outfile.write('calendarEraName = %s,\n' % (self.calendarEraName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frame', node)
        if value is not None and 'frame' not in already_processed:
            already_processed.append('frame')
            self.frame = value
        value = find_attr_value_('indeterminatePosition', node)
        if value is not None and 'indeterminatePosition' not in already_processed:
            already_processed.append('indeterminatePosition')
            self.indeterminatePosition = value
        value = find_attr_value_('calendarEraName', node)
        if value is not None and 'calendarEraName' not in already_processed:
            already_processed.append('calendarEraName')
            self.calendarEraName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimePositionType


class TimeIntervalLengthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, radix=None, unit=None, factor=None, valueOf_=None):
        self.radix = _cast(None, radix)
        self.unit = _cast(None, unit)
        self.factor = _cast(None, factor)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimeIntervalLengthType.subclass:
            return TimeIntervalLengthType.subclass(*args_, **kwargs_)
        else:
            return TimeIntervalLengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_radix(self): return self.radix
    def set_radix(self, radix): self.radix = radix
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_factor(self): return self.factor
    def set_factor(self, factor): self.factor = factor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='TimeIntervalLengthType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeIntervalLengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeIntervalLengthType'):
        if self.radix is not None and 'radix' not in already_processed:
            already_processed.append('radix')
            outfile.write(' radix=%s' % (quote_attrib(self.radix), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.factor is not None and 'factor' not in already_processed:
            already_processed.append('factor')
            outfile.write(' factor=%s' % (quote_attrib(self.factor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeIntervalLengthType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeIntervalLengthType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.radix is not None and 'radix' not in already_processed:
            already_processed.append('radix')
            showIndent(outfile, level)
            outfile.write('radix = %s,\n' % (self.radix,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = %s,\n' % (self.unit,))
        if self.factor is not None and 'factor' not in already_processed:
            already_processed.append('factor')
            showIndent(outfile, level)
            outfile.write('factor = %s,\n' % (self.factor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('radix', node)
        if value is not None and 'radix' not in already_processed:
            already_processed.append('radix')
            self.radix = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
        value = find_attr_value_('factor', node)
        if value is not None and 'factor' not in already_processed:
            already_processed.append('factor')
            self.factor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeIntervalLengthType


class Boolean(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, valueOf_=None):
        self.nilReason = _cast(None, nilReason)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Boolean.subclass:
            return Boolean.subclass(*args_, **kwargs_)
        else:
            return Boolean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Boolean', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Boolean')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Boolean'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Boolean', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Boolean'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = %s,\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Boolean


class Category(CodeType):
    """A gml:Category has an optional XML attribute codeSpace, whose value
    is a URI which identifies a dictionary, codelist or authority
    for the term."""
    subclass = None
    superclass = CodeType
    def __init__(self, codeSpace=None, nilReason=None, valueOf_=None):
        super(Category, self).__init__(codeSpace, valueOf_, )
        self.nilReason = _cast(None, nilReason)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Category.subclass:
            return Category.subclass(*args_, **kwargs_)
        else:
            return Category(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Category', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Category')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Category'):
        super(Category, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Category')
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Category', fromsubclass_=False):
        super(Category, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Category, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Category'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = %s,\n' % (self.nilReason,))
        super(Category, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Category, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
        super(Category, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Category


class Count(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, valueOf_=None):
        self.nilReason = _cast(None, nilReason)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Count.subclass:
            return Count.subclass(*args_, **kwargs_)
        else:
            return Count(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Count', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Count')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Count'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Count', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Count'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = %s,\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Count


class Quantity(MeasureType):
    """An XML attribute uom ("unit of measure") is required, whose value is
    a URI which identifies the definition of a ratio scale or units
    by which the numeric value shall be multiplied, or an interval
    or position scale on which the value occurs."""
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, nilReason=None, valueOf_=None):
        super(Quantity, self).__init__(uom, valueOf_, )
        self.nilReason = _cast(None, nilReason)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Quantity.subclass:
            return Quantity.subclass(*args_, **kwargs_)
        else:
            return Quantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Quantity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Quantity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Quantity'):
        super(Quantity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Quantity')
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (quote_attrib(self.nilReason), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Quantity', fromsubclass_=False):
        super(Quantity, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Quantity, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Quantity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = %s,\n' % (self.nilReason,))
        super(Quantity, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Quantity, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
        super(Quantity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Quantity


class ValuePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractValue=None, AbstractGeometry=None, AbstractTimeObject=None, Null=None):
        self.owns = _cast(None, owns)
        self.AbstractValue = AbstractValue
        self.AbstractGeometry = AbstractGeometry
        self.AbstractTimeObject = AbstractTimeObject
        self.Null = Null
    def factory(*args_, **kwargs_):
        if ValuePropertyType.subclass:
            return ValuePropertyType.subclass(*args_, **kwargs_)
        else:
            return ValuePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractValue(self): return self.AbstractValue
    def set_AbstractValue(self, AbstractValue): self.AbstractValue = AbstractValue
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_AbstractTimeObject(self): return self.AbstractTimeObject
    def set_AbstractTimeObject(self, AbstractTimeObject): self.AbstractTimeObject = AbstractTimeObject
    def get_Null(self): return self.Null
    def set_Null(self, Null): self.Null = Null
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='ValuePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePropertyType', fromsubclass_=False):
        if self.AbstractValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbstractValue>%s</%sAbstractValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbstractValue).encode(ExternalEncoding), input_name='AbstractValue'), namespace_))
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
        if self.AbstractTimeObject is not None:
            self.AbstractTimeObject.export(outfile, level, namespace_, name_='AbstractTimeObject')
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('<%sNull>%s</%sNull>\n' % (namespace_, self.gds_format_string(quote_xml(self.Null).encode(ExternalEncoding), input_name='Null'), namespace_))
    def hasContent_(self):
        if (
            self.AbstractValue is not None or
            self.AbstractGeometry is not None or
            self.AbstractTimeObject is not None or
            self.Null is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractValue is not None:
            showIndent(outfile, level)
            outfile.write('AbstractValue=%s,\n' % quote_python(self.AbstractValue).encode(ExternalEncoding))
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbstractTimeObject is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTimeObject=model_.AbstractTimeObject(\n')
            self.AbstractTimeObject.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('Null=%s,\n' % quote_python(self.Null).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractValue':
            AbstractValue_ = child_.text
            AbstractValue_ = self.gds_validate_string(AbstractValue_, node, 'AbstractValue')
            self.AbstractValue = AbstractValue_
        elif nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
        elif nodeName_ == 'AbstractTimeObject':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimeObject> element')
            self.set_AbstractTimeObject(obj_)
        elif nodeName_ == 'Null':
            Null_ = child_.text
            Null_ = self.gds_validate_string(Null_, node, 'Null')
            self.Null = Null_
# end class ValuePropertyType


class ValueArrayPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractValue=None, AbstractGeometry=None, AbstractTimeObject=None, Null=None):
        self.owns = _cast(None, owns)
        self.AbstractValue = AbstractValue
        self.AbstractGeometry = AbstractGeometry
        self.AbstractTimeObject = AbstractTimeObject
        self.Null = Null
    def factory(*args_, **kwargs_):
        if ValueArrayPropertyType.subclass:
            return ValueArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return ValueArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractValue(self): return self.AbstractValue
    def set_AbstractValue(self, AbstractValue): self.AbstractValue = AbstractValue
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_AbstractTimeObject(self): return self.AbstractTimeObject
    def set_AbstractTimeObject(self, AbstractTimeObject): self.AbstractTimeObject = AbstractTimeObject
    def get_Null(self): return self.Null
    def set_Null(self, Null): self.Null = Null
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='ValueArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueArrayPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ValueArrayPropertyType', fromsubclass_=False):
        if self.AbstractValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbstractValue>%s</%sAbstractValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbstractValue).encode(ExternalEncoding), input_name='AbstractValue'), namespace_))
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
        if self.AbstractTimeObject is not None:
            self.AbstractTimeObject.export(outfile, level, namespace_, name_='AbstractTimeObject')
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('<%sNull>%s</%sNull>\n' % (namespace_, self.gds_format_string(quote_xml(self.Null).encode(ExternalEncoding), input_name='Null'), namespace_))
    def hasContent_(self):
        if (
            self.AbstractValue is not None or
            self.AbstractGeometry is not None or
            self.AbstractTimeObject is not None or
            self.Null is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractValue is not None:
            showIndent(outfile, level)
            outfile.write('AbstractValue=%s,\n' % quote_python(self.AbstractValue).encode(ExternalEncoding))
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbstractTimeObject is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTimeObject=model_.AbstractTimeObject(\n')
            self.AbstractTimeObject.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('Null=%s,\n' % quote_python(self.Null).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractValue':
            AbstractValue_ = child_.text
            AbstractValue_ = self.gds_validate_string(AbstractValue_, node, 'AbstractValue')
            self.AbstractValue = AbstractValue_
        elif nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
        elif nodeName_ == 'AbstractTimeObject':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimeObject> element')
            self.set_AbstractTimeObject(obj_)
        elif nodeName_ == 'Null':
            Null_ = child_.text
            Null_ = self.gds_validate_string(Null_, node, 'Null')
            self.Null = Null_
# end class ValueArrayPropertyType


class CompositeValueType(AbstractGMLType):
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, valueComponent=None, valueComponents=None, extensiontype_=None):
        super(CompositeValueType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.aggregationType = _cast(None, aggregationType)
        if valueComponent is None:
            self.valueComponent = []
        else:
            self.valueComponent = valueComponent
        self.valueComponents = valueComponents
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CompositeValueType.subclass:
            return CompositeValueType.subclass(*args_, **kwargs_)
        else:
            return CompositeValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueComponent(self): return self.valueComponent
    def set_valueComponent(self, valueComponent): self.valueComponent = valueComponent
    def add_valueComponent(self, value): self.valueComponent.append(value)
    def insert_valueComponent(self, index, value): self.valueComponent[index] = value
    def get_valueComponents(self): return self.valueComponents
    def set_valueComponents(self, valueComponents): self.valueComponents = valueComponents
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='CompositeValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompositeValueType'):
        super(CompositeValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeValueType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CompositeValueType', fromsubclass_=False):
        super(CompositeValueType, self).exportChildren(outfile, level, namespace_, name_, True)
        for valueComponent_ in self.valueComponent:
            valueComponent_.export(outfile, level, namespace_, name_='valueComponent')
        if self.valueComponents is not None:
            self.valueComponents.export(outfile, level, namespace_, name_='valueComponents')
    def hasContent_(self):
        if (
            self.valueComponent or
            self.valueComponents is not None or
            super(CompositeValueType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CompositeValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(CompositeValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CompositeValueType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueComponent=[\n')
        level += 1
        for valueComponent_ in self.valueComponent:
            showIndent(outfile, level)
            outfile.write('model_.valueComponent(\n')
            valueComponent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.valueComponents is not None:
            showIndent(outfile, level)
            outfile.write('valueComponents=model_.valueComponents(\n')
            self.valueComponents.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(CompositeValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'valueComponent':
            obj_ = ValuePropertyType.factory()
            obj_.build(child_)
            self.valueComponent.append(obj_)
        elif nodeName_ == 'valueComponents':
            obj_ = ValueArrayPropertyType.factory()
            obj_.build(child_)
            self.set_valueComponents(obj_)
        super(CompositeValueType, self).buildChildren(child_, node, nodeName_, True)
# end class CompositeValueType


class ValueArrayType(CompositeValueType):
    subclass = None
    superclass = CompositeValueType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, valueComponent=None, valueComponents=None, codeSpace=None, uom=None):
        super(ValueArrayType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, aggregationType, valueComponent, valueComponents, )
        self.codeSpace = _cast(None, codeSpace)
        self.uom = _cast(None, uom)
        pass
    def factory(*args_, **kwargs_):
        if ValueArrayType.subclass:
            return ValueArrayType.subclass(*args_, **kwargs_)
        else:
            return ValueArrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    def export(self, outfile, level, namespace_='', name_='ValueArrayType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueArrayType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueArrayType'):
        super(ValueArrayType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ValueArrayType')
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            outfile.write(' codeSpace=%s' % (quote_attrib(self.codeSpace), ))
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ValueArrayType', fromsubclass_=False):
        super(ValueArrayType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(ValueArrayType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueArrayType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            showIndent(outfile, level)
            outfile.write('codeSpace = %s,\n' % (self.codeSpace,))
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            showIndent(outfile, level)
            outfile.write('uom = %s,\n' % (self.uom,))
        super(ValueArrayType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ValueArrayType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            self.codeSpace = value
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            self.uom = value
        super(ValueArrayType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ValueArrayType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ValueArrayType


class CategoryExtentType(CodeOrNilReasonListType):
    subclass = None
    superclass = CodeOrNilReasonListType
    def __init__(self, codeSpace=None, valueOf_=None):
        super(CategoryExtentType, self).__init__(codeSpace, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CategoryExtentType.subclass:
            return CategoryExtentType.subclass(*args_, **kwargs_)
        else:
            return CategoryExtentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='CategoryExtentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryExtentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CategoryExtentType'):
        super(CategoryExtentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryExtentType')
    def exportChildren(self, outfile, level, namespace_='', name_='CategoryExtentType', fromsubclass_=False):
        super(CategoryExtentType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CategoryExtentType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CategoryExtentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CategoryExtentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CategoryExtentType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CategoryExtentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CategoryExtentType


class QuantityExtentType(MeasureOrNilReasonListType):
    subclass = None
    superclass = MeasureOrNilReasonListType
    def __init__(self, uom=None, valueOf_=None):
        super(QuantityExtentType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if QuantityExtentType.subclass:
            return QuantityExtentType.subclass(*args_, **kwargs_)
        else:
            return QuantityExtentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='QuantityExtentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityExtentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuantityExtentType'):
        super(QuantityExtentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityExtentType')
    def exportChildren(self, outfile, level, namespace_='', name_='QuantityExtentType', fromsubclass_=False):
        super(QuantityExtentType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(QuantityExtentType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QuantityExtentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QuantityExtentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QuantityExtentType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(QuantityExtentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuantityExtentType


class BooleanPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Boolean=None):
        self.Boolean = Boolean
    def factory(*args_, **kwargs_):
        if BooleanPropertyType.subclass:
            return BooleanPropertyType.subclass(*args_, **kwargs_)
        else:
            return BooleanPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Boolean(self): return self.Boolean
    def set_Boolean(self, Boolean): self.Boolean = Boolean
    def export(self, outfile, level, namespace_='', name_='BooleanPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BooleanPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BooleanPropertyType', fromsubclass_=False):
        if self.Boolean is not None:
            showIndent(outfile, level)
            outfile.write('<%sBoolean>%s</%sBoolean>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.Boolean)), input_name='Boolean'), namespace_))
    def hasContent_(self):
        if (
            self.Boolean is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BooleanPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Boolean is not None:
            showIndent(outfile, level)
            outfile.write('Boolean=%s,\n' % self.Boolean)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Boolean':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Boolean')
            self.Boolean = ival_
# end class BooleanPropertyType


class CategoryPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Category=None):
        self.Category = Category
    def factory(*args_, **kwargs_):
        if CategoryPropertyType.subclass:
            return CategoryPropertyType.subclass(*args_, **kwargs_)
        else:
            return CategoryPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def export(self, outfile, level, namespace_='', name_='CategoryPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CategoryPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CategoryPropertyType', fromsubclass_=False):
        if self.Category is not None:
            self.Category.export(outfile, level, namespace_, name_='Category', )
    def hasContent_(self):
        if (
            self.Category is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CategoryPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=model_.Category(\n')
            self.Category.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Category':
            obj_ = Category.factory()
            obj_.build(child_)
            self.set_Category(obj_)
# end class CategoryPropertyType


class QuantityPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Quantity=None):
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if QuantityPropertyType.subclass:
            return QuantityPropertyType.subclass(*args_, **kwargs_)
        else:
            return QuantityPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def export(self, outfile, level, namespace_='', name_='QuantityPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuantityPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuantityPropertyType', fromsubclass_=False):
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_, name_='Quantity', )
    def hasContent_(self):
        if (
            self.Quantity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QuantityPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Quantity is not None:
            showIndent(outfile, level)
            outfile.write('Quantity=model_.Quantity(\n')
            self.Quantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.set_Quantity(obj_)
# end class QuantityPropertyType


class CountPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Count=None):
        self.Count = Count
    def factory(*args_, **kwargs_):
        if CountPropertyType.subclass:
            return CountPropertyType.subclass(*args_, **kwargs_)
        else:
            return CountPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    def export(self, outfile, level, namespace_='', name_='CountPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CountPropertyType', fromsubclass_=False):
        if self.Count is not None:
            self.Count.export(outfile, level, namespace_, name_='Count', )
    def hasContent_(self):
        if (
            self.Count is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CountPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Count is not None:
            showIndent(outfile, level)
            outfile.write('Count=model_.Count(\n')
            self.Count.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Count':
            obj_ = Count.factory()
            obj_.build(child_)
            self.set_Count(obj_)
# end class CountPropertyType


class GridLimitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GridEnvelope=None):
        self.GridEnvelope = GridEnvelope
    def factory(*args_, **kwargs_):
        if GridLimitsType.subclass:
            return GridLimitsType.subclass(*args_, **kwargs_)
        else:
            return GridLimitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GridEnvelope(self): return self.GridEnvelope
    def set_GridEnvelope(self, GridEnvelope): self.GridEnvelope = GridEnvelope
    def export(self, outfile, level, namespace_='', name_='GridLimitsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GridLimitsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GridLimitsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GridLimitsType', fromsubclass_=False):
        if self.GridEnvelope is not None:
            self.GridEnvelope.export(outfile, level, namespace_, name_='GridEnvelope', )
    def hasContent_(self):
        if (
            self.GridEnvelope is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GridLimitsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GridEnvelope is not None:
            showIndent(outfile, level)
            outfile.write('GridEnvelope=model_.GridEnvelopeType(\n')
            self.GridEnvelope.exportLiteral(outfile, level, name_='GridEnvelope')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GridEnvelope':
            obj_ = GridEnvelopeType.factory()
            obj_.build(child_)
            self.set_GridEnvelope(obj_)
# end class GridLimitsType


class GridEnvelopeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, low=None, high=None):
        self.low = low
        self.high = high
    def factory(*args_, **kwargs_):
        if GridEnvelopeType.subclass:
            return GridEnvelopeType.subclass(*args_, **kwargs_)
        else:
            return GridEnvelopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_low(self): return self.low
    def set_low(self, low): self.low = low
    def validate_integerList(self, value):
        # Validate type integerList, a restriction on integer.
        pass
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def export(self, outfile, level, namespace_='', name_='GridEnvelopeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GridEnvelopeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GridEnvelopeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GridEnvelopeType', fromsubclass_=False):
        if self.low is not None:
            self.low.export(outfile, level, namespace_, name_='low', )
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', )
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GridEnvelopeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.low is not None:
            showIndent(outfile, level)
            outfile.write('low=model_.integer(\n')
            self.low.exportLiteral(outfile, level, name_='low')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.high is not None:
            showIndent(outfile, level)
            outfile.write('high=model_.integer(\n')
            self.high.exportLiteral(outfile, level, name_='high')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'low':
            low_ = child_.text
            self.low = low_
            self.low = self.low.split()
            self.validate_integerList(self.low)    # validate type integerList
        elif nodeName_ == 'high':
            high_ = child_.text
            self.high = high_
            self.high = self.high.split()
            self.validate_integerList(self.high)    # validate type integerList
# end class GridEnvelopeType


class SingleCRSPropertyType(GeneratedsSuper):
    """gml:SingleCRSPropertyType is a property type for association roles
    to a single coordinate reference system, either referencing or
    containing the definition of that coordinate reference system."""
    subclass = None
    superclass = None
    def __init__(self, AbstractSingleCRS=None):
        self.AbstractSingleCRS = AbstractSingleCRS
    def factory(*args_, **kwargs_):
        if SingleCRSPropertyType.subclass:
            return SingleCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return SingleCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractSingleCRS(self): return self.AbstractSingleCRS
    def set_AbstractSingleCRS(self, AbstractSingleCRS): self.AbstractSingleCRS = AbstractSingleCRS
    def export(self, outfile, level, namespace_='', name_='SingleCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SingleCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SingleCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SingleCRSPropertyType', fromsubclass_=False):
        if self.AbstractSingleCRS is not None:
            self.AbstractSingleCRS.export(outfile, level, namespace_, name_='AbstractSingleCRS')
    def hasContent_(self):
        if (
            self.AbstractSingleCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SingleCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractSingleCRS is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSingleCRS=model_.AbstractSingleCRS(\n')
            self.AbstractSingleCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractSingleCRS':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSingleCRS> element')
            self.set_AbstractSingleCRS(obj_)
# end class SingleCRSPropertyType


class CompoundCRSPropertyType(GeneratedsSuper):
    """gml:CompoundCRSPropertyType is a property type for association roles
    to a compound coordinate reference system, either referencing or
    containing the definition of that reference system."""
    subclass = None
    superclass = None
    def __init__(self, CompoundCRS=None):
        self.CompoundCRS = CompoundCRS
    def factory(*args_, **kwargs_):
        if CompoundCRSPropertyType.subclass:
            return CompoundCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return CompoundCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompoundCRS(self): return self.CompoundCRS
    def set_CompoundCRS(self, CompoundCRS): self.CompoundCRS = CompoundCRS
    def export(self, outfile, level, namespace_='', name_='CompoundCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompoundCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompoundCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CompoundCRSPropertyType', fromsubclass_=False):
        if self.CompoundCRS is not None:
            self.CompoundCRS.export(outfile, level, namespace_, name_='CompoundCRS', )
    def hasContent_(self):
        if (
            self.CompoundCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CompoundCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CompoundCRS is not None:
            showIndent(outfile, level)
            outfile.write('CompoundCRS=model_.CompoundCRS(\n')
            self.CompoundCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompoundCRS':
            obj_ = CompoundCRSType.factory()
            obj_.build(child_)
            self.set_CompoundCRS(obj_)
# end class CompoundCRSPropertyType


class GeodeticCRSPropertyType(GeneratedsSuper):
    """gml:GeodeticCRSPropertyType is a property type for association roles
    to a geodetic coordinate reference system, either referencing or
    containing the definition of that reference system."""
    subclass = None
    superclass = None
    def __init__(self, GeodeticCRS=None):
        self.GeodeticCRS = GeodeticCRS
    def factory(*args_, **kwargs_):
        if GeodeticCRSPropertyType.subclass:
            return GeodeticCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeodeticCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeodeticCRS(self): return self.GeodeticCRS
    def set_GeodeticCRS(self, GeodeticCRS): self.GeodeticCRS = GeodeticCRS
    def export(self, outfile, level, namespace_='', name_='GeodeticCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeodeticCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeodeticCRSPropertyType', fromsubclass_=False):
        if self.GeodeticCRS is not None:
            self.GeodeticCRS.export(outfile, level, namespace_, name_='GeodeticCRS', )
    def hasContent_(self):
        if (
            self.GeodeticCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeodeticCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GeodeticCRS is not None:
            showIndent(outfile, level)
            outfile.write('GeodeticCRS=model_.GeodeticCRS(\n')
            self.GeodeticCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeodeticCRS':
            obj_ = GeodeticCRSType.factory()
            obj_.build(child_)
            self.set_GeodeticCRS(obj_)
# end class GeodeticCRSPropertyType


class VerticalCRSPropertyType(GeneratedsSuper):
    """gml:VerticalCRSPropertyType is a property type for association roles
    to a vertical coordinate reference system, either referencing or
    containing the definition of that reference system."""
    subclass = None
    superclass = None
    def __init__(self, VerticalCRS=None):
        self.VerticalCRS = VerticalCRS
    def factory(*args_, **kwargs_):
        if VerticalCRSPropertyType.subclass:
            return VerticalCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return VerticalCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VerticalCRS(self): return self.VerticalCRS
    def set_VerticalCRS(self, VerticalCRS): self.VerticalCRS = VerticalCRS
    def export(self, outfile, level, namespace_='', name_='VerticalCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerticalCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VerticalCRSPropertyType', fromsubclass_=False):
        if self.VerticalCRS is not None:
            self.VerticalCRS.export(outfile, level, namespace_, name_='VerticalCRS', )
    def hasContent_(self):
        if (
            self.VerticalCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VerticalCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VerticalCRS is not None:
            showIndent(outfile, level)
            outfile.write('VerticalCRS=model_.VerticalCRS(\n')
            self.VerticalCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VerticalCRS':
            obj_ = VerticalCRSType.factory()
            obj_.build(child_)
            self.set_VerticalCRS(obj_)
# end class VerticalCRSPropertyType


class ProjectedCRSPropertyType(GeneratedsSuper):
    """gml:ProjectedCRSPropertyType is a property type for association
    roles to a projected coordinate reference system, either
    referencing or containing the definition of that reference
    system."""
    subclass = None
    superclass = None
    def __init__(self, ProjectedCRS=None):
        self.ProjectedCRS = ProjectedCRS
    def factory(*args_, **kwargs_):
        if ProjectedCRSPropertyType.subclass:
            return ProjectedCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return ProjectedCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProjectedCRS(self): return self.ProjectedCRS
    def set_ProjectedCRS(self, ProjectedCRS): self.ProjectedCRS = ProjectedCRS
    def export(self, outfile, level, namespace_='', name_='ProjectedCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProjectedCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProjectedCRSPropertyType', fromsubclass_=False):
        if self.ProjectedCRS is not None:
            self.ProjectedCRS.export(outfile, level, namespace_, name_='ProjectedCRS', )
    def hasContent_(self):
        if (
            self.ProjectedCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProjectedCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProjectedCRS is not None:
            showIndent(outfile, level)
            outfile.write('ProjectedCRS=model_.ProjectedCRS(\n')
            self.ProjectedCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProjectedCRS':
            obj_ = ProjectedCRSType.factory()
            obj_.build(child_)
            self.set_ProjectedCRS(obj_)
# end class ProjectedCRSPropertyType


class DerivedCRSPropertyType(GeneratedsSuper):
    """gml:DerivedCRSPropertyType is a property type for association roles
    to a non-projected derived coordinate reference system, either
    referencing or containing the definition of that reference
    system."""
    subclass = None
    superclass = None
    def __init__(self, DerivedCRS=None):
        self.DerivedCRS = DerivedCRS
    def factory(*args_, **kwargs_):
        if DerivedCRSPropertyType.subclass:
            return DerivedCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return DerivedCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DerivedCRS(self): return self.DerivedCRS
    def set_DerivedCRS(self, DerivedCRS): self.DerivedCRS = DerivedCRS
    def export(self, outfile, level, namespace_='', name_='DerivedCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivedCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DerivedCRSPropertyType', fromsubclass_=False):
        if self.DerivedCRS is not None:
            self.DerivedCRS.export(outfile, level, namespace_, name_='DerivedCRS', )
    def hasContent_(self):
        if (
            self.DerivedCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DerivedCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DerivedCRS is not None:
            showIndent(outfile, level)
            outfile.write('DerivedCRS=model_.DerivedCRS(\n')
            self.DerivedCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DerivedCRS':
            obj_ = DerivedCRSType.factory()
            obj_.build(child_)
            self.set_DerivedCRS(obj_)
# end class DerivedCRSPropertyType


class EngineeringCRSPropertyType(GeneratedsSuper):
    """gml:EngineeringCRSPropertyType is a property type for association
    roles to an engineering coordinate reference system, either
    referencing or containing the definition of that reference
    system."""
    subclass = None
    superclass = None
    def __init__(self, EngineeringCRS=None):
        self.EngineeringCRS = EngineeringCRS
    def factory(*args_, **kwargs_):
        if EngineeringCRSPropertyType.subclass:
            return EngineeringCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return EngineeringCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EngineeringCRS(self): return self.EngineeringCRS
    def set_EngineeringCRS(self, EngineeringCRS): self.EngineeringCRS = EngineeringCRS
    def export(self, outfile, level, namespace_='', name_='EngineeringCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EngineeringCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EngineeringCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EngineeringCRSPropertyType', fromsubclass_=False):
        if self.EngineeringCRS is not None:
            self.EngineeringCRS.export(outfile, level, namespace_, name_='EngineeringCRS', )
    def hasContent_(self):
        if (
            self.EngineeringCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EngineeringCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EngineeringCRS is not None:
            showIndent(outfile, level)
            outfile.write('EngineeringCRS=model_.EngineeringCRS(\n')
            self.EngineeringCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EngineeringCRS':
            obj_ = EngineeringCRSType.factory()
            obj_.build(child_)
            self.set_EngineeringCRS(obj_)
# end class EngineeringCRSPropertyType


class ImageCRSPropertyType(GeneratedsSuper):
    """gml:ImageCRSPropertyType is a property type for association roles to
    an image coordinate reference system, either referencing or
    containing the definition of that reference system."""
    subclass = None
    superclass = None
    def __init__(self, ImageCRS=None):
        self.ImageCRS = ImageCRS
    def factory(*args_, **kwargs_):
        if ImageCRSPropertyType.subclass:
            return ImageCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return ImageCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ImageCRS(self): return self.ImageCRS
    def set_ImageCRS(self, ImageCRS): self.ImageCRS = ImageCRS
    def export(self, outfile, level, namespace_='', name_='ImageCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImageCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImageCRSPropertyType', fromsubclass_=False):
        if self.ImageCRS is not None:
            self.ImageCRS.export(outfile, level, namespace_, name_='ImageCRS', )
    def hasContent_(self):
        if (
            self.ImageCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImageCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ImageCRS is not None:
            showIndent(outfile, level)
            outfile.write('ImageCRS=model_.ImageCRS(\n')
            self.ImageCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ImageCRS':
            obj_ = ImageCRSType.factory()
            obj_.build(child_)
            self.set_ImageCRS(obj_)
# end class ImageCRSPropertyType


class TemporalCRSPropertyType(GeneratedsSuper):
    """gml:TemporalCRSPropertyType is a property type for association roles
    to a temporal coordinate reference system, either referencing or
    containing the definition of that reference system."""
    subclass = None
    superclass = None
    def __init__(self, TemporalCRS=None):
        self.TemporalCRS = TemporalCRS
    def factory(*args_, **kwargs_):
        if TemporalCRSPropertyType.subclass:
            return TemporalCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return TemporalCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TemporalCRS(self): return self.TemporalCRS
    def set_TemporalCRS(self, TemporalCRS): self.TemporalCRS = TemporalCRS
    def export(self, outfile, level, namespace_='', name_='TemporalCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TemporalCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TemporalCRSPropertyType', fromsubclass_=False):
        if self.TemporalCRS is not None:
            self.TemporalCRS.export(outfile, level, namespace_, name_='TemporalCRS', )
    def hasContent_(self):
        if (
            self.TemporalCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TemporalCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TemporalCRS is not None:
            showIndent(outfile, level)
            outfile.write('TemporalCRS=model_.TemporalCRS(\n')
            self.TemporalCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TemporalCRS':
            obj_ = TemporalCRSType.factory()
            obj_.build(child_)
            self.set_TemporalCRS(obj_)
# end class TemporalCRSPropertyType


class CoordinateSystemAxisPropertyType(GeneratedsSuper):
    """gml:CoordinateSystemAxisPropertyType is a property type for
    association roles to a coordinate system axis, either
    referencing or containing the definition of that axis."""
    subclass = None
    superclass = None
    def __init__(self, CoordinateSystemAxis=None):
        self.CoordinateSystemAxis = CoordinateSystemAxis
    def factory(*args_, **kwargs_):
        if CoordinateSystemAxisPropertyType.subclass:
            return CoordinateSystemAxisPropertyType.subclass(*args_, **kwargs_)
        else:
            return CoordinateSystemAxisPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CoordinateSystemAxis(self): return self.CoordinateSystemAxis
    def set_CoordinateSystemAxis(self, CoordinateSystemAxis): self.CoordinateSystemAxis = CoordinateSystemAxis
    def export(self, outfile, level, namespace_='', name_='CoordinateSystemAxisPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateSystemAxisPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoordinateSystemAxisPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoordinateSystemAxisPropertyType', fromsubclass_=False):
        if self.CoordinateSystemAxis is not None:
            self.CoordinateSystemAxis.export(outfile, level, namespace_, name_='CoordinateSystemAxis', )
    def hasContent_(self):
        if (
            self.CoordinateSystemAxis is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoordinateSystemAxisPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CoordinateSystemAxis is not None:
            showIndent(outfile, level)
            outfile.write('CoordinateSystemAxis=model_.CoordinateSystemAxis(\n')
            self.CoordinateSystemAxis.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CoordinateSystemAxis':
            obj_ = CoordinateSystemAxisType.factory()
            obj_.build(child_)
            self.set_CoordinateSystemAxis(obj_)
# end class CoordinateSystemAxisPropertyType


class CoordinateSystemPropertyType(GeneratedsSuper):
    """gml:CoordinateSystemPropertyType is a property type for association
    roles to a coordinate system, either referencing or containing
    the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, AbstractCoordinateSystem=None):
        self.AbstractCoordinateSystem = AbstractCoordinateSystem
    def factory(*args_, **kwargs_):
        if CoordinateSystemPropertyType.subclass:
            return CoordinateSystemPropertyType.subclass(*args_, **kwargs_)
        else:
            return CoordinateSystemPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCoordinateSystem(self): return self.AbstractCoordinateSystem
    def set_AbstractCoordinateSystem(self, AbstractCoordinateSystem): self.AbstractCoordinateSystem = AbstractCoordinateSystem
    def export(self, outfile, level, namespace_='', name_='CoordinateSystemPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateSystemPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoordinateSystemPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoordinateSystemPropertyType', fromsubclass_=False):
        if self.AbstractCoordinateSystem is not None:
            self.AbstractCoordinateSystem.export(outfile, level, namespace_, name_='AbstractCoordinateSystem')
    def hasContent_(self):
        if (
            self.AbstractCoordinateSystem is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoordinateSystemPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractCoordinateSystem is not None:
            showIndent(outfile, level)
            outfile.write('AbstractCoordinateSystem=model_.AbstractCoordinateSystem(\n')
            self.AbstractCoordinateSystem.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCoordinateSystem':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCoordinateSystem> element')
            self.set_AbstractCoordinateSystem(obj_)
# end class CoordinateSystemPropertyType


class EllipsoidalCSPropertyType(GeneratedsSuper):
    """gml:EllipsoidalCSPropertyType is a property type for association
    roles to an ellipsoidal coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, EllipsoidalCS=None):
        self.EllipsoidalCS = EllipsoidalCS
    def factory(*args_, **kwargs_):
        if EllipsoidalCSPropertyType.subclass:
            return EllipsoidalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EllipsoidalCS(self): return self.EllipsoidalCS
    def set_EllipsoidalCS(self, EllipsoidalCS): self.EllipsoidalCS = EllipsoidalCS
    def export(self, outfile, level, namespace_='', name_='EllipsoidalCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidalCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EllipsoidalCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EllipsoidalCSPropertyType', fromsubclass_=False):
        if self.EllipsoidalCS is not None:
            self.EllipsoidalCS.export(outfile, level, namespace_, name_='EllipsoidalCS', )
    def hasContent_(self):
        if (
            self.EllipsoidalCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EllipsoidalCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EllipsoidalCS is not None:
            showIndent(outfile, level)
            outfile.write('EllipsoidalCS=model_.EllipsoidalCS(\n')
            self.EllipsoidalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EllipsoidalCS':
            obj_ = EllipsoidalCSType.factory()
            obj_.build(child_)
            self.set_EllipsoidalCS(obj_)
# end class EllipsoidalCSPropertyType


class CartesianCSPropertyType(GeneratedsSuper):
    """gml:CartesianCSPropertyType is a property type for association roles
    to a Cartesian coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, CartesianCS=None):
        self.CartesianCS = CartesianCS
    def factory(*args_, **kwargs_):
        if CartesianCSPropertyType.subclass:
            return CartesianCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return CartesianCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CartesianCS(self): return self.CartesianCS
    def set_CartesianCS(self, CartesianCS): self.CartesianCS = CartesianCS
    def export(self, outfile, level, namespace_='', name_='CartesianCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CartesianCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CartesianCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CartesianCSPropertyType', fromsubclass_=False):
        if self.CartesianCS is not None:
            self.CartesianCS.export(outfile, level, namespace_, name_='CartesianCS', )
    def hasContent_(self):
        if (
            self.CartesianCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CartesianCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('CartesianCS=model_.CartesianCS(\n')
            self.CartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CartesianCS':
            obj_ = CartesianCSType.factory()
            obj_.build(child_)
            self.set_CartesianCS(obj_)
# end class CartesianCSPropertyType


class VerticalCSPropertyType(GeneratedsSuper):
    """gml:VerticalCSPropertyType is a property type for association roles
    to a vertical coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, VerticalCS=None):
        self.VerticalCS = VerticalCS
    def factory(*args_, **kwargs_):
        if VerticalCSPropertyType.subclass:
            return VerticalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return VerticalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VerticalCS(self): return self.VerticalCS
    def set_VerticalCS(self, VerticalCS): self.VerticalCS = VerticalCS
    def export(self, outfile, level, namespace_='', name_='VerticalCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerticalCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VerticalCSPropertyType', fromsubclass_=False):
        if self.VerticalCS is not None:
            self.VerticalCS.export(outfile, level, namespace_, name_='VerticalCS', )
    def hasContent_(self):
        if (
            self.VerticalCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VerticalCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VerticalCS is not None:
            showIndent(outfile, level)
            outfile.write('VerticalCS=model_.VerticalCS(\n')
            self.VerticalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VerticalCS':
            obj_ = VerticalCSType.factory()
            obj_.build(child_)
            self.set_VerticalCS(obj_)
# end class VerticalCSPropertyType


class TimeCSPropertyType(GeneratedsSuper):
    """gml:TimeCSPropertyType is a property type for association roles to a
    time coordinate system, either referencing or containing the
    definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, TimeCS=None):
        self.TimeCS = TimeCS
    def factory(*args_, **kwargs_):
        if TimeCSPropertyType.subclass:
            return TimeCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeCS(self): return self.TimeCS
    def set_TimeCS(self, TimeCS): self.TimeCS = TimeCS
    def export(self, outfile, level, namespace_='', name_='TimeCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCSPropertyType', fromsubclass_=False):
        if self.TimeCS is not None:
            self.TimeCS.export(outfile, level, namespace_, name_='TimeCS', )
    def hasContent_(self):
        if (
            self.TimeCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeCS is not None:
            showIndent(outfile, level)
            outfile.write('TimeCS=model_.TimeCS(\n')
            self.TimeCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeCS':
            obj_ = TimeCSType.factory()
            obj_.build(child_)
            self.set_TimeCS(obj_)
# end class TimeCSPropertyType


class LinearCSPropertyType(GeneratedsSuper):
    """gml:LinearCSPropertyType is a property type for association roles to
    a linear coordinate system, either referencing or containing the
    definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, LinearCS=None):
        self.LinearCS = LinearCS
    def factory(*args_, **kwargs_):
        if LinearCSPropertyType.subclass:
            return LinearCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return LinearCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinearCS(self): return self.LinearCS
    def set_LinearCS(self, LinearCS): self.LinearCS = LinearCS
    def export(self, outfile, level, namespace_='', name_='LinearCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinearCSPropertyType', fromsubclass_=False):
        if self.LinearCS is not None:
            self.LinearCS.export(outfile, level, namespace_, name_='LinearCS', )
    def hasContent_(self):
        if (
            self.LinearCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LinearCS is not None:
            showIndent(outfile, level)
            outfile.write('LinearCS=model_.LinearCS(\n')
            self.LinearCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinearCS':
            obj_ = LinearCSType.factory()
            obj_.build(child_)
            self.set_LinearCS(obj_)
# end class LinearCSPropertyType


class UserDefinedCSPropertyType(GeneratedsSuper):
    """gml:UserDefinedCSPropertyType is a property type for association
    roles to a user-defined coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, UserDefinedCS=None):
        self.UserDefinedCS = UserDefinedCS
    def factory(*args_, **kwargs_):
        if UserDefinedCSPropertyType.subclass:
            return UserDefinedCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return UserDefinedCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UserDefinedCS(self): return self.UserDefinedCS
    def set_UserDefinedCS(self, UserDefinedCS): self.UserDefinedCS = UserDefinedCS
    def export(self, outfile, level, namespace_='', name_='UserDefinedCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserDefinedCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UserDefinedCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UserDefinedCSPropertyType', fromsubclass_=False):
        if self.UserDefinedCS is not None:
            self.UserDefinedCS.export(outfile, level, namespace_, name_='UserDefinedCS', )
    def hasContent_(self):
        if (
            self.UserDefinedCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UserDefinedCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UserDefinedCS is not None:
            showIndent(outfile, level)
            outfile.write('UserDefinedCS=model_.UserDefinedCS(\n')
            self.UserDefinedCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UserDefinedCS':
            obj_ = UserDefinedCSType.factory()
            obj_.build(child_)
            self.set_UserDefinedCS(obj_)
# end class UserDefinedCSPropertyType


class SphericalCSPropertyType(GeneratedsSuper):
    """gml:SphericalCSPropertyType is property type for association roles
    to a spherical coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, SphericalCS=None):
        self.SphericalCS = SphericalCS
    def factory(*args_, **kwargs_):
        if SphericalCSPropertyType.subclass:
            return SphericalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return SphericalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SphericalCS(self): return self.SphericalCS
    def set_SphericalCS(self, SphericalCS): self.SphericalCS = SphericalCS
    def export(self, outfile, level, namespace_='', name_='SphericalCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SphericalCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SphericalCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SphericalCSPropertyType', fromsubclass_=False):
        if self.SphericalCS is not None:
            self.SphericalCS.export(outfile, level, namespace_, name_='SphericalCS', )
    def hasContent_(self):
        if (
            self.SphericalCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SphericalCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SphericalCS is not None:
            showIndent(outfile, level)
            outfile.write('SphericalCS=model_.SphericalCS(\n')
            self.SphericalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SphericalCS':
            obj_ = SphericalCSType.factory()
            obj_.build(child_)
            self.set_SphericalCS(obj_)
# end class SphericalCSPropertyType


class PolarCSPropertyType(GeneratedsSuper):
    """gml:PolarCSPropertyType is a property type for association roles to
    a polar coordinate system, either referencing or containing the
    definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, PolarCS=None):
        self.PolarCS = PolarCS
    def factory(*args_, **kwargs_):
        if PolarCSPropertyType.subclass:
            return PolarCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return PolarCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PolarCS(self): return self.PolarCS
    def set_PolarCS(self, PolarCS): self.PolarCS = PolarCS
    def export(self, outfile, level, namespace_='', name_='PolarCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolarCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolarCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PolarCSPropertyType', fromsubclass_=False):
        if self.PolarCS is not None:
            self.PolarCS.export(outfile, level, namespace_, name_='PolarCS', )
    def hasContent_(self):
        if (
            self.PolarCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolarCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PolarCS is not None:
            showIndent(outfile, level)
            outfile.write('PolarCS=model_.PolarCS(\n')
            self.PolarCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PolarCS':
            obj_ = PolarCSType.factory()
            obj_.build(child_)
            self.set_PolarCS(obj_)
# end class PolarCSPropertyType


class CylindricalCSPropertyType(GeneratedsSuper):
    """gml:CylindricalCSPropertyType is a property type for association
    roles to a cylindrical coordinate system, either referencing or
    containing the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, CylindricalCS=None):
        self.CylindricalCS = CylindricalCS
    def factory(*args_, **kwargs_):
        if CylindricalCSPropertyType.subclass:
            return CylindricalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return CylindricalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CylindricalCS(self): return self.CylindricalCS
    def set_CylindricalCS(self, CylindricalCS): self.CylindricalCS = CylindricalCS
    def export(self, outfile, level, namespace_='', name_='CylindricalCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CylindricalCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CylindricalCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CylindricalCSPropertyType', fromsubclass_=False):
        if self.CylindricalCS is not None:
            self.CylindricalCS.export(outfile, level, namespace_, name_='CylindricalCS', )
    def hasContent_(self):
        if (
            self.CylindricalCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CylindricalCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CylindricalCS is not None:
            showIndent(outfile, level)
            outfile.write('CylindricalCS=model_.CylindricalCS(\n')
            self.CylindricalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CylindricalCS':
            obj_ = CylindricalCSType.factory()
            obj_.build(child_)
            self.set_CylindricalCS(obj_)
# end class CylindricalCSPropertyType


class AffineCSPropertyType(GeneratedsSuper):
    """gml:AffineCSPropertyType is a property type for association roles to
    an affine coordinate system, either referencing or containing
    the definition of that coordinate system."""
    subclass = None
    superclass = None
    def __init__(self, AffineCS=None):
        self.AffineCS = AffineCS
    def factory(*args_, **kwargs_):
        if AffineCSPropertyType.subclass:
            return AffineCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return AffineCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AffineCS(self): return self.AffineCS
    def set_AffineCS(self, AffineCS): self.AffineCS = AffineCS
    def export(self, outfile, level, namespace_='', name_='AffineCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AffineCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AffineCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AffineCSPropertyType', fromsubclass_=False):
        if self.AffineCS is not None:
            self.AffineCS.export(outfile, level, namespace_, name_='AffineCS', )
    def hasContent_(self):
        if (
            self.AffineCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AffineCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AffineCS is not None:
            showIndent(outfile, level)
            outfile.write('AffineCS=model_.AffineCS(\n')
            self.AffineCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AffineCS':
            obj_ = AffineCSType.factory()
            obj_.build(child_)
            self.set_AffineCS(obj_)
# end class AffineCSPropertyType


class IdentifiedObjectType(DefinitionType):
    """gml:IdentifiedObjectType provides identification properties of a
    CRS-related object. In gml:DefinitionType, the gml:identifier
    element shall be the primary name by which this object is
    identified, encoding the "name" attribute in the UML model. Zero
    or more of the gml:name elements can be an unordered set of
    "identifiers", encoding the "identifier" attribute in the UML
    model. Each of these gml:name elements can reference elsewhere
    the object's defining information or be an identifier by which
    this object can be referenced. Zero or more other gml:name
    elements can be an unordered set of "alias" alternative names by
    which this CRS related object is identified, encoding the
    "alias" attributes in the UML model. An object may have several
    aliases, typically used in different contexts. The context for
    an alias is indicated by the value of its (optional) codeSpace
    attribute. Any needed version information shall be included in
    the codeSpace attribute of a gml:identifier and gml:name
    elements. In this use, the gml:remarks element in the
    gml:DefinitionType shall contain comments on or information
    about this object, including data source information."""
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, extensiontype_=None):
        super(IdentifiedObjectType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IdentifiedObjectType.subclass:
            return IdentifiedObjectType.subclass(*args_, **kwargs_)
        else:
            return IdentifiedObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='IdentifiedObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedObjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedObjectType'):
        super(IdentifiedObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedObjectType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedObjectType', fromsubclass_=False):
        super(IdentifiedObjectType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(IdentifiedObjectType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IdentifiedObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IdentifiedObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiedObjectType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(IdentifiedObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentifiedObjectType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiedObjectType


class AbstractCRSType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, extensiontype_=None):
        super(AbstractCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        if domainOfValidity is None:
            self.domainOfValidity = []
        else:
            self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractCRSType.subclass:
            return AbstractCRSType.subclass(*args_, **kwargs_)
        else:
            return AbstractCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def add_domainOfValidity(self, value): self.domainOfValidity.append(value)
    def insert_domainOfValidity(self, index, value): self.domainOfValidity[index] = value
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope(self, index, value): self.scope[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractCRSType'):
        super(AbstractCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCRSType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCRSType', fromsubclass_=False):
        super(AbstractCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        for domainOfValidity_ in self.domainOfValidity:
            domainOfValidity_.export(outfile, level, namespace_, name_='domainOfValidity')
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.gds_format_string(quote_xml(scope_).encode(ExternalEncoding), input_name='scope'), namespace_))
    def hasContent_(self):
        if (
            self.domainOfValidity or
            self.scope or
            super(AbstractCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractCRSType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('domainOfValidity=[\n')
        level += 1
        for domainOfValidity_ in self.domainOfValidity:
            showIndent(outfile, level)
            outfile.write('model_.domainOfValidity(\n')
            domainOfValidity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('scope=[\n')
        level += 1
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.domainOfValidity.append(obj_)
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        super(AbstractCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractCRSType


class domainOfValidity(GeneratedsSuper):
    """The gml:domainOfValidity property implements an association role to
    an EX_Extent object as encoded in ISO/TS 19139, either
    referencing or containing the definition of that extent."""
    subclass = None
    superclass = None
    def __init__(self, EX_Extent=None):
        self.EX_Extent = EX_Extent
    def factory(*args_, **kwargs_):
        if domainOfValidity.subclass:
            return domainOfValidity.subclass(*args_, **kwargs_)
        else:
            return domainOfValidity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_Extent(self): return self.EX_Extent
    def set_EX_Extent(self, EX_Extent): self.EX_Extent = EX_Extent
    def export(self, outfile, level, namespace_='', name_='domainOfValidity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='domainOfValidity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='domainOfValidity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='domainOfValidity', fromsubclass_=False):
        if self.EX_Extent is not None:
            self.EX_Extent.export(outfile, level, namespace_, name_='EX_Extent', )
    def hasContent_(self):
        if (
            self.EX_Extent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='domainOfValidity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_Extent is not None:
            showIndent(outfile, level)
            outfile.write('EX_Extent=model_.EX_Extent(\n')
            self.EX_Extent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_Extent':
            obj_ = EX_Extent_Type.factory()
            obj_.build(child_)
            self.set_EX_Extent(obj_)
# end class domainOfValidity


class CRSPropertyType(GeneratedsSuper):
    """gml:CRSPropertyType is a property type for association roles to a
    CRS abstract coordinate reference system, either referencing or
    containing the definition of that CRS."""
    subclass = None
    superclass = None
    def __init__(self, AbstractCRS=None):
        self.AbstractCRS = AbstractCRS
    def factory(*args_, **kwargs_):
        if CRSPropertyType.subclass:
            return CRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return CRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCRS(self): return self.AbstractCRS
    def set_AbstractCRS(self, AbstractCRS): self.AbstractCRS = AbstractCRS
    def export(self, outfile, level, namespace_='', name_='CRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CRSPropertyType', fromsubclass_=False):
        if self.AbstractCRS is not None:
            self.AbstractCRS.export(outfile, level, namespace_, name_='AbstractCRS')
    def hasContent_(self):
        if (
            self.AbstractCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractCRS is not None:
            showIndent(outfile, level)
            outfile.write('AbstractCRS=model_.AbstractCRS(\n')
            self.AbstractCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCRS':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCRS> element')
            self.set_AbstractCRS(obj_)
# end class CRSPropertyType


class DS_Aggregate_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDS_Aggregate=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDS_Aggregate = AbstractDS_Aggregate
    def factory(*args_, **kwargs_):
        if DS_Aggregate_PropertyType.subclass:
            return DS_Aggregate_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_Aggregate_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDS_Aggregate(self): return self.AbstractDS_Aggregate
    def set_AbstractDS_Aggregate(self, AbstractDS_Aggregate): self.AbstractDS_Aggregate = AbstractDS_Aggregate
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_Aggregate_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Aggregate_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Aggregate_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Aggregate_PropertyType', fromsubclass_=False):
        if self.AbstractDS_Aggregate is not None:
            self.AbstractDS_Aggregate.export(outfile, level, namespace_, name_='AbstractDS_Aggregate')
    def hasContent_(self):
        if (
            self.AbstractDS_Aggregate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Aggregate_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDS_Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDS_Aggregate=model_.AbstractDS_Aggregate(\n')
            self.AbstractDS_Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDS_Aggregate':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDS_Aggregate> element')
            self.set_AbstractDS_Aggregate(obj_)
# end class DS_Aggregate_PropertyType


class DS_DataSet_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_DataSet=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_DataSet = DS_DataSet
    def factory(*args_, **kwargs_):
        if DS_DataSet_PropertyType.subclass:
            return DS_DataSet_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_DataSet_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_DataSet(self): return self.DS_DataSet
    def set_DS_DataSet(self, DS_DataSet): self.DS_DataSet = DS_DataSet
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_DataSet_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_DataSet_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_DataSet_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_DataSet_PropertyType', fromsubclass_=False):
        if self.DS_DataSet is not None:
            self.DS_DataSet.export(outfile, level, namespace_, name_='DS_DataSet', )
    def hasContent_(self):
        if (
            self.DS_DataSet is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_DataSet_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_DataSet is not None:
            showIndent(outfile, level)
            outfile.write('DS_DataSet=model_.DS_DataSet(\n')
            self.DS_DataSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_DataSet':
            obj_ = DS_DataSet_Type.factory()
            obj_.build(child_)
            self.set_DS_DataSet(obj_)
# end class DS_DataSet_PropertyType


class DS_OtherAggregate_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_OtherAggregate=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_OtherAggregate = DS_OtherAggregate
    def factory(*args_, **kwargs_):
        if DS_OtherAggregate_PropertyType.subclass:
            return DS_OtherAggregate_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_OtherAggregate_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_OtherAggregate(self): return self.DS_OtherAggregate
    def set_DS_OtherAggregate(self, DS_OtherAggregate): self.DS_OtherAggregate = DS_OtherAggregate
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_OtherAggregate_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_OtherAggregate_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_OtherAggregate_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_OtherAggregate_PropertyType', fromsubclass_=False):
        if self.DS_OtherAggregate is not None:
            self.DS_OtherAggregate.export(outfile, level, namespace_, name_='DS_OtherAggregate', )
    def hasContent_(self):
        if (
            self.DS_OtherAggregate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_OtherAggregate_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_OtherAggregate is not None:
            showIndent(outfile, level)
            outfile.write('DS_OtherAggregate=model_.DS_OtherAggregate(\n')
            self.DS_OtherAggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_OtherAggregate':
            class_obj_ = self.get_class_obj_(child_, DS_OtherAggregate_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DS_OtherAggregate(obj_)
# end class DS_OtherAggregate_PropertyType


class DS_Series_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_Series=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_Series = DS_Series
    def factory(*args_, **kwargs_):
        if DS_Series_PropertyType.subclass:
            return DS_Series_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_Series_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_Series(self): return self.DS_Series
    def set_DS_Series(self, DS_Series): self.DS_Series = DS_Series
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_Series_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Series_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Series_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Series_PropertyType', fromsubclass_=False):
        if self.DS_Series is not None:
            self.DS_Series.export(outfile, level, namespace_, name_='DS_Series', )
    def hasContent_(self):
        if (
            self.DS_Series is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Series_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_Series is not None:
            showIndent(outfile, level)
            outfile.write('DS_Series=model_.DS_Series(\n')
            self.DS_Series.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_Series':
            class_obj_ = self.get_class_obj_(child_, DS_Series_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DS_Series(obj_)
# end class DS_Series_PropertyType


class DS_Initiative_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_Initiative=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_Initiative = DS_Initiative
    def factory(*args_, **kwargs_):
        if DS_Initiative_PropertyType.subclass:
            return DS_Initiative_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_Initiative_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_Initiative(self): return self.DS_Initiative
    def set_DS_Initiative(self, DS_Initiative): self.DS_Initiative = DS_Initiative
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_Initiative_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Initiative_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Initiative_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Initiative_PropertyType', fromsubclass_=False):
        if self.DS_Initiative is not None:
            self.DS_Initiative.export(outfile, level, namespace_, name_='DS_Initiative', )
    def hasContent_(self):
        if (
            self.DS_Initiative is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Initiative_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_Initiative is not None:
            showIndent(outfile, level)
            outfile.write('DS_Initiative=model_.DS_Initiative(\n')
            self.DS_Initiative.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_Initiative':
            obj_ = DS_Initiative_Type.factory()
            obj_.build(child_)
            self.set_DS_Initiative(obj_)
# end class DS_Initiative_PropertyType


class DS_Platform_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_Platform=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_Platform = DS_Platform
    def factory(*args_, **kwargs_):
        if DS_Platform_PropertyType.subclass:
            return DS_Platform_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_Platform_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_Platform(self): return self.DS_Platform
    def set_DS_Platform(self, DS_Platform): self.DS_Platform = DS_Platform
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_Platform_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Platform_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Platform_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Platform_PropertyType', fromsubclass_=False):
        if self.DS_Platform is not None:
            self.DS_Platform.export(outfile, level, namespace_, name_='DS_Platform', )
    def hasContent_(self):
        if (
            self.DS_Platform is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Platform_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_Platform is not None:
            showIndent(outfile, level)
            outfile.write('DS_Platform=model_.DS_Platform(\n')
            self.DS_Platform.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_Platform':
            obj_ = DS_Platform_Type.factory()
            obj_.build(child_)
            self.set_DS_Platform(obj_)
# end class DS_Platform_PropertyType


class DS_Sensor_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_Sensor=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_Sensor = DS_Sensor
    def factory(*args_, **kwargs_):
        if DS_Sensor_PropertyType.subclass:
            return DS_Sensor_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_Sensor_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_Sensor(self): return self.DS_Sensor
    def set_DS_Sensor(self, DS_Sensor): self.DS_Sensor = DS_Sensor
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_Sensor_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Sensor_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Sensor_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Sensor_PropertyType', fromsubclass_=False):
        if self.DS_Sensor is not None:
            self.DS_Sensor.export(outfile, level, namespace_, name_='DS_Sensor', )
    def hasContent_(self):
        if (
            self.DS_Sensor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Sensor_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_Sensor is not None:
            showIndent(outfile, level)
            outfile.write('DS_Sensor=model_.DS_Sensor(\n')
            self.DS_Sensor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_Sensor':
            obj_ = DS_Sensor_Type.factory()
            obj_.build(child_)
            self.set_DS_Sensor(obj_)
# end class DS_Sensor_PropertyType


class DS_ProductionSeries_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_ProductionSeries=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_ProductionSeries = DS_ProductionSeries
    def factory(*args_, **kwargs_):
        if DS_ProductionSeries_PropertyType.subclass:
            return DS_ProductionSeries_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_ProductionSeries_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_ProductionSeries(self): return self.DS_ProductionSeries
    def set_DS_ProductionSeries(self, DS_ProductionSeries): self.DS_ProductionSeries = DS_ProductionSeries
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_ProductionSeries_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_ProductionSeries_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_ProductionSeries_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_ProductionSeries_PropertyType', fromsubclass_=False):
        if self.DS_ProductionSeries is not None:
            self.DS_ProductionSeries.export(outfile, level, namespace_, name_='DS_ProductionSeries', )
    def hasContent_(self):
        if (
            self.DS_ProductionSeries is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_ProductionSeries_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_ProductionSeries is not None:
            showIndent(outfile, level)
            outfile.write('DS_ProductionSeries=model_.DS_ProductionSeries(\n')
            self.DS_ProductionSeries.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_ProductionSeries':
            obj_ = DS_ProductionSeries_Type.factory()
            obj_.build(child_)
            self.set_DS_ProductionSeries(obj_)
# end class DS_ProductionSeries_PropertyType


class DS_StereoMate_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_StereoMate=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_StereoMate = DS_StereoMate
    def factory(*args_, **kwargs_):
        if DS_StereoMate_PropertyType.subclass:
            return DS_StereoMate_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_StereoMate_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_StereoMate(self): return self.DS_StereoMate
    def set_DS_StereoMate(self, DS_StereoMate): self.DS_StereoMate = DS_StereoMate
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_StereoMate_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_StereoMate_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_StereoMate_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_StereoMate_PropertyType', fromsubclass_=False):
        if self.DS_StereoMate is not None:
            self.DS_StereoMate.export(outfile, level, namespace_, name_='DS_StereoMate', )
    def hasContent_(self):
        if (
            self.DS_StereoMate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_StereoMate_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_StereoMate is not None:
            showIndent(outfile, level)
            outfile.write('DS_StereoMate=model_.DS_StereoMate(\n')
            self.DS_StereoMate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_StereoMate':
            obj_ = DS_StereoMate_Type.factory()
            obj_.build(child_)
            self.set_DS_StereoMate(obj_)
# end class DS_StereoMate_PropertyType


class MD_Metadata_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Metadata=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Metadata = MD_Metadata
    def factory(*args_, **kwargs_):
        if MD_Metadata_PropertyType.subclass:
            return MD_Metadata_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Metadata_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Metadata(self): return self.MD_Metadata
    def set_MD_Metadata(self, MD_Metadata): self.MD_Metadata = MD_Metadata
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Metadata_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Metadata_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Metadata_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Metadata_PropertyType', fromsubclass_=False):
        if self.MD_Metadata is not None:
            self.MD_Metadata.export(outfile, level, namespace_, name_='MD_Metadata', )
    def hasContent_(self):
        if (
            self.MD_Metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Metadata_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Metadata is not None:
            showIndent(outfile, level)
            outfile.write('MD_Metadata=model_.MD_Metadata(\n')
            self.MD_Metadata.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Metadata':
            obj_ = MD_Metadata_Type.factory()
            obj_.build(child_)
            self.set_MD_Metadata(obj_)
# end class MD_Metadata_PropertyType


class MD_GridSpatialRepresentation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_GridSpatialRepresentation=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_GridSpatialRepresentation = MD_GridSpatialRepresentation
    def factory(*args_, **kwargs_):
        if MD_GridSpatialRepresentation_PropertyType.subclass:
            return MD_GridSpatialRepresentation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_GridSpatialRepresentation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_GridSpatialRepresentation(self): return self.MD_GridSpatialRepresentation
    def set_MD_GridSpatialRepresentation(self, MD_GridSpatialRepresentation): self.MD_GridSpatialRepresentation = MD_GridSpatialRepresentation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_GridSpatialRepresentation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_GridSpatialRepresentation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_GridSpatialRepresentation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_GridSpatialRepresentation_PropertyType', fromsubclass_=False):
        if self.MD_GridSpatialRepresentation is not None:
            self.MD_GridSpatialRepresentation.export(outfile, level, namespace_, name_='MD_GridSpatialRepresentation', )
    def hasContent_(self):
        if (
            self.MD_GridSpatialRepresentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_GridSpatialRepresentation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_GridSpatialRepresentation is not None:
            showIndent(outfile, level)
            outfile.write('MD_GridSpatialRepresentation=model_.MD_GridSpatialRepresentation(\n')
            self.MD_GridSpatialRepresentation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_GridSpatialRepresentation':
            class_obj_ = self.get_class_obj_(child_, MD_GridSpatialRepresentation_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_MD_GridSpatialRepresentation(obj_)
# end class MD_GridSpatialRepresentation_PropertyType


class MD_VectorSpatialRepresentation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_VectorSpatialRepresentation=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_VectorSpatialRepresentation = MD_VectorSpatialRepresentation
    def factory(*args_, **kwargs_):
        if MD_VectorSpatialRepresentation_PropertyType.subclass:
            return MD_VectorSpatialRepresentation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_VectorSpatialRepresentation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_VectorSpatialRepresentation(self): return self.MD_VectorSpatialRepresentation
    def set_MD_VectorSpatialRepresentation(self, MD_VectorSpatialRepresentation): self.MD_VectorSpatialRepresentation = MD_VectorSpatialRepresentation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_VectorSpatialRepresentation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_VectorSpatialRepresentation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_VectorSpatialRepresentation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_VectorSpatialRepresentation_PropertyType', fromsubclass_=False):
        if self.MD_VectorSpatialRepresentation is not None:
            self.MD_VectorSpatialRepresentation.export(outfile, level, namespace_, name_='MD_VectorSpatialRepresentation', )
    def hasContent_(self):
        if (
            self.MD_VectorSpatialRepresentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_VectorSpatialRepresentation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_VectorSpatialRepresentation is not None:
            showIndent(outfile, level)
            outfile.write('MD_VectorSpatialRepresentation=model_.MD_VectorSpatialRepresentation(\n')
            self.MD_VectorSpatialRepresentation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_VectorSpatialRepresentation':
            obj_ = MD_VectorSpatialRepresentation_Type.factory()
            obj_.build(child_)
            self.set_MD_VectorSpatialRepresentation(obj_)
# end class MD_VectorSpatialRepresentation_PropertyType


class MD_SpatialRepresentation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractMD_SpatialRepresentation=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractMD_SpatialRepresentation = AbstractMD_SpatialRepresentation
    def factory(*args_, **kwargs_):
        if MD_SpatialRepresentation_PropertyType.subclass:
            return MD_SpatialRepresentation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_SpatialRepresentation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractMD_SpatialRepresentation(self): return self.AbstractMD_SpatialRepresentation
    def set_AbstractMD_SpatialRepresentation(self, AbstractMD_SpatialRepresentation): self.AbstractMD_SpatialRepresentation = AbstractMD_SpatialRepresentation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_SpatialRepresentation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_SpatialRepresentation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_SpatialRepresentation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_SpatialRepresentation_PropertyType', fromsubclass_=False):
        if self.AbstractMD_SpatialRepresentation is not None:
            self.AbstractMD_SpatialRepresentation.export(outfile, level, namespace_, name_='AbstractMD_SpatialRepresentation')
    def hasContent_(self):
        if (
            self.AbstractMD_SpatialRepresentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_SpatialRepresentation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractMD_SpatialRepresentation is not None:
            showIndent(outfile, level)
            outfile.write('AbstractMD_SpatialRepresentation=model_.AbstractMD_SpatialRepresentation(\n')
            self.AbstractMD_SpatialRepresentation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractMD_SpatialRepresentation':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractMD_SpatialRepresentation> element')
            self.set_AbstractMD_SpatialRepresentation(obj_)
# end class MD_SpatialRepresentation_PropertyType


class MD_Georeferenceable_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Georeferenceable=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Georeferenceable = MD_Georeferenceable
    def factory(*args_, **kwargs_):
        if MD_Georeferenceable_PropertyType.subclass:
            return MD_Georeferenceable_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Georeferenceable_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Georeferenceable(self): return self.MD_Georeferenceable
    def set_MD_Georeferenceable(self, MD_Georeferenceable): self.MD_Georeferenceable = MD_Georeferenceable
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Georeferenceable_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Georeferenceable_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Georeferenceable_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Georeferenceable_PropertyType', fromsubclass_=False):
        if self.MD_Georeferenceable is not None:
            self.MD_Georeferenceable.export(outfile, level, namespace_, name_='MD_Georeferenceable', )
    def hasContent_(self):
        if (
            self.MD_Georeferenceable is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Georeferenceable_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Georeferenceable is not None:
            showIndent(outfile, level)
            outfile.write('MD_Georeferenceable=model_.MD_Georeferenceable(\n')
            self.MD_Georeferenceable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Georeferenceable':
            obj_ = MD_Georeferenceable_Type.factory()
            obj_.build(child_)
            self.set_MD_Georeferenceable(obj_)
# end class MD_Georeferenceable_PropertyType


class MD_Dimension_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Dimension=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Dimension = MD_Dimension
    def factory(*args_, **kwargs_):
        if MD_Dimension_PropertyType.subclass:
            return MD_Dimension_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Dimension_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Dimension(self): return self.MD_Dimension
    def set_MD_Dimension(self, MD_Dimension): self.MD_Dimension = MD_Dimension
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Dimension_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Dimension_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Dimension_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Dimension_PropertyType', fromsubclass_=False):
        if self.MD_Dimension is not None:
            self.MD_Dimension.export(outfile, level, namespace_, name_='MD_Dimension', )
    def hasContent_(self):
        if (
            self.MD_Dimension is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Dimension_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Dimension is not None:
            showIndent(outfile, level)
            outfile.write('MD_Dimension=model_.MD_Dimension(\n')
            self.MD_Dimension.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Dimension':
            obj_ = MD_Dimension_Type.factory()
            obj_.build(child_)
            self.set_MD_Dimension(obj_)
# end class MD_Dimension_PropertyType


class MD_Georectified_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Georectified=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Georectified = MD_Georectified
    def factory(*args_, **kwargs_):
        if MD_Georectified_PropertyType.subclass:
            return MD_Georectified_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Georectified_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Georectified(self): return self.MD_Georectified
    def set_MD_Georectified(self, MD_Georectified): self.MD_Georectified = MD_Georectified
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Georectified_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Georectified_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Georectified_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Georectified_PropertyType', fromsubclass_=False):
        if self.MD_Georectified is not None:
            self.MD_Georectified.export(outfile, level, namespace_, name_='MD_Georectified', )
    def hasContent_(self):
        if (
            self.MD_Georectified is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Georectified_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Georectified is not None:
            showIndent(outfile, level)
            outfile.write('MD_Georectified=model_.MD_Georectified(\n')
            self.MD_Georectified.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Georectified':
            obj_ = MD_Georectified_Type.factory()
            obj_.build(child_)
            self.set_MD_Georectified(obj_)
# end class MD_Georectified_PropertyType


class MD_GeometricObjects_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_GeometricObjects=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_GeometricObjects = MD_GeometricObjects
    def factory(*args_, **kwargs_):
        if MD_GeometricObjects_PropertyType.subclass:
            return MD_GeometricObjects_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_GeometricObjects_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_GeometricObjects(self): return self.MD_GeometricObjects
    def set_MD_GeometricObjects(self, MD_GeometricObjects): self.MD_GeometricObjects = MD_GeometricObjects
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_GeometricObjects_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_GeometricObjects_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_GeometricObjects_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_GeometricObjects_PropertyType', fromsubclass_=False):
        if self.MD_GeometricObjects is not None:
            self.MD_GeometricObjects.export(outfile, level, namespace_, name_='MD_GeometricObjects', )
    def hasContent_(self):
        if (
            self.MD_GeometricObjects is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_GeometricObjects_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_GeometricObjects is not None:
            showIndent(outfile, level)
            outfile.write('MD_GeometricObjects=model_.MD_GeometricObjects(\n')
            self.MD_GeometricObjects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_GeometricObjects':
            obj_ = MD_GeometricObjects_Type.factory()
            obj_.build(child_)
            self.set_MD_GeometricObjects(obj_)
# end class MD_GeometricObjects_PropertyType


class MD_PixelOrientationCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_PixelOrientationCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_PixelOrientationCode = MD_PixelOrientationCode
    def factory(*args_, **kwargs_):
        if MD_PixelOrientationCode_PropertyType.subclass:
            return MD_PixelOrientationCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_PixelOrientationCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_PixelOrientationCode(self): return self.MD_PixelOrientationCode
    def set_MD_PixelOrientationCode(self, MD_PixelOrientationCode): self.MD_PixelOrientationCode = MD_PixelOrientationCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_PixelOrientationCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_PixelOrientationCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_PixelOrientationCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_PixelOrientationCode_PropertyType', fromsubclass_=False):
        if self.MD_PixelOrientationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sMD_PixelOrientationCode>%s</%sMD_PixelOrientationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.MD_PixelOrientationCode).encode(ExternalEncoding), input_name='MD_PixelOrientationCode'), namespace_))
    def hasContent_(self):
        if (
            self.MD_PixelOrientationCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_PixelOrientationCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_PixelOrientationCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_PixelOrientationCode=%s,\n' % quote_python(self.MD_PixelOrientationCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_PixelOrientationCode':
            MD_PixelOrientationCode_ = child_.text
            MD_PixelOrientationCode_ = self.gds_validate_string(MD_PixelOrientationCode_, node, 'MD_PixelOrientationCode')
            self.MD_PixelOrientationCode = MD_PixelOrientationCode_
# end class MD_PixelOrientationCode_PropertyType


class MD_TopologyLevelCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_TopologyLevelCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_TopologyLevelCode = MD_TopologyLevelCode
    def factory(*args_, **kwargs_):
        if MD_TopologyLevelCode_PropertyType.subclass:
            return MD_TopologyLevelCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_TopologyLevelCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_TopologyLevelCode(self): return self.MD_TopologyLevelCode
    def set_MD_TopologyLevelCode(self, MD_TopologyLevelCode): self.MD_TopologyLevelCode = MD_TopologyLevelCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_TopologyLevelCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_TopologyLevelCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_TopologyLevelCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_TopologyLevelCode_PropertyType', fromsubclass_=False):
        if self.MD_TopologyLevelCode is not None:
            self.MD_TopologyLevelCode.export(outfile, level, namespace_, name_='MD_TopologyLevelCode', )
    def hasContent_(self):
        if (
            self.MD_TopologyLevelCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_TopologyLevelCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_TopologyLevelCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_TopologyLevelCode=model_.MD_TopologyLevelCode(\n')
            self.MD_TopologyLevelCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_TopologyLevelCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_TopologyLevelCode(obj_)
# end class MD_TopologyLevelCode_PropertyType


class MD_GeometricObjectTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_GeometricObjectTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_GeometricObjectTypeCode = MD_GeometricObjectTypeCode
    def factory(*args_, **kwargs_):
        if MD_GeometricObjectTypeCode_PropertyType.subclass:
            return MD_GeometricObjectTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_GeometricObjectTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_GeometricObjectTypeCode(self): return self.MD_GeometricObjectTypeCode
    def set_MD_GeometricObjectTypeCode(self, MD_GeometricObjectTypeCode): self.MD_GeometricObjectTypeCode = MD_GeometricObjectTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_GeometricObjectTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_GeometricObjectTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_GeometricObjectTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_GeometricObjectTypeCode_PropertyType', fromsubclass_=False):
        if self.MD_GeometricObjectTypeCode is not None:
            self.MD_GeometricObjectTypeCode.export(outfile, level, namespace_, name_='MD_GeometricObjectTypeCode', )
    def hasContent_(self):
        if (
            self.MD_GeometricObjectTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_GeometricObjectTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_GeometricObjectTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_GeometricObjectTypeCode=model_.MD_GeometricObjectTypeCode(\n')
            self.MD_GeometricObjectTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_GeometricObjectTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_GeometricObjectTypeCode(obj_)
# end class MD_GeometricObjectTypeCode_PropertyType


class MD_CellGeometryCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_CellGeometryCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_CellGeometryCode = MD_CellGeometryCode
    def factory(*args_, **kwargs_):
        if MD_CellGeometryCode_PropertyType.subclass:
            return MD_CellGeometryCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_CellGeometryCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_CellGeometryCode(self): return self.MD_CellGeometryCode
    def set_MD_CellGeometryCode(self, MD_CellGeometryCode): self.MD_CellGeometryCode = MD_CellGeometryCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_CellGeometryCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_CellGeometryCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_CellGeometryCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_CellGeometryCode_PropertyType', fromsubclass_=False):
        if self.MD_CellGeometryCode is not None:
            self.MD_CellGeometryCode.export(outfile, level, namespace_, name_='MD_CellGeometryCode', )
    def hasContent_(self):
        if (
            self.MD_CellGeometryCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_CellGeometryCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_CellGeometryCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_CellGeometryCode=model_.MD_CellGeometryCode(\n')
            self.MD_CellGeometryCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_CellGeometryCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_CellGeometryCode(obj_)
# end class MD_CellGeometryCode_PropertyType


class MD_DimensionNameTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_DimensionNameTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_DimensionNameTypeCode = MD_DimensionNameTypeCode
    def factory(*args_, **kwargs_):
        if MD_DimensionNameTypeCode_PropertyType.subclass:
            return MD_DimensionNameTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_DimensionNameTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_DimensionNameTypeCode(self): return self.MD_DimensionNameTypeCode
    def set_MD_DimensionNameTypeCode(self, MD_DimensionNameTypeCode): self.MD_DimensionNameTypeCode = MD_DimensionNameTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_DimensionNameTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DimensionNameTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_DimensionNameTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_DimensionNameTypeCode_PropertyType', fromsubclass_=False):
        if self.MD_DimensionNameTypeCode is not None:
            self.MD_DimensionNameTypeCode.export(outfile, level, namespace_, name_='MD_DimensionNameTypeCode', )
    def hasContent_(self):
        if (
            self.MD_DimensionNameTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_DimensionNameTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_DimensionNameTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_DimensionNameTypeCode=model_.MD_DimensionNameTypeCode(\n')
            self.MD_DimensionNameTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_DimensionNameTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_DimensionNameTypeCode(obj_)
# end class MD_DimensionNameTypeCode_PropertyType


class CI_ResponsibleParty_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_ResponsibleParty=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_ResponsibleParty = CI_ResponsibleParty
    def factory(*args_, **kwargs_):
        if CI_ResponsibleParty_PropertyType.subclass:
            return CI_ResponsibleParty_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_ResponsibleParty_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_ResponsibleParty(self): return self.CI_ResponsibleParty
    def set_CI_ResponsibleParty(self, CI_ResponsibleParty): self.CI_ResponsibleParty = CI_ResponsibleParty
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_ResponsibleParty_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_ResponsibleParty_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_ResponsibleParty_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_ResponsibleParty_PropertyType', fromsubclass_=False):
        if self.CI_ResponsibleParty is not None:
            self.CI_ResponsibleParty.export(outfile, level, namespace_, name_='CI_ResponsibleParty', )
    def hasContent_(self):
        if (
            self.CI_ResponsibleParty is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_ResponsibleParty_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_ResponsibleParty is not None:
            showIndent(outfile, level)
            outfile.write('CI_ResponsibleParty=model_.CI_ResponsibleParty(\n')
            self.CI_ResponsibleParty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_ResponsibleParty':
            obj_ = CI_ResponsibleParty_Type.factory()
            obj_.build(child_)
            self.set_CI_ResponsibleParty(obj_)
# end class CI_ResponsibleParty_PropertyType


class CI_Citation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_Citation=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_Citation = CI_Citation
    def factory(*args_, **kwargs_):
        if CI_Citation_PropertyType.subclass:
            return CI_Citation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Citation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Citation(self): return self.CI_Citation
    def set_CI_Citation(self, CI_Citation): self.CI_Citation = CI_Citation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_Citation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Citation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Citation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Citation_PropertyType', fromsubclass_=False):
        if self.CI_Citation is not None:
            self.CI_Citation.export(outfile, level, namespace_, name_='CI_Citation', )
    def hasContent_(self):
        if (
            self.CI_Citation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Citation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_Citation is not None:
            showIndent(outfile, level)
            outfile.write('CI_Citation=model_.CI_Citation(\n')
            self.CI_Citation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Citation':
            obj_ = CI_Citation_Type.factory()
            obj_.build(child_)
            self.set_CI_Citation(obj_)
# end class CI_Citation_PropertyType


class CI_Address_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_Address=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_Address = CI_Address
    def factory(*args_, **kwargs_):
        if CI_Address_PropertyType.subclass:
            return CI_Address_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Address_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Address(self): return self.CI_Address
    def set_CI_Address(self, CI_Address): self.CI_Address = CI_Address
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_Address_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Address_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Address_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Address_PropertyType', fromsubclass_=False):
        if self.CI_Address is not None:
            self.CI_Address.export(outfile, level, namespace_, name_='CI_Address', )
    def hasContent_(self):
        if (
            self.CI_Address is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Address_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_Address is not None:
            showIndent(outfile, level)
            outfile.write('CI_Address=model_.CI_Address(\n')
            self.CI_Address.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Address':
            obj_ = CI_Address_Type.factory()
            obj_.build(child_)
            self.set_CI_Address(obj_)
# end class CI_Address_PropertyType


class CI_OnlineResource_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_OnlineResource=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_OnlineResource = CI_OnlineResource
    def factory(*args_, **kwargs_):
        if CI_OnlineResource_PropertyType.subclass:
            return CI_OnlineResource_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_OnlineResource_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_OnlineResource(self): return self.CI_OnlineResource
    def set_CI_OnlineResource(self, CI_OnlineResource): self.CI_OnlineResource = CI_OnlineResource
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_OnlineResource_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnlineResource_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_OnlineResource_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_OnlineResource_PropertyType', fromsubclass_=False):
        if self.CI_OnlineResource is not None:
            self.CI_OnlineResource.export(outfile, level, namespace_, name_='CI_OnlineResource', )
    def hasContent_(self):
        if (
            self.CI_OnlineResource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_OnlineResource_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_OnlineResource is not None:
            showIndent(outfile, level)
            outfile.write('CI_OnlineResource=model_.CI_OnlineResource(\n')
            self.CI_OnlineResource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_OnlineResource':
            obj_ = CI_OnlineResource_Type.factory()
            obj_.build(child_)
            self.set_CI_OnlineResource(obj_)
# end class CI_OnlineResource_PropertyType


class CI_Contact_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_Contact=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_Contact = CI_Contact
    def factory(*args_, **kwargs_):
        if CI_Contact_PropertyType.subclass:
            return CI_Contact_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Contact_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Contact(self): return self.CI_Contact
    def set_CI_Contact(self, CI_Contact): self.CI_Contact = CI_Contact
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_Contact_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Contact_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Contact_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Contact_PropertyType', fromsubclass_=False):
        if self.CI_Contact is not None:
            self.CI_Contact.export(outfile, level, namespace_, name_='CI_Contact', )
    def hasContent_(self):
        if (
            self.CI_Contact is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Contact_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_Contact is not None:
            showIndent(outfile, level)
            outfile.write('CI_Contact=model_.CI_Contact(\n')
            self.CI_Contact.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Contact':
            obj_ = CI_Contact_Type.factory()
            obj_.build(child_)
            self.set_CI_Contact(obj_)
# end class CI_Contact_PropertyType


class CI_Telephone_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_Telephone=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_Telephone = CI_Telephone
    def factory(*args_, **kwargs_):
        if CI_Telephone_PropertyType.subclass:
            return CI_Telephone_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Telephone_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Telephone(self): return self.CI_Telephone
    def set_CI_Telephone(self, CI_Telephone): self.CI_Telephone = CI_Telephone
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_Telephone_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Telephone_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Telephone_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Telephone_PropertyType', fromsubclass_=False):
        if self.CI_Telephone is not None:
            self.CI_Telephone.export(outfile, level, namespace_, name_='CI_Telephone', )
    def hasContent_(self):
        if (
            self.CI_Telephone is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Telephone_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_Telephone is not None:
            showIndent(outfile, level)
            outfile.write('CI_Telephone=model_.CI_Telephone(\n')
            self.CI_Telephone.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Telephone':
            obj_ = CI_Telephone_Type.factory()
            obj_.build(child_)
            self.set_CI_Telephone(obj_)
# end class CI_Telephone_PropertyType


class CI_Date_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_Date=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_Date = CI_Date
    def factory(*args_, **kwargs_):
        if CI_Date_PropertyType.subclass:
            return CI_Date_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Date_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Date(self): return self.CI_Date
    def set_CI_Date(self, CI_Date): self.CI_Date = CI_Date
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_Date_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Date_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Date_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Date_PropertyType', fromsubclass_=False):
        if self.CI_Date is not None:
            self.CI_Date.export(outfile, level, namespace_, name_='CI_Date', )
    def hasContent_(self):
        if (
            self.CI_Date is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Date_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_Date is not None:
            showIndent(outfile, level)
            outfile.write('CI_Date=model_.CI_Date(\n')
            self.CI_Date.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Date':
            obj_ = CI_Date_Type.factory()
            obj_.build(child_)
            self.set_CI_Date(obj_)
# end class CI_Date_PropertyType


class CI_Series_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_Series=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_Series = CI_Series
    def factory(*args_, **kwargs_):
        if CI_Series_PropertyType.subclass:
            return CI_Series_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_Series_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Series(self): return self.CI_Series
    def set_CI_Series(self, CI_Series): self.CI_Series = CI_Series
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_Series_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Series_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Series_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Series_PropertyType', fromsubclass_=False):
        if self.CI_Series is not None:
            self.CI_Series.export(outfile, level, namespace_, name_='CI_Series', )
    def hasContent_(self):
        if (
            self.CI_Series is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Series_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_Series is not None:
            showIndent(outfile, level)
            outfile.write('CI_Series=model_.CI_Series(\n')
            self.CI_Series.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Series':
            obj_ = CI_Series_Type.factory()
            obj_.build(child_)
            self.set_CI_Series(obj_)
# end class CI_Series_PropertyType


class URL_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, URL=None):
        self.nilReason = _cast(None, nilReason)
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URL_PropertyType.subclass:
            return URL_PropertyType.subclass(*args_, **kwargs_)
        else:
            return URL_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='URL_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='URL_PropertyType', fromsubclass_=False):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('<%sURL>%s</%sURL>\n' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_))
    def hasContent_(self):
        if (
            self.URL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='URL_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_PropertyType


class CI_RoleCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_RoleCode=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_RoleCode = CI_RoleCode
    def factory(*args_, **kwargs_):
        if CI_RoleCode_PropertyType.subclass:
            return CI_RoleCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_RoleCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_RoleCode(self): return self.CI_RoleCode
    def set_CI_RoleCode(self, CI_RoleCode): self.CI_RoleCode = CI_RoleCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_RoleCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_RoleCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_RoleCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_RoleCode_PropertyType', fromsubclass_=False):
        if self.CI_RoleCode is not None:
            self.CI_RoleCode.export(outfile, level, namespace_, name_='CI_RoleCode', )
    def hasContent_(self):
        if (
            self.CI_RoleCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_RoleCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_RoleCode is not None:
            showIndent(outfile, level)
            outfile.write('CI_RoleCode=model_.CI_RoleCode(\n')
            self.CI_RoleCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_RoleCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_CI_RoleCode(obj_)
# end class CI_RoleCode_PropertyType


class CI_PresentationFormCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_PresentationFormCode=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_PresentationFormCode = CI_PresentationFormCode
    def factory(*args_, **kwargs_):
        if CI_PresentationFormCode_PropertyType.subclass:
            return CI_PresentationFormCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_PresentationFormCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_PresentationFormCode(self): return self.CI_PresentationFormCode
    def set_CI_PresentationFormCode(self, CI_PresentationFormCode): self.CI_PresentationFormCode = CI_PresentationFormCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_PresentationFormCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_PresentationFormCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_PresentationFormCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_PresentationFormCode_PropertyType', fromsubclass_=False):
        if self.CI_PresentationFormCode is not None:
            self.CI_PresentationFormCode.export(outfile, level, namespace_, name_='CI_PresentationFormCode', )
    def hasContent_(self):
        if (
            self.CI_PresentationFormCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_PresentationFormCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_PresentationFormCode is not None:
            showIndent(outfile, level)
            outfile.write('CI_PresentationFormCode=model_.CI_PresentationFormCode(\n')
            self.CI_PresentationFormCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_PresentationFormCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_CI_PresentationFormCode(obj_)
# end class CI_PresentationFormCode_PropertyType


class CI_OnLineFunctionCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_OnLineFunctionCode=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_OnLineFunctionCode = CI_OnLineFunctionCode
    def factory(*args_, **kwargs_):
        if CI_OnLineFunctionCode_PropertyType.subclass:
            return CI_OnLineFunctionCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_OnLineFunctionCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_OnLineFunctionCode(self): return self.CI_OnLineFunctionCode
    def set_CI_OnLineFunctionCode(self, CI_OnLineFunctionCode): self.CI_OnLineFunctionCode = CI_OnLineFunctionCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_OnLineFunctionCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnLineFunctionCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_OnLineFunctionCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_OnLineFunctionCode_PropertyType', fromsubclass_=False):
        if self.CI_OnLineFunctionCode is not None:
            self.CI_OnLineFunctionCode.export(outfile, level, namespace_, name_='CI_OnLineFunctionCode', )
    def hasContent_(self):
        if (
            self.CI_OnLineFunctionCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_OnLineFunctionCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_OnLineFunctionCode is not None:
            showIndent(outfile, level)
            outfile.write('CI_OnLineFunctionCode=model_.CI_OnLineFunctionCode(\n')
            self.CI_OnLineFunctionCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_OnLineFunctionCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_CI_OnLineFunctionCode(obj_)
# end class CI_OnLineFunctionCode_PropertyType


class CI_DateTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CI_DateTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.CI_DateTypeCode = CI_DateTypeCode
    def factory(*args_, **kwargs_):
        if CI_DateTypeCode_PropertyType.subclass:
            return CI_DateTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CI_DateTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_DateTypeCode(self): return self.CI_DateTypeCode
    def set_CI_DateTypeCode(self, CI_DateTypeCode): self.CI_DateTypeCode = CI_DateTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='CI_DateTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_DateTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_DateTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CI_DateTypeCode_PropertyType', fromsubclass_=False):
        if self.CI_DateTypeCode is not None:
            self.CI_DateTypeCode.export(outfile, level, namespace_, name_='CI_DateTypeCode', )
    def hasContent_(self):
        if (
            self.CI_DateTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_DateTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_DateTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('CI_DateTypeCode=model_.CI_DateTypeCode(\n')
            self.CI_DateTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_DateTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_CI_DateTypeCode(obj_)
# end class CI_DateTypeCode_PropertyType


class RS_Identifier_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, RS_Identifier=None):
        self.nilReason = _cast(None, nilReason)
        self.RS_Identifier = RS_Identifier
    def factory(*args_, **kwargs_):
        if RS_Identifier_PropertyType.subclass:
            return RS_Identifier_PropertyType.subclass(*args_, **kwargs_)
        else:
            return RS_Identifier_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RS_Identifier(self): return self.RS_Identifier
    def set_RS_Identifier(self, RS_Identifier): self.RS_Identifier = RS_Identifier
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='RS_Identifier_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RS_Identifier_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RS_Identifier_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RS_Identifier_PropertyType', fromsubclass_=False):
        if self.RS_Identifier is not None:
            self.RS_Identifier.export(outfile, level, namespace_, name_='RS_Identifier', )
    def hasContent_(self):
        if (
            self.RS_Identifier is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RS_Identifier_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RS_Identifier is not None:
            showIndent(outfile, level)
            outfile.write('RS_Identifier=model_.RS_Identifier(\n')
            self.RS_Identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RS_Identifier':
            obj_ = RS_Identifier_Type.factory()
            obj_.build(child_)
            self.set_RS_Identifier(obj_)
# end class RS_Identifier_PropertyType


class MD_ReferenceSystem_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ReferenceSystem=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ReferenceSystem = MD_ReferenceSystem
    def factory(*args_, **kwargs_):
        if MD_ReferenceSystem_PropertyType.subclass:
            return MD_ReferenceSystem_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ReferenceSystem_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ReferenceSystem(self): return self.MD_ReferenceSystem
    def set_MD_ReferenceSystem(self, MD_ReferenceSystem): self.MD_ReferenceSystem = MD_ReferenceSystem
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ReferenceSystem_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ReferenceSystem_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ReferenceSystem_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ReferenceSystem_PropertyType', fromsubclass_=False):
        if self.MD_ReferenceSystem is not None:
            self.MD_ReferenceSystem.export(outfile, level, namespace_, name_='MD_ReferenceSystem', )
    def hasContent_(self):
        if (
            self.MD_ReferenceSystem is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ReferenceSystem_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ReferenceSystem is not None:
            showIndent(outfile, level)
            outfile.write('MD_ReferenceSystem=model_.MD_ReferenceSystem(\n')
            self.MD_ReferenceSystem.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ReferenceSystem':
            obj_ = MD_ReferenceSystem_Type.factory()
            obj_.build(child_)
            self.set_MD_ReferenceSystem(obj_)
# end class MD_ReferenceSystem_PropertyType


class MD_Identifier_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Identifier=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Identifier = MD_Identifier
    def factory(*args_, **kwargs_):
        if MD_Identifier_PropertyType.subclass:
            return MD_Identifier_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Identifier_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Identifier(self): return self.MD_Identifier
    def set_MD_Identifier(self, MD_Identifier): self.MD_Identifier = MD_Identifier
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Identifier_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Identifier_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Identifier_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Identifier_PropertyType', fromsubclass_=False):
        if self.MD_Identifier is not None:
            self.MD_Identifier.export(outfile, level, namespace_, name_='MD_Identifier', )
    def hasContent_(self):
        if (
            self.MD_Identifier is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Identifier_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Identifier is not None:
            showIndent(outfile, level)
            outfile.write('MD_Identifier=model_.MD_Identifier(\n')
            self.MD_Identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Identifier':
            class_obj_ = self.get_class_obj_(child_, MD_Identifier_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_MD_Identifier(obj_)
# end class MD_Identifier_PropertyType


class RS_ReferenceSystem_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractRS_ReferenceSystem=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractRS_ReferenceSystem = AbstractRS_ReferenceSystem
    def factory(*args_, **kwargs_):
        if RS_ReferenceSystem_PropertyType.subclass:
            return RS_ReferenceSystem_PropertyType.subclass(*args_, **kwargs_)
        else:
            return RS_ReferenceSystem_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractRS_ReferenceSystem(self): return self.AbstractRS_ReferenceSystem
    def set_AbstractRS_ReferenceSystem(self, AbstractRS_ReferenceSystem): self.AbstractRS_ReferenceSystem = AbstractRS_ReferenceSystem
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='RS_ReferenceSystem_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RS_ReferenceSystem_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RS_ReferenceSystem_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RS_ReferenceSystem_PropertyType', fromsubclass_=False):
        if self.AbstractRS_ReferenceSystem is not None:
            self.AbstractRS_ReferenceSystem.export(outfile, level, namespace_, name_='AbstractRS_ReferenceSystem')
    def hasContent_(self):
        if (
            self.AbstractRS_ReferenceSystem is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RS_ReferenceSystem_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractRS_ReferenceSystem is not None:
            showIndent(outfile, level)
            outfile.write('AbstractRS_ReferenceSystem=model_.AbstractRS_ReferenceSystem(\n')
            self.AbstractRS_ReferenceSystem.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractRS_ReferenceSystem':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractRS_ReferenceSystem> element')
            self.set_AbstractRS_ReferenceSystem(obj_)
# end class RS_ReferenceSystem_PropertyType


class EX_TemporalExtent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, EX_TemporalExtent=None):
        self.nilReason = _cast(None, nilReason)
        self.EX_TemporalExtent = EX_TemporalExtent
    def factory(*args_, **kwargs_):
        if EX_TemporalExtent_PropertyType.subclass:
            return EX_TemporalExtent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_TemporalExtent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_TemporalExtent(self): return self.EX_TemporalExtent
    def set_EX_TemporalExtent(self, EX_TemporalExtent): self.EX_TemporalExtent = EX_TemporalExtent
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_TemporalExtent_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_TemporalExtent_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_TemporalExtent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_TemporalExtent_PropertyType', fromsubclass_=False):
        if self.EX_TemporalExtent is not None:
            self.EX_TemporalExtent.export(outfile, level, namespace_, name_='EX_TemporalExtent', )
    def hasContent_(self):
        if (
            self.EX_TemporalExtent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_TemporalExtent_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_TemporalExtent is not None:
            showIndent(outfile, level)
            outfile.write('EX_TemporalExtent=model_.EX_TemporalExtent(\n')
            self.EX_TemporalExtent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_TemporalExtent':
            class_obj_ = self.get_class_obj_(child_, EX_TemporalExtent_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_EX_TemporalExtent(obj_)
# end class EX_TemporalExtent_PropertyType


class EX_VerticalExtent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, EX_VerticalExtent=None):
        self.nilReason = _cast(None, nilReason)
        self.EX_VerticalExtent = EX_VerticalExtent
    def factory(*args_, **kwargs_):
        if EX_VerticalExtent_PropertyType.subclass:
            return EX_VerticalExtent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_VerticalExtent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_VerticalExtent(self): return self.EX_VerticalExtent
    def set_EX_VerticalExtent(self, EX_VerticalExtent): self.EX_VerticalExtent = EX_VerticalExtent
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_VerticalExtent_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_VerticalExtent_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_VerticalExtent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_VerticalExtent_PropertyType', fromsubclass_=False):
        if self.EX_VerticalExtent is not None:
            self.EX_VerticalExtent.export(outfile, level, namespace_, name_='EX_VerticalExtent', )
    def hasContent_(self):
        if (
            self.EX_VerticalExtent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_VerticalExtent_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_VerticalExtent is not None:
            showIndent(outfile, level)
            outfile.write('EX_VerticalExtent=model_.EX_VerticalExtent(\n')
            self.EX_VerticalExtent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_VerticalExtent':
            obj_ = EX_VerticalExtent_Type.factory()
            obj_.build(child_)
            self.set_EX_VerticalExtent(obj_)
# end class EX_VerticalExtent_PropertyType


class EX_BoundingPolygon_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, EX_BoundingPolygon=None):
        self.nilReason = _cast(None, nilReason)
        self.EX_BoundingPolygon = EX_BoundingPolygon
    def factory(*args_, **kwargs_):
        if EX_BoundingPolygon_PropertyType.subclass:
            return EX_BoundingPolygon_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_BoundingPolygon_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_BoundingPolygon(self): return self.EX_BoundingPolygon
    def set_EX_BoundingPolygon(self, EX_BoundingPolygon): self.EX_BoundingPolygon = EX_BoundingPolygon
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_BoundingPolygon_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_BoundingPolygon_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_BoundingPolygon_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_BoundingPolygon_PropertyType', fromsubclass_=False):
        if self.EX_BoundingPolygon is not None:
            self.EX_BoundingPolygon.export(outfile, level, namespace_, name_='EX_BoundingPolygon', )
    def hasContent_(self):
        if (
            self.EX_BoundingPolygon is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_BoundingPolygon_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_BoundingPolygon is not None:
            showIndent(outfile, level)
            outfile.write('EX_BoundingPolygon=model_.EX_BoundingPolygon(\n')
            self.EX_BoundingPolygon.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_BoundingPolygon':
            obj_ = EX_BoundingPolygon_Type.factory()
            obj_.build(child_)
            self.set_EX_BoundingPolygon(obj_)
# end class EX_BoundingPolygon_PropertyType


class EX_Extent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, EX_Extent=None):
        self.nilReason = _cast(None, nilReason)
        self.EX_Extent = EX_Extent
    def factory(*args_, **kwargs_):
        if EX_Extent_PropertyType.subclass:
            return EX_Extent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_Extent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_Extent(self): return self.EX_Extent
    def set_EX_Extent(self, EX_Extent): self.EX_Extent = EX_Extent
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_Extent_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_Extent_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_Extent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_Extent_PropertyType', fromsubclass_=False):
        if self.EX_Extent is not None:
            self.EX_Extent.export(outfile, level, namespace_, name_='EX_Extent', )
    def hasContent_(self):
        if (
            self.EX_Extent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_Extent_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_Extent is not None:
            showIndent(outfile, level)
            outfile.write('EX_Extent=model_.EX_Extent(\n')
            self.EX_Extent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_Extent':
            obj_ = EX_Extent_Type.factory()
            obj_.build(child_)
            self.set_EX_Extent(obj_)
# end class EX_Extent_PropertyType


class EX_GeographicExtent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractEX_GeographicExtent=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractEX_GeographicExtent = AbstractEX_GeographicExtent
    def factory(*args_, **kwargs_):
        if EX_GeographicExtent_PropertyType.subclass:
            return EX_GeographicExtent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_GeographicExtent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractEX_GeographicExtent(self): return self.AbstractEX_GeographicExtent
    def set_AbstractEX_GeographicExtent(self, AbstractEX_GeographicExtent): self.AbstractEX_GeographicExtent = AbstractEX_GeographicExtent
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_GeographicExtent_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicExtent_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_GeographicExtent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_GeographicExtent_PropertyType', fromsubclass_=False):
        if self.AbstractEX_GeographicExtent is not None:
            self.AbstractEX_GeographicExtent.export(outfile, level, namespace_, name_='AbstractEX_GeographicExtent')
    def hasContent_(self):
        if (
            self.AbstractEX_GeographicExtent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_GeographicExtent_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractEX_GeographicExtent is not None:
            showIndent(outfile, level)
            outfile.write('AbstractEX_GeographicExtent=model_.AbstractEX_GeographicExtent(\n')
            self.AbstractEX_GeographicExtent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractEX_GeographicExtent':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractEX_GeographicExtent> element')
            self.set_AbstractEX_GeographicExtent(obj_)
# end class EX_GeographicExtent_PropertyType


class EX_GeographicBoundingBox_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, EX_GeographicBoundingBox=None):
        self.nilReason = _cast(None, nilReason)
        self.EX_GeographicBoundingBox = EX_GeographicBoundingBox
    def factory(*args_, **kwargs_):
        if EX_GeographicBoundingBox_PropertyType.subclass:
            return EX_GeographicBoundingBox_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_GeographicBoundingBox_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_GeographicBoundingBox(self): return self.EX_GeographicBoundingBox
    def set_EX_GeographicBoundingBox(self, EX_GeographicBoundingBox): self.EX_GeographicBoundingBox = EX_GeographicBoundingBox
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_GeographicBoundingBox_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicBoundingBox_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_GeographicBoundingBox_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_GeographicBoundingBox_PropertyType', fromsubclass_=False):
        if self.EX_GeographicBoundingBox is not None:
            self.EX_GeographicBoundingBox.export(outfile, level, namespace_, name_='EX_GeographicBoundingBox', )
    def hasContent_(self):
        if (
            self.EX_GeographicBoundingBox is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_GeographicBoundingBox_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_GeographicBoundingBox is not None:
            showIndent(outfile, level)
            outfile.write('EX_GeographicBoundingBox=model_.EX_GeographicBoundingBox(\n')
            self.EX_GeographicBoundingBox.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_GeographicBoundingBox':
            obj_ = EX_GeographicBoundingBox_Type.factory()
            obj_.build(child_)
            self.set_EX_GeographicBoundingBox(obj_)
# end class EX_GeographicBoundingBox_PropertyType


class EX_SpatialTemporalExtent_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, EX_SpatialTemporalExtent=None):
        self.nilReason = _cast(None, nilReason)
        self.EX_SpatialTemporalExtent = EX_SpatialTemporalExtent
    def factory(*args_, **kwargs_):
        if EX_SpatialTemporalExtent_PropertyType.subclass:
            return EX_SpatialTemporalExtent_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_SpatialTemporalExtent_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_SpatialTemporalExtent(self): return self.EX_SpatialTemporalExtent
    def set_EX_SpatialTemporalExtent(self, EX_SpatialTemporalExtent): self.EX_SpatialTemporalExtent = EX_SpatialTemporalExtent
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_SpatialTemporalExtent_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_SpatialTemporalExtent_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_SpatialTemporalExtent_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_SpatialTemporalExtent_PropertyType', fromsubclass_=False):
        if self.EX_SpatialTemporalExtent is not None:
            self.EX_SpatialTemporalExtent.export(outfile, level, namespace_, name_='EX_SpatialTemporalExtent', )
    def hasContent_(self):
        if (
            self.EX_SpatialTemporalExtent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_SpatialTemporalExtent_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_SpatialTemporalExtent is not None:
            showIndent(outfile, level)
            outfile.write('EX_SpatialTemporalExtent=model_.EX_SpatialTemporalExtent(\n')
            self.EX_SpatialTemporalExtent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_SpatialTemporalExtent':
            obj_ = EX_SpatialTemporalExtent_Type.factory()
            obj_.build(child_)
            self.set_EX_SpatialTemporalExtent(obj_)
# end class EX_SpatialTemporalExtent_PropertyType


class EX_GeographicDescription_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, EX_GeographicDescription=None):
        self.nilReason = _cast(None, nilReason)
        self.EX_GeographicDescription = EX_GeographicDescription
    def factory(*args_, **kwargs_):
        if EX_GeographicDescription_PropertyType.subclass:
            return EX_GeographicDescription_PropertyType.subclass(*args_, **kwargs_)
        else:
            return EX_GeographicDescription_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EX_GeographicDescription(self): return self.EX_GeographicDescription
    def set_EX_GeographicDescription(self, EX_GeographicDescription): self.EX_GeographicDescription = EX_GeographicDescription
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='EX_GeographicDescription_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicDescription_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_GeographicDescription_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EX_GeographicDescription_PropertyType', fromsubclass_=False):
        if self.EX_GeographicDescription is not None:
            self.EX_GeographicDescription.export(outfile, level, namespace_, name_='EX_GeographicDescription', )
    def hasContent_(self):
        if (
            self.EX_GeographicDescription is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_GeographicDescription_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EX_GeographicDescription is not None:
            showIndent(outfile, level)
            outfile.write('EX_GeographicDescription=model_.EX_GeographicDescription(\n')
            self.EX_GeographicDescription.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EX_GeographicDescription':
            obj_ = EX_GeographicDescription_Type.factory()
            obj_.build(child_)
            self.set_EX_GeographicDescription(obj_)
# end class EX_GeographicDescription_PropertyType


class GM_Point_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Point=None):
        self.nilReason = _cast(None, nilReason)
        self.Point = Point
    def factory(*args_, **kwargs_):
        if GM_Point_PropertyType.subclass:
            return GM_Point_PropertyType.subclass(*args_, **kwargs_)
        else:
            return GM_Point_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point(self): return self.Point
    def set_Point(self, Point): self.Point = Point
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='GM_Point_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GM_Point_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GM_Point_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GM_Point_PropertyType', fromsubclass_=False):
        if self.Point is not None:
            self.Point.export(outfile, level, namespace_, name_='Point', )
    def hasContent_(self):
        if (
            self.Point is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GM_Point_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Point is not None:
            showIndent(outfile, level)
            outfile.write('Point=model_.Point(\n')
            self.Point.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point':
            obj_ = PointType.factory()
            obj_.build(child_)
            self.set_Point(obj_)
# end class GM_Point_PropertyType


class GM_Object_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractGeometry=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractGeometry = AbstractGeometry
    def factory(*args_, **kwargs_):
        if GM_Object_PropertyType.subclass:
            return GM_Object_PropertyType.subclass(*args_, **kwargs_)
        else:
            return GM_Object_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='GM_Object_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GM_Object_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GM_Object_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GM_Object_PropertyType', fromsubclass_=False):
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
    def hasContent_(self):
        if (
            self.AbstractGeometry is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GM_Object_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
# end class GM_Object_PropertyType


class TypeName_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, TypeName=None):
        self.nilReason = _cast(None, nilReason)
        self.TypeName = TypeName
    def factory(*args_, **kwargs_):
        if TypeName_PropertyType.subclass:
            return TypeName_PropertyType.subclass(*args_, **kwargs_)
        else:
            return TypeName_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TypeName(self): return self.TypeName
    def set_TypeName(self, TypeName): self.TypeName = TypeName
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='TypeName_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeName_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TypeName_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TypeName_PropertyType', fromsubclass_=False):
        if self.TypeName is not None:
            self.TypeName.export(outfile, level, namespace_, name_='TypeName', )
    def hasContent_(self):
        if (
            self.TypeName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TypeName_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TypeName is not None:
            showIndent(outfile, level)
            outfile.write('TypeName=model_.TypeName(\n')
            self.TypeName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TypeName':
            obj_ = TypeName_Type.factory()
            obj_.build(child_)
            self.set_TypeName(obj_)
# end class TypeName_PropertyType


class MemberName_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MemberName=None):
        self.nilReason = _cast(None, nilReason)
        self.MemberName = MemberName
    def factory(*args_, **kwargs_):
        if MemberName_PropertyType.subclass:
            return MemberName_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MemberName_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MemberName(self): return self.MemberName
    def set_MemberName(self, MemberName): self.MemberName = MemberName
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MemberName_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemberName_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MemberName_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MemberName_PropertyType', fromsubclass_=False):
        if self.MemberName is not None:
            self.MemberName.export(outfile, level, namespace_, name_='MemberName', )
    def hasContent_(self):
        if (
            self.MemberName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MemberName_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MemberName is not None:
            showIndent(outfile, level)
            outfile.write('MemberName=model_.MemberName(\n')
            self.MemberName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MemberName':
            obj_ = MemberName_Type.factory()
            obj_.build(child_)
            self.set_MemberName(obj_)
# end class MemberName_PropertyType


class Multiplicity_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Multiplicity=None):
        self.nilReason = _cast(None, nilReason)
        self.Multiplicity = Multiplicity
    def factory(*args_, **kwargs_):
        if Multiplicity_PropertyType.subclass:
            return Multiplicity_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Multiplicity_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Multiplicity(self): return self.Multiplicity
    def set_Multiplicity(self, Multiplicity): self.Multiplicity = Multiplicity
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Multiplicity_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Multiplicity_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Multiplicity_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Multiplicity_PropertyType', fromsubclass_=False):
        if self.Multiplicity is not None:
            self.Multiplicity.export(outfile, level, namespace_, name_='Multiplicity', )
    def hasContent_(self):
        if (
            self.Multiplicity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Multiplicity_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Multiplicity is not None:
            showIndent(outfile, level)
            outfile.write('Multiplicity=model_.Multiplicity(\n')
            self.Multiplicity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Multiplicity':
            obj_ = Multiplicity_Type.factory()
            obj_.build(child_)
            self.set_Multiplicity(obj_)
# end class Multiplicity_PropertyType


class MultiplicityRange_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MultiplicityRange=None):
        self.nilReason = _cast(None, nilReason)
        self.MultiplicityRange = MultiplicityRange
    def factory(*args_, **kwargs_):
        if MultiplicityRange_PropertyType.subclass:
            return MultiplicityRange_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MultiplicityRange_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MultiplicityRange(self): return self.MultiplicityRange
    def set_MultiplicityRange(self, MultiplicityRange): self.MultiplicityRange = MultiplicityRange
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MultiplicityRange_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiplicityRange_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiplicityRange_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultiplicityRange_PropertyType', fromsubclass_=False):
        if self.MultiplicityRange is not None:
            self.MultiplicityRange.export(outfile, level, namespace_, name_='MultiplicityRange', )
    def hasContent_(self):
        if (
            self.MultiplicityRange is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiplicityRange_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MultiplicityRange is not None:
            showIndent(outfile, level)
            outfile.write('MultiplicityRange=model_.MultiplicityRange(\n')
            self.MultiplicityRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiplicityRange':
            obj_ = MultiplicityRange_Type.factory()
            obj_.build(child_)
            self.set_MultiplicityRange(obj_)
# end class MultiplicityRange_PropertyType


class Measure_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Measure=None):
        self.nilReason = _cast(None, nilReason)
        self.Measure = Measure
    def factory(*args_, **kwargs_):
        if Measure_PropertyType.subclass:
            return Measure_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Measure_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Measure(self): return self.Measure
    def set_Measure(self, Measure): self.Measure = Measure
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Measure_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Measure_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Measure_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Measure_PropertyType', fromsubclass_=False):
        if self.Measure is not None:
            self.Measure.export(outfile, level, namespace_, name_='Measure', )
    def hasContent_(self):
        if (
            self.Measure is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Measure_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Measure is not None:
            showIndent(outfile, level)
            outfile.write('Measure=model_.Measure(\n')
            self.Measure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measure':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Measure(obj_)
# end class Measure_PropertyType


class Length_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Length=None):
        self.nilReason = _cast(None, nilReason)
        self.Length = Length
    def factory(*args_, **kwargs_):
        if Length_PropertyType.subclass:
            return Length_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Length_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Length_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Length_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Length_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Length_PropertyType', fromsubclass_=False):
        if self.Length is not None:
            self.Length.export(outfile, level, namespace_, name_='Length', )
    def hasContent_(self):
        if (
            self.Length is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Length_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Length is not None:
            showIndent(outfile, level)
            outfile.write('Length=model_.Length(\n')
            self.Length.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Length':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.set_Length(obj_)
# end class Length_PropertyType


class Angle_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Angle=None):
        self.nilReason = _cast(None, nilReason)
        self.Angle = Angle
    def factory(*args_, **kwargs_):
        if Angle_PropertyType.subclass:
            return Angle_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Angle_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Angle(self): return self.Angle
    def set_Angle(self, Angle): self.Angle = Angle
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Angle_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Angle_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Angle_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Angle_PropertyType', fromsubclass_=False):
        if self.Angle is not None:
            self.Angle.export(outfile, level, namespace_, name_='Angle', )
    def hasContent_(self):
        if (
            self.Angle is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Angle_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Angle is not None:
            showIndent(outfile, level)
            outfile.write('Angle=model_.Angle(\n')
            self.Angle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Angle':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.set_Angle(obj_)
# end class Angle_PropertyType


class Scale_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Scale=None):
        self.nilReason = _cast(None, nilReason)
        self.Scale = Scale
    def factory(*args_, **kwargs_):
        if Scale_PropertyType.subclass:
            return Scale_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Scale_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Scale_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Scale_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Scale_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Scale_PropertyType', fromsubclass_=False):
        if self.Scale is not None:
            self.Scale.export(outfile, level, namespace_, name_='Scale', )
    def hasContent_(self):
        if (
            self.Scale is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Scale_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Scale is not None:
            showIndent(outfile, level)
            outfile.write('Scale=model_.Scale(\n')
            self.Scale.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Scale':
            obj_ = ScaleType.factory()
            obj_.build(child_)
            self.set_Scale(obj_)
# end class Scale_PropertyType


class Distance_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Distance=None):
        self.nilReason = _cast(None, nilReason)
        self.Distance = Distance
    def factory(*args_, **kwargs_):
        if Distance_PropertyType.subclass:
            return Distance_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Distance_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Distance(self): return self.Distance
    def set_Distance(self, Distance): self.Distance = Distance
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Distance_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Distance_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Distance_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Distance_PropertyType', fromsubclass_=False):
        if self.Distance is not None:
            self.Distance.export(outfile, level, namespace_, name_='Distance', )
    def hasContent_(self):
        if (
            self.Distance is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Distance_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Distance is not None:
            showIndent(outfile, level)
            outfile.write('Distance=model_.Distance(\n')
            self.Distance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Distance':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.set_Distance(obj_)
# end class Distance_PropertyType


class CharacterString_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, CharacterString=None, extensiontype_=None):
        self.nilReason = _cast(None, nilReason)
        self.CharacterString = CharacterString
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CharacterString_PropertyType.subclass:
            return CharacterString_PropertyType.subclass(*args_, **kwargs_)
        else:
            return CharacterString_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CharacterString(self): return self.CharacterString
    def set_CharacterString(self, CharacterString): self.CharacterString = CharacterString
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='CharacterString_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CharacterString_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CharacterString_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CharacterString_PropertyType', fromsubclass_=False):
        if self.CharacterString is not None:
            showIndent(outfile, level)
            outfile.write('<%sCharacterString>%s</%sCharacterString>\n' % (namespace_, self.gds_format_string(quote_xml(self.CharacterString).encode(ExternalEncoding), input_name='CharacterString'), namespace_))
    def hasContent_(self):
        if (
            self.CharacterString is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CharacterString_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CharacterString is not None:
            showIndent(outfile, level)
            outfile.write('CharacterString=%s,\n' % quote_python(self.CharacterString).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CharacterString':
            CharacterString_ = child_.text
            CharacterString_ = self.gds_validate_string(CharacterString_, node, 'CharacterString')
            self.CharacterString = CharacterString_
# end class CharacterString_PropertyType


class Boolean_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Boolean=None):
        self.nilReason = _cast(None, nilReason)
        self.Boolean = Boolean
    def factory(*args_, **kwargs_):
        if Boolean_PropertyType.subclass:
            return Boolean_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Boolean_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Boolean(self): return self.Boolean
    def set_Boolean(self, Boolean): self.Boolean = Boolean
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Boolean_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Boolean_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Boolean_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Boolean_PropertyType', fromsubclass_=False):
        if self.Boolean is not None:
            showIndent(outfile, level)
            outfile.write('<%sBoolean>%s</%sBoolean>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.Boolean)), input_name='Boolean'), namespace_))
    def hasContent_(self):
        if (
            self.Boolean is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Boolean_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Boolean is not None:
            showIndent(outfile, level)
            outfile.write('Boolean=%s,\n' % self.Boolean)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Boolean':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Boolean')
            self.Boolean = ival_
# end class Boolean_PropertyType


class GenericName_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractGenericName=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractGenericName = AbstractGenericName
    def factory(*args_, **kwargs_):
        if GenericName_PropertyType.subclass:
            return GenericName_PropertyType.subclass(*args_, **kwargs_)
        else:
            return GenericName_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGenericName(self): return self.AbstractGenericName
    def set_AbstractGenericName(self, AbstractGenericName): self.AbstractGenericName = AbstractGenericName
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='GenericName_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericName_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericName_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GenericName_PropertyType', fromsubclass_=False):
        if self.AbstractGenericName is not None:
            self.AbstractGenericName.export(outfile, level, namespace_, name_='AbstractGenericName')
    def hasContent_(self):
        if (
            self.AbstractGenericName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GenericName_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGenericName is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGenericName=model_.AbstractGenericName(\n')
            self.AbstractGenericName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGenericName':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGenericName> element')
            self.set_AbstractGenericName(obj_)
# end class GenericName_PropertyType


class LocalName_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, LocalName=None):
        self.nilReason = _cast(None, nilReason)
        self.LocalName = LocalName
    def factory(*args_, **kwargs_):
        if LocalName_PropertyType.subclass:
            return LocalName_PropertyType.subclass(*args_, **kwargs_)
        else:
            return LocalName_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalName(self): return self.LocalName
    def set_LocalName(self, LocalName): self.LocalName = LocalName
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='LocalName_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalName_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalName_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LocalName_PropertyType', fromsubclass_=False):
        if self.LocalName is not None:
            self.LocalName.export(outfile, level, namespace_, name_='LocalName', )
    def hasContent_(self):
        if (
            self.LocalName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalName_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LocalName is not None:
            showIndent(outfile, level)
            outfile.write('LocalName=model_.LocalName(\n')
            self.LocalName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalName':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_LocalName(obj_)
# end class LocalName_PropertyType


class ScopedName_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, ScopedName=None):
        self.nilReason = _cast(None, nilReason)
        self.ScopedName = ScopedName
    def factory(*args_, **kwargs_):
        if ScopedName_PropertyType.subclass:
            return ScopedName_PropertyType.subclass(*args_, **kwargs_)
        else:
            return ScopedName_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ScopedName(self): return self.ScopedName
    def set_ScopedName(self, ScopedName): self.ScopedName = ScopedName
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='ScopedName_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScopedName_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScopedName_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ScopedName_PropertyType', fromsubclass_=False):
        if self.ScopedName is not None:
            self.ScopedName.export(outfile, level, namespace_, name_='ScopedName', )
    def hasContent_(self):
        if (
            self.ScopedName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScopedName_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ScopedName is not None:
            showIndent(outfile, level)
            outfile.write('ScopedName=model_.ScopedName(\n')
            self.ScopedName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ScopedName':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_ScopedName(obj_)
# end class ScopedName_PropertyType


class UomAngle_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UomAngle_PropertyType.subclass:
            return UomAngle_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UomAngle_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UomAngle_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomAngle_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomAngle_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UomAngle_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UomAngle_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UomAngle_PropertyType


class UomLength_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UomLength_PropertyType.subclass:
            return UomLength_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UomLength_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UomLength_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomLength_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomLength_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UomLength_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UomLength_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UomLength_PropertyType


class UomScale_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UomScale_PropertyType.subclass:
            return UomScale_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UomScale_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UomScale_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomScale_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomScale_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UomScale_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UomScale_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UomScale_PropertyType


class UnitOfMeasure_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UnitOfMeasure_PropertyType.subclass:
            return UnitOfMeasure_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UnitOfMeasure_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UnitOfMeasure_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitOfMeasure_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitOfMeasure_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnitOfMeasure_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnitOfMeasure_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UnitOfMeasure_PropertyType


class UomArea_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UomArea_PropertyType.subclass:
            return UomArea_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UomArea_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UomArea_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomArea_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomArea_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UomArea_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UomArea_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UomArea_PropertyType


class UomVelocity_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UomVelocity_PropertyType.subclass:
            return UomVelocity_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UomVelocity_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UomVelocity_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomVelocity_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomVelocity_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UomVelocity_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UomVelocity_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UomVelocity_PropertyType


class UomTime_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UomTime_PropertyType.subclass:
            return UomTime_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UomTime_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UomTime_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomTime_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomTime_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UomTime_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UomTime_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UomTime_PropertyType


class UomVolume_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnitDefinition=None):
        self.nilReason = _cast(None, nilReason)
        self.UnitDefinition = UnitDefinition
    def factory(*args_, **kwargs_):
        if UomVolume_PropertyType.subclass:
            return UomVolume_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UomVolume_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitDefinition(self): return self.UnitDefinition
    def set_UnitDefinition(self, UnitDefinition): self.UnitDefinition = UnitDefinition
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UomVolume_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomVolume_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomVolume_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UomVolume_PropertyType', fromsubclass_=False):
        if self.UnitDefinition is not None:
            self.UnitDefinition.export(outfile, level, namespace_, name_='UnitDefinition', )
    def hasContent_(self):
        if (
            self.UnitDefinition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UomVolume_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitDefinition is not None:
            showIndent(outfile, level)
            outfile.write('UnitDefinition=model_.UnitDefinition(\n')
            self.UnitDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitDefinition':
            class_obj_ = self.get_class_obj_(child_, UnitDefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_UnitDefinition(obj_)
# end class UomVolume_PropertyType


class DateTime_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DateTime=None):
        self.nilReason = _cast(None, nilReason)
        self.DateTime = DateTime
    def factory(*args_, **kwargs_):
        if DateTime_PropertyType.subclass:
            return DateTime_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DateTime_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DateTime_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTime_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTime_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DateTime_PropertyType', fromsubclass_=False):
        if self.DateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sDateTime>%s</%sDateTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.DateTime).encode(ExternalEncoding), input_name='DateTime'), namespace_))
    def hasContent_(self):
        if (
            self.DateTime is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DateTime_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DateTime is not None:
            showIndent(outfile, level)
            outfile.write('DateTime=%s,\n' % quote_python(self.DateTime).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateTime':
            DateTime_ = child_.text
            DateTime_ = self.gds_validate_string(DateTime_, node, 'DateTime')
            self.DateTime = DateTime_
# end class DateTime_PropertyType


class Date_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Date=None, DateTime=None):
        self.nilReason = _cast(None, nilReason)
        self.Date = Date
        self.DateTime = DateTime
    def factory(*args_, **kwargs_):
        if Date_PropertyType.subclass:
            return Date_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Date_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Date_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Date_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Date_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Date_PropertyType', fromsubclass_=False):
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('<%sDate>%s</%sDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_))
        if self.DateTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sDateTime>%s</%sDateTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.DateTime).encode(ExternalEncoding), input_name='DateTime'), namespace_))
    def hasContent_(self):
        if (
            self.Date is not None or
            self.DateTime is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Date_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
        if self.DateTime is not None:
            showIndent(outfile, level)
            outfile.write('DateTime=%s,\n' % quote_python(self.DateTime).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'DateTime':
            DateTime_ = child_.text
            DateTime_ = self.gds_validate_string(DateTime_, node, 'DateTime')
            self.DateTime = DateTime_
# end class Date_PropertyType


class Number_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Real=None, Decimal=None, Integer=None):
        self.nilReason = _cast(None, nilReason)
        self.Real = Real
        self.Decimal = Decimal
        self.Integer = Integer
    def factory(*args_, **kwargs_):
        if Number_PropertyType.subclass:
            return Number_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Number_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Real(self): return self.Real
    def set_Real(self, Real): self.Real = Real
    def get_Decimal(self): return self.Decimal
    def set_Decimal(self, Decimal): self.Decimal = Decimal
    def get_Integer(self): return self.Integer
    def set_Integer(self, Integer): self.Integer = Integer
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Number_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Number_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Number_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Number_PropertyType', fromsubclass_=False):
        if self.Real is not None:
            showIndent(outfile, level)
            outfile.write('<%sReal>%s</%sReal>\n' % (namespace_, self.gds_format_double(self.Real, input_name='Real'), namespace_))
        if self.Decimal is not None:
            showIndent(outfile, level)
            outfile.write('<%sDecimal>%s</%sDecimal>\n' % (namespace_, self.gds_format_float(self.Decimal, input_name='Decimal'), namespace_))
        if self.Integer is not None:
            showIndent(outfile, level)
            outfile.write('<%sInteger>%s</%sInteger>\n' % (namespace_, self.gds_format_integer(self.Integer, input_name='Integer'), namespace_))
    def hasContent_(self):
        if (
            self.Real is not None or
            self.Decimal is not None or
            self.Integer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Number_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Real is not None:
            showIndent(outfile, level)
            outfile.write('Real=%e,\n' % self.Real)
        if self.Decimal is not None:
            showIndent(outfile, level)
            outfile.write('Decimal=%f,\n' % self.Decimal)
        if self.Integer is not None:
            showIndent(outfile, level)
            outfile.write('Integer=%d,\n' % self.Integer)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Real':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Real')
            self.Real = fval_
        elif nodeName_ == 'Decimal':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Decimal')
            self.Decimal = fval_
        elif nodeName_ == 'Integer':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Integer')
            self.Integer = ival_
# end class Number_PropertyType


class Decimal_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Decimal=None):
        self.nilReason = _cast(None, nilReason)
        self.Decimal = Decimal
    def factory(*args_, **kwargs_):
        if Decimal_PropertyType.subclass:
            return Decimal_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Decimal_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Decimal(self): return self.Decimal
    def set_Decimal(self, Decimal): self.Decimal = Decimal
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Decimal_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Decimal_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Decimal_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Decimal_PropertyType', fromsubclass_=False):
        if self.Decimal is not None:
            showIndent(outfile, level)
            outfile.write('<%sDecimal>%s</%sDecimal>\n' % (namespace_, self.gds_format_float(self.Decimal, input_name='Decimal'), namespace_))
    def hasContent_(self):
        if (
            self.Decimal is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Decimal_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Decimal is not None:
            showIndent(outfile, level)
            outfile.write('Decimal=%f,\n' % self.Decimal)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Decimal':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Decimal')
            self.Decimal = fval_
# end class Decimal_PropertyType


class Real_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Real=None):
        self.nilReason = _cast(None, nilReason)
        self.Real = Real
    def factory(*args_, **kwargs_):
        if Real_PropertyType.subclass:
            return Real_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Real_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Real(self): return self.Real
    def set_Real(self, Real): self.Real = Real
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Real_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Real_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Real_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Real_PropertyType', fromsubclass_=False):
        if self.Real is not None:
            showIndent(outfile, level)
            outfile.write('<%sReal>%s</%sReal>\n' % (namespace_, self.gds_format_double(self.Real, input_name='Real'), namespace_))
    def hasContent_(self):
        if (
            self.Real is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Real_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Real is not None:
            showIndent(outfile, level)
            outfile.write('Real=%e,\n' % self.Real)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Real':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Real')
            self.Real = fval_
# end class Real_PropertyType


class Integer_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Integer=None):
        self.nilReason = _cast(None, nilReason)
        self.Integer = Integer
    def factory(*args_, **kwargs_):
        if Integer_PropertyType.subclass:
            return Integer_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Integer_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Integer(self): return self.Integer
    def set_Integer(self, Integer): self.Integer = Integer
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Integer_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Integer_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Integer_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Integer_PropertyType', fromsubclass_=False):
        if self.Integer is not None:
            showIndent(outfile, level)
            outfile.write('<%sInteger>%s</%sInteger>\n' % (namespace_, self.gds_format_integer(self.Integer, input_name='Integer'), namespace_))
    def hasContent_(self):
        if (
            self.Integer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Integer_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Integer is not None:
            showIndent(outfile, level)
            outfile.write('Integer=%d,\n' % self.Integer)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Integer':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Integer')
            self.Integer = ival_
# end class Integer_PropertyType


class UnlimitedInteger_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, isInfinite=None, valueOf_=None):
        self.isInfinite = _cast(bool, isInfinite)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UnlimitedInteger_Type.subclass:
            return UnlimitedInteger_Type.subclass(*args_, **kwargs_)
        else:
            return UnlimitedInteger_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isInfinite(self): return self.isInfinite
    def set_isInfinite(self, isInfinite): self.isInfinite = isInfinite
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='UnlimitedInteger_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnlimitedInteger_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnlimitedInteger_Type'):
        if self.isInfinite is not None and 'isInfinite' not in already_processed:
            already_processed.append('isInfinite')
            outfile.write(' isInfinite="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.isInfinite)), input_name='isInfinite'))
    def exportChildren(self, outfile, level, namespace_='', name_='UnlimitedInteger_Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnlimitedInteger_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isInfinite is not None and 'isInfinite' not in already_processed:
            already_processed.append('isInfinite')
            showIndent(outfile, level)
            outfile.write('isInfinite = %s,\n' % (self.isInfinite,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isInfinite', node)
        if value is not None and 'isInfinite' not in already_processed:
            already_processed.append('isInfinite')
            if value in ('true', '1'):
                self.isInfinite = True
            elif value in ('false', '0'):
                self.isInfinite = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnlimitedInteger_Type


class UnlimitedInteger_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, UnlimitedInteger=None):
        self.nilReason = _cast(None, nilReason)
        self.UnlimitedInteger = UnlimitedInteger
    def factory(*args_, **kwargs_):
        if UnlimitedInteger_PropertyType.subclass:
            return UnlimitedInteger_PropertyType.subclass(*args_, **kwargs_)
        else:
            return UnlimitedInteger_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnlimitedInteger(self): return self.UnlimitedInteger
    def set_UnlimitedInteger(self, UnlimitedInteger): self.UnlimitedInteger = UnlimitedInteger
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='UnlimitedInteger_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnlimitedInteger_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnlimitedInteger_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnlimitedInteger_PropertyType', fromsubclass_=False):
        if self.UnlimitedInteger is not None:
            self.UnlimitedInteger.export(outfile, level, namespace_, name_='UnlimitedInteger', )
    def hasContent_(self):
        if (
            self.UnlimitedInteger is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnlimitedInteger_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnlimitedInteger is not None:
            showIndent(outfile, level)
            outfile.write('UnlimitedInteger=model_.UnlimitedInteger(\n')
            self.UnlimitedInteger.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnlimitedInteger':
            obj_ = UnlimitedInteger_Type.factory()
            obj_.build(child_)
            self.set_UnlimitedInteger(obj_)
# end class UnlimitedInteger_PropertyType


class Record(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Record.subclass:
            return Record.subclass(*args_, **kwargs_)
        else:
            return Record(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Record', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Record')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Record'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Record', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Record'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Record


class Record_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Record=None):
        self.nilReason = _cast(None, nilReason)
        self.Record = Record
    def factory(*args_, **kwargs_):
        if Record_PropertyType.subclass:
            return Record_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Record_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Record(self): return self.Record
    def set_Record(self, Record): self.Record = Record
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Record_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Record_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Record_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Record_PropertyType', fromsubclass_=False):
        if self.Record is not None:
            self.Record.export(outfile, level, namespace_, name_='Record', )
    def hasContent_(self):
        if (
            self.Record is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Record_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Record is not None:
            showIndent(outfile, level)
            outfile.write('Record=model_.Record(\n')
            self.Record.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Record':
            obj_ = Record.factory()
            obj_.build(child_)
            self.set_Record(obj_)
# end class Record_PropertyType


class RecordType_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, arcrole=None, actuate=None, href=None, role=None, show=None, type_=None, valueOf_=None):
        self.title = _cast(None, title)
        self.arcrole = _cast(None, arcrole)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.show = _cast(None, show)
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RecordType_Type.subclass:
            return RecordType_Type.subclass(*args_, **kwargs_)
        else:
            return RecordType_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='RecordType_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecordType_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RecordType_Type'):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RecordType_Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RecordType_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RecordType_Type


class RecordType_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, RecordType=None):
        self.nilReason = _cast(None, nilReason)
        self.RecordType = RecordType
    def factory(*args_, **kwargs_):
        if RecordType_PropertyType.subclass:
            return RecordType_PropertyType.subclass(*args_, **kwargs_)
        else:
            return RecordType_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RecordType(self): return self.RecordType
    def set_RecordType(self, RecordType): self.RecordType = RecordType
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='RecordType_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecordType_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RecordType_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RecordType_PropertyType', fromsubclass_=False):
        if self.RecordType is not None:
            self.RecordType.export(outfile, level, namespace_, name_='RecordType', )
    def hasContent_(self):
        if (
            self.RecordType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RecordType_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RecordType is not None:
            showIndent(outfile, level)
            outfile.write('RecordType=model_.RecordType(\n')
            self.RecordType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RecordType':
            obj_ = RecordType_Type.factory()
            obj_.build(child_)
            self.set_RecordType(obj_)
# end class RecordType_PropertyType


class Binary_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, valueOf_=None):
        self.src = _cast(None, src)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Binary_Type.subclass:
            return Binary_Type.subclass(*args_, **kwargs_)
        else:
            return Binary_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Binary_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Binary_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Binary_Type'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Binary_Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Binary_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('src', node)
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Binary_Type


class Binary_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Binary=None):
        self.nilReason = _cast(None, nilReason)
        self.Binary = Binary
    def factory(*args_, **kwargs_):
        if Binary_PropertyType.subclass:
            return Binary_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Binary_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Binary(self): return self.Binary
    def set_Binary(self, Binary): self.Binary = Binary
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Binary_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Binary_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Binary_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Binary_PropertyType', fromsubclass_=False):
        if self.Binary is not None:
            self.Binary.export(outfile, level, namespace_, name_='Binary', )
    def hasContent_(self):
        if (
            self.Binary is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Binary_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Binary is not None:
            showIndent(outfile, level)
            outfile.write('Binary=model_.Binary(\n')
            self.Binary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Binary':
            obj_ = Binary_Type.factory()
            obj_.build(child_)
            self.set_Binary(obj_)
# end class Binary_PropertyType


class AbstractObject_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, uuid=None, extensiontype_=None):
        self.id = _cast(None, id)
        self.uuid = _cast(None, uuid)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractObject_Type.subclass:
            return AbstractObject_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractObject_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractObject_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractObject_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractObject_Type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.append('uuid')
            outfile.write(' uuid=%s' % (self.gds_format_string(quote_attrib(self.uuid).encode(ExternalEncoding), input_name='uuid'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractObject_Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractObject_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.append('uuid')
            showIndent(outfile, level)
            outfile.write('uuid = "%s",\n' % (self.uuid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.append('uuid')
            self.uuid = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractObject_Type


class ObjectReference_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, extensiontype_=None):
        self.nilReason = _cast(None, nilReason)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObjectReference_PropertyType.subclass:
            return ObjectReference_PropertyType.subclass(*args_, **kwargs_)
        else:
            return ObjectReference_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ObjectReference_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectReference_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectReference_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectReference_PropertyType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectReference_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObjectReference_PropertyType


class CodeListValue_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codeList=None, codeSpace=None, codeListValue=None, valueOf_=None):
        self.codeList = _cast(None, codeList)
        self.codeSpace = _cast(None, codeSpace)
        self.codeListValue = _cast(None, codeListValue)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodeListValue_Type.subclass:
            return CodeListValue_Type.subclass(*args_, **kwargs_)
        else:
            return CodeListValue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeList(self): return self.codeList
    def set_codeList(self, codeList): self.codeList = codeList
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    def get_codeListValue(self): return self.codeListValue
    def set_codeListValue(self, codeListValue): self.codeListValue = codeListValue
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='CodeListValue_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeListValue_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeListValue_Type'):
        if self.codeList is not None and 'codeList' not in already_processed:
            already_processed.append('codeList')
            outfile.write(' codeList=%s' % (self.gds_format_string(quote_attrib(self.codeList).encode(ExternalEncoding), input_name='codeList'), ))
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            outfile.write(' codeSpace=%s' % (self.gds_format_string(quote_attrib(self.codeSpace).encode(ExternalEncoding), input_name='codeSpace'), ))
        if self.codeListValue is not None and 'codeListValue' not in already_processed:
            already_processed.append('codeListValue')
            outfile.write(' codeListValue=%s' % (self.gds_format_string(quote_attrib(self.codeListValue).encode(ExternalEncoding), input_name='codeListValue'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CodeListValue_Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CodeListValue_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codeList is not None and 'codeList' not in already_processed:
            already_processed.append('codeList')
            showIndent(outfile, level)
            outfile.write('codeList = "%s",\n' % (self.codeList,))
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            showIndent(outfile, level)
            outfile.write('codeSpace = "%s",\n' % (self.codeSpace,))
        if self.codeListValue is not None and 'codeListValue' not in already_processed:
            already_processed.append('codeListValue')
            showIndent(outfile, level)
            outfile.write('codeListValue = "%s",\n' % (self.codeListValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeList', node)
        if value is not None and 'codeList' not in already_processed:
            already_processed.append('codeList')
            self.codeList = value
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.append('codeSpace')
            self.codeSpace = value
        value = find_attr_value_('codeListValue', node)
        if value is not None and 'codeListValue' not in already_processed:
            already_processed.append('codeListValue')
            self.codeListValue = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeListValue_Type


class TM_Primitive_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractTimePrimitive=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractTimePrimitive = AbstractTimePrimitive
    def factory(*args_, **kwargs_):
        if TM_Primitive_PropertyType.subclass:
            return TM_Primitive_PropertyType.subclass(*args_, **kwargs_)
        else:
            return TM_Primitive_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTimePrimitive(self): return self.AbstractTimePrimitive
    def set_AbstractTimePrimitive(self, AbstractTimePrimitive): self.AbstractTimePrimitive = AbstractTimePrimitive
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='TM_Primitive_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TM_Primitive_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TM_Primitive_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TM_Primitive_PropertyType', fromsubclass_=False):
        if self.AbstractTimePrimitive is not None:
            self.AbstractTimePrimitive.export(outfile, level, namespace_, name_='AbstractTimePrimitive')
    def hasContent_(self):
        if (
            self.AbstractTimePrimitive is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TM_Primitive_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractTimePrimitive is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTimePrimitive=model_.AbstractTimePrimitive(\n')
            self.AbstractTimePrimitive.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTimePrimitive':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimePrimitive> element')
            self.set_AbstractTimePrimitive(obj_)
# end class TM_Primitive_PropertyType


class TM_PeriodDuration_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, TM_PeriodDuration=None):
        self.nilReason = _cast(None, nilReason)
        self.TM_PeriodDuration = TM_PeriodDuration
    def factory(*args_, **kwargs_):
        if TM_PeriodDuration_PropertyType.subclass:
            return TM_PeriodDuration_PropertyType.subclass(*args_, **kwargs_)
        else:
            return TM_PeriodDuration_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TM_PeriodDuration(self): return self.TM_PeriodDuration
    def set_TM_PeriodDuration(self, TM_PeriodDuration): self.TM_PeriodDuration = TM_PeriodDuration
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='TM_PeriodDuration_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TM_PeriodDuration_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TM_PeriodDuration_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TM_PeriodDuration_PropertyType', fromsubclass_=False):
        if self.TM_PeriodDuration is not None:
            showIndent(outfile, level)
            outfile.write('<%sTM_PeriodDuration>%s</%sTM_PeriodDuration>\n' % (namespace_, self.gds_format_string(quote_xml(self.TM_PeriodDuration).encode(ExternalEncoding), input_name='TM_PeriodDuration'), namespace_))
    def hasContent_(self):
        if (
            self.TM_PeriodDuration is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TM_PeriodDuration_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TM_PeriodDuration is not None:
            showIndent(outfile, level)
            outfile.write('TM_PeriodDuration=%s,\n' % quote_python(self.TM_PeriodDuration).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TM_PeriodDuration':
            TM_PeriodDuration_ = child_.text
            TM_PeriodDuration_ = self.gds_validate_string(TM_PeriodDuration_, node, 'TM_PeriodDuration')
            self.TM_PeriodDuration = TM_PeriodDuration_
# end class TM_PeriodDuration_PropertyType


class SC_CRS_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractCRS=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractCRS = AbstractCRS
    def factory(*args_, **kwargs_):
        if SC_CRS_PropertyType.subclass:
            return SC_CRS_PropertyType.subclass(*args_, **kwargs_)
        else:
            return SC_CRS_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCRS(self): return self.AbstractCRS
    def set_AbstractCRS(self, AbstractCRS): self.AbstractCRS = AbstractCRS
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='SC_CRS_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SC_CRS_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SC_CRS_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SC_CRS_PropertyType', fromsubclass_=False):
        if self.AbstractCRS is not None:
            self.AbstractCRS.export(outfile, level, namespace_, name_='AbstractCRS')
    def hasContent_(self):
        if (
            self.AbstractCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SC_CRS_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractCRS is not None:
            showIndent(outfile, level)
            outfile.write('AbstractCRS=model_.AbstractCRS(\n')
            self.AbstractCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCRS':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCRS> element')
            self.set_AbstractCRS(obj_)
# end class SC_CRS_PropertyType


class MD_ExtendedElementInformation_Type(AbstractObject_Type):
    """New metadata element, not found in ISO 19115, which is required to
    describe geographic data"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, name=None, shortName=None, domainCode=None, definition=None, obligation=None, condition=None, dataType=None, maximumOccurrence=None, domainValue=None, parentEntity=None, rule=None, rationale=None, source=None):
        super(MD_ExtendedElementInformation_Type, self).__init__(id, uuid, )
        self.name = name
        self.shortName = shortName
        self.domainCode = domainCode
        self.definition = definition
        self.obligation = obligation
        self.condition = condition
        self.dataType = dataType
        self.maximumOccurrence = maximumOccurrence
        self.domainValue = domainValue
        if parentEntity is None:
            self.parentEntity = []
        else:
            self.parentEntity = parentEntity
        self.rule = rule
        if rationale is None:
            self.rationale = []
        else:
            self.rationale = rationale
        if source is None:
            self.source = []
        else:
            self.source = source
    def factory(*args_, **kwargs_):
        if MD_ExtendedElementInformation_Type.subclass:
            return MD_ExtendedElementInformation_Type.subclass(*args_, **kwargs_)
        else:
            return MD_ExtendedElementInformation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def get_domainCode(self): return self.domainCode
    def set_domainCode(self, domainCode): self.domainCode = domainCode
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def get_obligation(self): return self.obligation
    def set_obligation(self, obligation): self.obligation = obligation
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_maximumOccurrence(self): return self.maximumOccurrence
    def set_maximumOccurrence(self, maximumOccurrence): self.maximumOccurrence = maximumOccurrence
    def get_domainValue(self): return self.domainValue
    def set_domainValue(self, domainValue): self.domainValue = domainValue
    def get_parentEntity(self): return self.parentEntity
    def set_parentEntity(self, parentEntity): self.parentEntity = parentEntity
    def add_parentEntity(self, value): self.parentEntity.append(value)
    def insert_parentEntity(self, index, value): self.parentEntity[index] = value
    def get_rule(self): return self.rule
    def set_rule(self, rule): self.rule = rule
    def get_rationale(self): return self.rationale
    def set_rationale(self, rationale): self.rationale = rationale
    def add_rationale(self, value): self.rationale.append(value)
    def insert_rationale(self, index, value): self.rationale[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def add_source(self, value): self.source.append(value)
    def insert_source(self, index, value): self.source[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_ExtendedElementInformation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ExtendedElementInformation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ExtendedElementInformation_Type'):
        super(MD_ExtendedElementInformation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ExtendedElementInformation_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ExtendedElementInformation_Type', fromsubclass_=False):
        super(MD_ExtendedElementInformation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', )
        if self.shortName is not None:
            self.shortName.export(outfile, level, namespace_, name_='shortName')
        if self.domainCode is not None:
            self.domainCode.export(outfile, level, namespace_, name_='domainCode')
        if self.definition is not None:
            self.definition.export(outfile, level, namespace_, name_='definition', )
        if self.obligation is not None:
            self.obligation.export(outfile, level, namespace_, name_='obligation')
        if self.condition is not None:
            self.condition.export(outfile, level, namespace_, name_='condition')
        if self.dataType is not None:
            self.dataType.export(outfile, level, namespace_, name_='dataType', )
        if self.maximumOccurrence is not None:
            self.maximumOccurrence.export(outfile, level, namespace_, name_='maximumOccurrence')
        if self.domainValue is not None:
            self.domainValue.export(outfile, level, namespace_, name_='domainValue')
        for parentEntity_ in self.parentEntity:
            parentEntity_.export(outfile, level, namespace_, name_='parentEntity')
        if self.rule is not None:
            self.rule.export(outfile, level, namespace_, name_='rule', )
        for rationale_ in self.rationale:
            rationale_.export(outfile, level, namespace_, name_='rationale')
        for source_ in self.source:
            source_.export(outfile, level, namespace_, name_='source')
    def hasContent_(self):
        if (
            self.name is not None or
            self.shortName is not None or
            self.domainCode is not None or
            self.definition is not None or
            self.obligation is not None or
            self.condition is not None or
            self.dataType is not None or
            self.maximumOccurrence is not None or
            self.domainValue is not None or
            self.parentEntity or
            self.rule is not None or
            self.rationale or
            self.source or
            super(MD_ExtendedElementInformation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ExtendedElementInformation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_ExtendedElementInformation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_ExtendedElementInformation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.CharacterString_PropertyType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.shortName is not None:
            showIndent(outfile, level)
            outfile.write('shortName=model_.CharacterString_PropertyType(\n')
            self.shortName.exportLiteral(outfile, level, name_='shortName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.domainCode is not None:
            showIndent(outfile, level)
            outfile.write('domainCode=model_.Integer_PropertyType(\n')
            self.domainCode.exportLiteral(outfile, level, name_='domainCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.definition is not None:
            showIndent(outfile, level)
            outfile.write('definition=model_.CharacterString_PropertyType(\n')
            self.definition.exportLiteral(outfile, level, name_='definition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.obligation is not None:
            showIndent(outfile, level)
            outfile.write('obligation=model_.MD_ObligationCode_PropertyType(\n')
            self.obligation.exportLiteral(outfile, level, name_='obligation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.condition is not None:
            showIndent(outfile, level)
            outfile.write('condition=model_.CharacterString_PropertyType(\n')
            self.condition.exportLiteral(outfile, level, name_='condition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataType is not None:
            showIndent(outfile, level)
            outfile.write('dataType=model_.MD_DatatypeCode_PropertyType(\n')
            self.dataType.exportLiteral(outfile, level, name_='dataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maximumOccurrence is not None:
            showIndent(outfile, level)
            outfile.write('maximumOccurrence=model_.CharacterString_PropertyType(\n')
            self.maximumOccurrence.exportLiteral(outfile, level, name_='maximumOccurrence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.domainValue is not None:
            showIndent(outfile, level)
            outfile.write('domainValue=model_.CharacterString_PropertyType(\n')
            self.domainValue.exportLiteral(outfile, level, name_='domainValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('parentEntity=[\n')
        level += 1
        for parentEntity_ in self.parentEntity:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            parentEntity_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.rule is not None:
            showIndent(outfile, level)
            outfile.write('rule=model_.CharacterString_PropertyType(\n')
            self.rule.exportLiteral(outfile, level, name_='rule')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('rationale=[\n')
        level += 1
        for rationale_ in self.rationale:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            rationale_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('source=[\n')
        level += 1
        for source_ in self.source:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            source_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_ExtendedElementInformation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'shortName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_shortName(obj_)
        elif nodeName_ == 'domainCode':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_domainCode(obj_)
        elif nodeName_ == 'definition':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_definition(obj_)
        elif nodeName_ == 'obligation':
            obj_ = MD_ObligationCode_PropertyType.factory()
            obj_.build(child_)
            self.set_obligation(obj_)
        elif nodeName_ == 'condition':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_condition(obj_)
        elif nodeName_ == 'dataType':
            obj_ = MD_DatatypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_dataType(obj_)
        elif nodeName_ == 'maximumOccurrence':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_maximumOccurrence(obj_)
        elif nodeName_ == 'domainValue':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_domainValue(obj_)
        elif nodeName_ == 'parentEntity':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.parentEntity.append(obj_)
        elif nodeName_ == 'rule':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_rule(obj_)
        elif nodeName_ == 'rationale':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.rationale.append(obj_)
        elif nodeName_ == 'source':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.source.append(obj_)
        super(MD_ExtendedElementInformation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_ExtendedElementInformation_Type


class MD_ExtendedElementInformation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ExtendedElementInformation=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ExtendedElementInformation = MD_ExtendedElementInformation
    def factory(*args_, **kwargs_):
        if MD_ExtendedElementInformation_PropertyType.subclass:
            return MD_ExtendedElementInformation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ExtendedElementInformation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ExtendedElementInformation(self): return self.MD_ExtendedElementInformation
    def set_MD_ExtendedElementInformation(self, MD_ExtendedElementInformation): self.MD_ExtendedElementInformation = MD_ExtendedElementInformation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ExtendedElementInformation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ExtendedElementInformation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ExtendedElementInformation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ExtendedElementInformation_PropertyType', fromsubclass_=False):
        if self.MD_ExtendedElementInformation is not None:
            self.MD_ExtendedElementInformation.export(outfile, level, namespace_, name_='MD_ExtendedElementInformation', )
    def hasContent_(self):
        if (
            self.MD_ExtendedElementInformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ExtendedElementInformation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ExtendedElementInformation is not None:
            showIndent(outfile, level)
            outfile.write('MD_ExtendedElementInformation=model_.MD_ExtendedElementInformation(\n')
            self.MD_ExtendedElementInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ExtendedElementInformation':
            obj_ = MD_ExtendedElementInformation_Type.factory()
            obj_.build(child_)
            self.set_MD_ExtendedElementInformation(obj_)
# end class MD_ExtendedElementInformation_PropertyType


class MD_MetadataExtensionInformation_Type(AbstractObject_Type):
    """Information describing metadata extensions."""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extensionOnLineResource=None, extendedElementInformation=None):
        super(MD_MetadataExtensionInformation_Type, self).__init__(id, uuid, )
        self.extensionOnLineResource = extensionOnLineResource
        if extendedElementInformation is None:
            self.extendedElementInformation = []
        else:
            self.extendedElementInformation = extendedElementInformation
    def factory(*args_, **kwargs_):
        if MD_MetadataExtensionInformation_Type.subclass:
            return MD_MetadataExtensionInformation_Type.subclass(*args_, **kwargs_)
        else:
            return MD_MetadataExtensionInformation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensionOnLineResource(self): return self.extensionOnLineResource
    def set_extensionOnLineResource(self, extensionOnLineResource): self.extensionOnLineResource = extensionOnLineResource
    def get_extendedElementInformation(self): return self.extendedElementInformation
    def set_extendedElementInformation(self, extendedElementInformation): self.extendedElementInformation = extendedElementInformation
    def add_extendedElementInformation(self, value): self.extendedElementInformation.append(value)
    def insert_extendedElementInformation(self, index, value): self.extendedElementInformation[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_MetadataExtensionInformation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MetadataExtensionInformation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_MetadataExtensionInformation_Type'):
        super(MD_MetadataExtensionInformation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MetadataExtensionInformation_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_MetadataExtensionInformation_Type', fromsubclass_=False):
        super(MD_MetadataExtensionInformation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.extensionOnLineResource is not None:
            self.extensionOnLineResource.export(outfile, level, namespace_, name_='extensionOnLineResource')
        for extendedElementInformation_ in self.extendedElementInformation:
            extendedElementInformation_.export(outfile, level, namespace_, name_='extendedElementInformation')
    def hasContent_(self):
        if (
            self.extensionOnLineResource is not None or
            self.extendedElementInformation or
            super(MD_MetadataExtensionInformation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_MetadataExtensionInformation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_MetadataExtensionInformation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_MetadataExtensionInformation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.extensionOnLineResource is not None:
            showIndent(outfile, level)
            outfile.write('extensionOnLineResource=model_.CI_OnlineResource_PropertyType(\n')
            self.extensionOnLineResource.exportLiteral(outfile, level, name_='extensionOnLineResource')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('extendedElementInformation=[\n')
        level += 1
        for extendedElementInformation_ in self.extendedElementInformation:
            showIndent(outfile, level)
            outfile.write('model_.MD_ExtendedElementInformation_PropertyType(\n')
            extendedElementInformation_.exportLiteral(outfile, level, name_='MD_ExtendedElementInformation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_MetadataExtensionInformation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'extensionOnLineResource':
            obj_ = CI_OnlineResource_PropertyType.factory()
            obj_.build(child_)
            self.set_extensionOnLineResource(obj_)
        elif nodeName_ == 'extendedElementInformation':
            obj_ = MD_ExtendedElementInformation_PropertyType.factory()
            obj_.build(child_)
            self.extendedElementInformation.append(obj_)
        super(MD_MetadataExtensionInformation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_MetadataExtensionInformation_Type


class MD_MetadataExtensionInformation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_MetadataExtensionInformation=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_MetadataExtensionInformation = MD_MetadataExtensionInformation
    def factory(*args_, **kwargs_):
        if MD_MetadataExtensionInformation_PropertyType.subclass:
            return MD_MetadataExtensionInformation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_MetadataExtensionInformation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_MetadataExtensionInformation(self): return self.MD_MetadataExtensionInformation
    def set_MD_MetadataExtensionInformation(self, MD_MetadataExtensionInformation): self.MD_MetadataExtensionInformation = MD_MetadataExtensionInformation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_MetadataExtensionInformation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MetadataExtensionInformation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_MetadataExtensionInformation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_MetadataExtensionInformation_PropertyType', fromsubclass_=False):
        if self.MD_MetadataExtensionInformation is not None:
            self.MD_MetadataExtensionInformation.export(outfile, level, namespace_, name_='MD_MetadataExtensionInformation', )
    def hasContent_(self):
        if (
            self.MD_MetadataExtensionInformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_MetadataExtensionInformation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_MetadataExtensionInformation is not None:
            showIndent(outfile, level)
            outfile.write('MD_MetadataExtensionInformation=model_.MD_MetadataExtensionInformation(\n')
            self.MD_MetadataExtensionInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_MetadataExtensionInformation':
            obj_ = MD_MetadataExtensionInformation_Type.factory()
            obj_.build(child_)
            self.set_MD_MetadataExtensionInformation(obj_)
# end class MD_MetadataExtensionInformation_PropertyType


class MD_ObligationCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ObligationCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ObligationCode = MD_ObligationCode
    def factory(*args_, **kwargs_):
        if MD_ObligationCode_PropertyType.subclass:
            return MD_ObligationCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ObligationCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ObligationCode(self): return self.MD_ObligationCode
    def set_MD_ObligationCode(self, MD_ObligationCode): self.MD_ObligationCode = MD_ObligationCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ObligationCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ObligationCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ObligationCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ObligationCode_PropertyType', fromsubclass_=False):
        if self.MD_ObligationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sMD_ObligationCode>%s</%sMD_ObligationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.MD_ObligationCode).encode(ExternalEncoding), input_name='MD_ObligationCode'), namespace_))
    def hasContent_(self):
        if (
            self.MD_ObligationCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ObligationCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ObligationCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_ObligationCode=%s,\n' % quote_python(self.MD_ObligationCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ObligationCode':
            MD_ObligationCode_ = child_.text
            MD_ObligationCode_ = self.gds_validate_string(MD_ObligationCode_, node, 'MD_ObligationCode')
            self.MD_ObligationCode = MD_ObligationCode_
# end class MD_ObligationCode_PropertyType


class MD_DatatypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_DatatypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_DatatypeCode = MD_DatatypeCode
    def factory(*args_, **kwargs_):
        if MD_DatatypeCode_PropertyType.subclass:
            return MD_DatatypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_DatatypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_DatatypeCode(self): return self.MD_DatatypeCode
    def set_MD_DatatypeCode(self, MD_DatatypeCode): self.MD_DatatypeCode = MD_DatatypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_DatatypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DatatypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_DatatypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_DatatypeCode_PropertyType', fromsubclass_=False):
        if self.MD_DatatypeCode is not None:
            self.MD_DatatypeCode.export(outfile, level, namespace_, name_='MD_DatatypeCode', )
    def hasContent_(self):
        if (
            self.MD_DatatypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_DatatypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_DatatypeCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_DatatypeCode=model_.MD_DatatypeCode(\n')
            self.MD_DatatypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_DatatypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_DatatypeCode(obj_)
# end class MD_DatatypeCode_PropertyType


class MD_FeatureCatalogueDescription_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_FeatureCatalogueDescription=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_FeatureCatalogueDescription = MD_FeatureCatalogueDescription
    def factory(*args_, **kwargs_):
        if MD_FeatureCatalogueDescription_PropertyType.subclass:
            return MD_FeatureCatalogueDescription_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_FeatureCatalogueDescription_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_FeatureCatalogueDescription(self): return self.MD_FeatureCatalogueDescription
    def set_MD_FeatureCatalogueDescription(self, MD_FeatureCatalogueDescription): self.MD_FeatureCatalogueDescription = MD_FeatureCatalogueDescription
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_FeatureCatalogueDescription_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_FeatureCatalogueDescription_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_FeatureCatalogueDescription_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_FeatureCatalogueDescription_PropertyType', fromsubclass_=False):
        if self.MD_FeatureCatalogueDescription is not None:
            self.MD_FeatureCatalogueDescription.export(outfile, level, namespace_, name_='MD_FeatureCatalogueDescription', )
    def hasContent_(self):
        if (
            self.MD_FeatureCatalogueDescription is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_FeatureCatalogueDescription_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_FeatureCatalogueDescription is not None:
            showIndent(outfile, level)
            outfile.write('MD_FeatureCatalogueDescription=model_.MD_FeatureCatalogueDescription(\n')
            self.MD_FeatureCatalogueDescription.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_FeatureCatalogueDescription':
            obj_ = MD_FeatureCatalogueDescription_Type.factory()
            obj_.build(child_)
            self.set_MD_FeatureCatalogueDescription(obj_)
# end class MD_FeatureCatalogueDescription_PropertyType


class MD_CoverageDescription_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_CoverageDescription=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_CoverageDescription = MD_CoverageDescription
    def factory(*args_, **kwargs_):
        if MD_CoverageDescription_PropertyType.subclass:
            return MD_CoverageDescription_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_CoverageDescription_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_CoverageDescription(self): return self.MD_CoverageDescription
    def set_MD_CoverageDescription(self, MD_CoverageDescription): self.MD_CoverageDescription = MD_CoverageDescription
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_CoverageDescription_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_CoverageDescription_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_CoverageDescription_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_CoverageDescription_PropertyType', fromsubclass_=False):
        if self.MD_CoverageDescription is not None:
            self.MD_CoverageDescription.export(outfile, level, namespace_, name_='MD_CoverageDescription', )
    def hasContent_(self):
        if (
            self.MD_CoverageDescription is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_CoverageDescription_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_CoverageDescription is not None:
            showIndent(outfile, level)
            outfile.write('MD_CoverageDescription=model_.MD_CoverageDescription(\n')
            self.MD_CoverageDescription.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_CoverageDescription':
            class_obj_ = self.get_class_obj_(child_, MD_CoverageDescription_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_MD_CoverageDescription(obj_)
# end class MD_CoverageDescription_PropertyType


class MD_ImageDescription_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ImageDescription=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ImageDescription = MD_ImageDescription
    def factory(*args_, **kwargs_):
        if MD_ImageDescription_PropertyType.subclass:
            return MD_ImageDescription_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ImageDescription_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ImageDescription(self): return self.MD_ImageDescription
    def set_MD_ImageDescription(self, MD_ImageDescription): self.MD_ImageDescription = MD_ImageDescription
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ImageDescription_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ImageDescription_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ImageDescription_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ImageDescription_PropertyType', fromsubclass_=False):
        if self.MD_ImageDescription is not None:
            self.MD_ImageDescription.export(outfile, level, namespace_, name_='MD_ImageDescription', )
    def hasContent_(self):
        if (
            self.MD_ImageDescription is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ImageDescription_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ImageDescription is not None:
            showIndent(outfile, level)
            outfile.write('MD_ImageDescription=model_.MD_ImageDescription(\n')
            self.MD_ImageDescription.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ImageDescription':
            obj_ = MD_ImageDescription_Type.factory()
            obj_.build(child_)
            self.set_MD_ImageDescription(obj_)
# end class MD_ImageDescription_PropertyType


class AbstractMD_ContentInformation_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extensiontype_=None):
        super(AbstractMD_ContentInformation_Type, self).__init__(id, uuid, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractMD_ContentInformation_Type.subclass:
            return AbstractMD_ContentInformation_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractMD_ContentInformation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractMD_ContentInformation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMD_ContentInformation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractMD_ContentInformation_Type'):
        super(AbstractMD_ContentInformation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMD_ContentInformation_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractMD_ContentInformation_Type', fromsubclass_=False):
        super(AbstractMD_ContentInformation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(AbstractMD_ContentInformation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractMD_ContentInformation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractMD_ContentInformation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractMD_ContentInformation_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractMD_ContentInformation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractMD_ContentInformation_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractMD_ContentInformation_Type


class MD_ContentInformation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractMD_ContentInformation=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractMD_ContentInformation = AbstractMD_ContentInformation
    def factory(*args_, **kwargs_):
        if MD_ContentInformation_PropertyType.subclass:
            return MD_ContentInformation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ContentInformation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractMD_ContentInformation(self): return self.AbstractMD_ContentInformation
    def set_AbstractMD_ContentInformation(self, AbstractMD_ContentInformation): self.AbstractMD_ContentInformation = AbstractMD_ContentInformation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ContentInformation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ContentInformation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ContentInformation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ContentInformation_PropertyType', fromsubclass_=False):
        if self.AbstractMD_ContentInformation is not None:
            self.AbstractMD_ContentInformation.export(outfile, level, namespace_, name_='AbstractMD_ContentInformation')
    def hasContent_(self):
        if (
            self.AbstractMD_ContentInformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ContentInformation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractMD_ContentInformation is not None:
            showIndent(outfile, level)
            outfile.write('AbstractMD_ContentInformation=model_.AbstractMD_ContentInformation(\n')
            self.AbstractMD_ContentInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractMD_ContentInformation':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractMD_ContentInformation> element')
            self.set_AbstractMD_ContentInformation(obj_)
# end class MD_ContentInformation_PropertyType


class MD_RangeDimension_Type(AbstractObject_Type):
    """Set of adjacent wavelengths in the electro-magnetic spectrum with a
    common characteristic, such as the visible band"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, sequenceIdentifier=None, descriptor=None, extensiontype_=None):
        super(MD_RangeDimension_Type, self).__init__(id, uuid, extensiontype_, )
        self.sequenceIdentifier = sequenceIdentifier
        self.descriptor = descriptor
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MD_RangeDimension_Type.subclass:
            return MD_RangeDimension_Type.subclass(*args_, **kwargs_)
        else:
            return MD_RangeDimension_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceIdentifier(self): return self.sequenceIdentifier
    def set_sequenceIdentifier(self, sequenceIdentifier): self.sequenceIdentifier = sequenceIdentifier
    def get_descriptor(self): return self.descriptor
    def set_descriptor(self, descriptor): self.descriptor = descriptor
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MD_RangeDimension_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_RangeDimension_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_RangeDimension_Type'):
        super(MD_RangeDimension_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_RangeDimension_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MD_RangeDimension_Type', fromsubclass_=False):
        super(MD_RangeDimension_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.sequenceIdentifier is not None:
            self.sequenceIdentifier.export(outfile, level, namespace_, name_='sequenceIdentifier')
        if self.descriptor is not None:
            self.descriptor.export(outfile, level, namespace_, name_='descriptor')
    def hasContent_(self):
        if (
            self.sequenceIdentifier is not None or
            self.descriptor is not None or
            super(MD_RangeDimension_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_RangeDimension_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_RangeDimension_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_RangeDimension_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.sequenceIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('sequenceIdentifier=model_.MemberName_PropertyType(\n')
            self.sequenceIdentifier.exportLiteral(outfile, level, name_='sequenceIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptor is not None:
            showIndent(outfile, level)
            outfile.write('descriptor=model_.CharacterString_PropertyType(\n')
            self.descriptor.exportLiteral(outfile, level, name_='descriptor')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(MD_RangeDimension_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequenceIdentifier':
            obj_ = MemberName_PropertyType.factory()
            obj_.build(child_)
            self.set_sequenceIdentifier(obj_)
        elif nodeName_ == 'descriptor':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_descriptor(obj_)
        super(MD_RangeDimension_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_RangeDimension_Type


class MD_RangeDimension_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_RangeDimension=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_RangeDimension = MD_RangeDimension
    def factory(*args_, **kwargs_):
        if MD_RangeDimension_PropertyType.subclass:
            return MD_RangeDimension_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_RangeDimension_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_RangeDimension(self): return self.MD_RangeDimension
    def set_MD_RangeDimension(self, MD_RangeDimension): self.MD_RangeDimension = MD_RangeDimension
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_RangeDimension_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_RangeDimension_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_RangeDimension_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_RangeDimension_PropertyType', fromsubclass_=False):
        if self.MD_RangeDimension is not None:
            self.MD_RangeDimension.export(outfile, level, namespace_, name_='MD_RangeDimension', )
    def hasContent_(self):
        if (
            self.MD_RangeDimension is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_RangeDimension_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_RangeDimension is not None:
            showIndent(outfile, level)
            outfile.write('MD_RangeDimension=model_.MD_RangeDimension(\n')
            self.MD_RangeDimension.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_RangeDimension':
            class_obj_ = self.get_class_obj_(child_, MD_RangeDimension_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_MD_RangeDimension(obj_)
# end class MD_RangeDimension_PropertyType


class MD_Band_Type(MD_RangeDimension_Type):
    subclass = None
    superclass = MD_RangeDimension_Type
    def __init__(self, id=None, uuid=None, sequenceIdentifier=None, descriptor=None, maxValue=None, minValue=None, units=None, peakResponse=None, bitsPerValue=None, toneGradation=None, scaleFactor=None, offset=None):
        super(MD_Band_Type, self).__init__(id, uuid, sequenceIdentifier, descriptor, )
        self.maxValue = maxValue
        self.minValue = minValue
        self.units = units
        self.peakResponse = peakResponse
        self.bitsPerValue = bitsPerValue
        self.toneGradation = toneGradation
        self.scaleFactor = scaleFactor
        self.offset = offset
    def factory(*args_, **kwargs_):
        if MD_Band_Type.subclass:
            return MD_Band_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Band_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxValue(self): return self.maxValue
    def set_maxValue(self, maxValue): self.maxValue = maxValue
    def get_minValue(self): return self.minValue
    def set_minValue(self, minValue): self.minValue = minValue
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_peakResponse(self): return self.peakResponse
    def set_peakResponse(self, peakResponse): self.peakResponse = peakResponse
    def get_bitsPerValue(self): return self.bitsPerValue
    def set_bitsPerValue(self, bitsPerValue): self.bitsPerValue = bitsPerValue
    def get_toneGradation(self): return self.toneGradation
    def set_toneGradation(self, toneGradation): self.toneGradation = toneGradation
    def get_scaleFactor(self): return self.scaleFactor
    def set_scaleFactor(self, scaleFactor): self.scaleFactor = scaleFactor
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def export(self, outfile, level, namespace_='', name_='MD_Band_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Band_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Band_Type'):
        super(MD_Band_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Band_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Band_Type', fromsubclass_=False):
        super(MD_Band_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.maxValue is not None:
            self.maxValue.export(outfile, level, namespace_, name_='maxValue')
        if self.minValue is not None:
            self.minValue.export(outfile, level, namespace_, name_='minValue')
        if self.units is not None:
            self.units.export(outfile, level, namespace_, name_='units')
        if self.peakResponse is not None:
            self.peakResponse.export(outfile, level, namespace_, name_='peakResponse')
        if self.bitsPerValue is not None:
            self.bitsPerValue.export(outfile, level, namespace_, name_='bitsPerValue')
        if self.toneGradation is not None:
            self.toneGradation.export(outfile, level, namespace_, name_='toneGradation')
        if self.scaleFactor is not None:
            self.scaleFactor.export(outfile, level, namespace_, name_='scaleFactor')
        if self.offset is not None:
            self.offset.export(outfile, level, namespace_, name_='offset')
    def hasContent_(self):
        if (
            self.maxValue is not None or
            self.minValue is not None or
            self.units is not None or
            self.peakResponse is not None or
            self.bitsPerValue is not None or
            self.toneGradation is not None or
            self.scaleFactor is not None or
            self.offset is not None or
            super(MD_Band_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Band_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Band_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Band_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.maxValue is not None:
            showIndent(outfile, level)
            outfile.write('maxValue=model_.Real_PropertyType(\n')
            self.maxValue.exportLiteral(outfile, level, name_='maxValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.minValue is not None:
            showIndent(outfile, level)
            outfile.write('minValue=model_.Real_PropertyType(\n')
            self.minValue.exportLiteral(outfile, level, name_='minValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units=model_.UomLength_PropertyType(\n')
            self.units.exportLiteral(outfile, level, name_='units')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.peakResponse is not None:
            showIndent(outfile, level)
            outfile.write('peakResponse=model_.Real_PropertyType(\n')
            self.peakResponse.exportLiteral(outfile, level, name_='peakResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bitsPerValue is not None:
            showIndent(outfile, level)
            outfile.write('bitsPerValue=model_.Integer_PropertyType(\n')
            self.bitsPerValue.exportLiteral(outfile, level, name_='bitsPerValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.toneGradation is not None:
            showIndent(outfile, level)
            outfile.write('toneGradation=model_.Integer_PropertyType(\n')
            self.toneGradation.exportLiteral(outfile, level, name_='toneGradation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scaleFactor is not None:
            showIndent(outfile, level)
            outfile.write('scaleFactor=model_.Real_PropertyType(\n')
            self.scaleFactor.exportLiteral(outfile, level, name_='scaleFactor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.offset is not None:
            showIndent(outfile, level)
            outfile.write('offset=model_.Real_PropertyType(\n')
            self.offset.exportLiteral(outfile, level, name_='offset')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Band_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'maxValue':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_maxValue(obj_)
        elif nodeName_ == 'minValue':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_minValue(obj_)
        elif nodeName_ == 'units':
            obj_ = UomLength_PropertyType.factory()
            obj_.build(child_)
            self.set_units(obj_)
        elif nodeName_ == 'peakResponse':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_peakResponse(obj_)
        elif nodeName_ == 'bitsPerValue':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_bitsPerValue(obj_)
        elif nodeName_ == 'toneGradation':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_toneGradation(obj_)
        elif nodeName_ == 'scaleFactor':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_scaleFactor(obj_)
        elif nodeName_ == 'offset':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_offset(obj_)
        super(MD_Band_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Band_Type


class MD_Band_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Band=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Band = MD_Band
    def factory(*args_, **kwargs_):
        if MD_Band_PropertyType.subclass:
            return MD_Band_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Band_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Band(self): return self.MD_Band
    def set_MD_Band(self, MD_Band): self.MD_Band = MD_Band
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Band_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Band_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Band_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Band_PropertyType', fromsubclass_=False):
        if self.MD_Band is not None:
            self.MD_Band.export(outfile, level, namespace_, name_='MD_Band', )
    def hasContent_(self):
        if (
            self.MD_Band is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Band_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Band is not None:
            showIndent(outfile, level)
            outfile.write('MD_Band=model_.MD_Band(\n')
            self.MD_Band.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Band':
            obj_ = MD_Band_Type.factory()
            obj_.build(child_)
            self.set_MD_Band(obj_)
# end class MD_Band_PropertyType


class MD_CoverageContentTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_CoverageContentTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_CoverageContentTypeCode = MD_CoverageContentTypeCode
    def factory(*args_, **kwargs_):
        if MD_CoverageContentTypeCode_PropertyType.subclass:
            return MD_CoverageContentTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_CoverageContentTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_CoverageContentTypeCode(self): return self.MD_CoverageContentTypeCode
    def set_MD_CoverageContentTypeCode(self, MD_CoverageContentTypeCode): self.MD_CoverageContentTypeCode = MD_CoverageContentTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_CoverageContentTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_CoverageContentTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_CoverageContentTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_CoverageContentTypeCode_PropertyType', fromsubclass_=False):
        if self.MD_CoverageContentTypeCode is not None:
            self.MD_CoverageContentTypeCode.export(outfile, level, namespace_, name_='MD_CoverageContentTypeCode', )
    def hasContent_(self):
        if (
            self.MD_CoverageContentTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_CoverageContentTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_CoverageContentTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_CoverageContentTypeCode=model_.MD_CoverageContentTypeCode(\n')
            self.MD_CoverageContentTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_CoverageContentTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_CoverageContentTypeCode(obj_)
# end class MD_CoverageContentTypeCode_PropertyType


class MD_ImagingConditionCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ImagingConditionCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ImagingConditionCode = MD_ImagingConditionCode
    def factory(*args_, **kwargs_):
        if MD_ImagingConditionCode_PropertyType.subclass:
            return MD_ImagingConditionCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ImagingConditionCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ImagingConditionCode(self): return self.MD_ImagingConditionCode
    def set_MD_ImagingConditionCode(self, MD_ImagingConditionCode): self.MD_ImagingConditionCode = MD_ImagingConditionCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ImagingConditionCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ImagingConditionCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ImagingConditionCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ImagingConditionCode_PropertyType', fromsubclass_=False):
        if self.MD_ImagingConditionCode is not None:
            self.MD_ImagingConditionCode.export(outfile, level, namespace_, name_='MD_ImagingConditionCode', )
    def hasContent_(self):
        if (
            self.MD_ImagingConditionCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ImagingConditionCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ImagingConditionCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_ImagingConditionCode=model_.MD_ImagingConditionCode(\n')
            self.MD_ImagingConditionCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ImagingConditionCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_ImagingConditionCode(obj_)
# end class MD_ImagingConditionCode_PropertyType


class MD_ApplicationSchemaInformation_Type(AbstractObject_Type):
    """Information about the application schema used to build the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, name=None, schemaLanguage=None, constraintLanguage=None, schemaAscii=None, graphicsFile=None, softwareDevelopmentFile=None, softwareDevelopmentFileFormat=None):
        super(MD_ApplicationSchemaInformation_Type, self).__init__(id, uuid, )
        self.name = name
        self.schemaLanguage = schemaLanguage
        self.constraintLanguage = constraintLanguage
        self.schemaAscii = schemaAscii
        self.graphicsFile = graphicsFile
        self.softwareDevelopmentFile = softwareDevelopmentFile
        self.softwareDevelopmentFileFormat = softwareDevelopmentFileFormat
    def factory(*args_, **kwargs_):
        if MD_ApplicationSchemaInformation_Type.subclass:
            return MD_ApplicationSchemaInformation_Type.subclass(*args_, **kwargs_)
        else:
            return MD_ApplicationSchemaInformation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_schemaLanguage(self): return self.schemaLanguage
    def set_schemaLanguage(self, schemaLanguage): self.schemaLanguage = schemaLanguage
    def get_constraintLanguage(self): return self.constraintLanguage
    def set_constraintLanguage(self, constraintLanguage): self.constraintLanguage = constraintLanguage
    def get_schemaAscii(self): return self.schemaAscii
    def set_schemaAscii(self, schemaAscii): self.schemaAscii = schemaAscii
    def get_graphicsFile(self): return self.graphicsFile
    def set_graphicsFile(self, graphicsFile): self.graphicsFile = graphicsFile
    def get_softwareDevelopmentFile(self): return self.softwareDevelopmentFile
    def set_softwareDevelopmentFile(self, softwareDevelopmentFile): self.softwareDevelopmentFile = softwareDevelopmentFile
    def get_softwareDevelopmentFileFormat(self): return self.softwareDevelopmentFileFormat
    def set_softwareDevelopmentFileFormat(self, softwareDevelopmentFileFormat): self.softwareDevelopmentFileFormat = softwareDevelopmentFileFormat
    def export(self, outfile, level, namespace_='', name_='MD_ApplicationSchemaInformation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ApplicationSchemaInformation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ApplicationSchemaInformation_Type'):
        super(MD_ApplicationSchemaInformation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ApplicationSchemaInformation_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ApplicationSchemaInformation_Type', fromsubclass_=False):
        super(MD_ApplicationSchemaInformation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', )
        if self.schemaLanguage is not None:
            self.schemaLanguage.export(outfile, level, namespace_, name_='schemaLanguage', )
        if self.constraintLanguage is not None:
            self.constraintLanguage.export(outfile, level, namespace_, name_='constraintLanguage', )
        if self.schemaAscii is not None:
            self.schemaAscii.export(outfile, level, namespace_, name_='schemaAscii')
        if self.graphicsFile is not None:
            self.graphicsFile.export(outfile, level, namespace_, name_='graphicsFile')
        if self.softwareDevelopmentFile is not None:
            self.softwareDevelopmentFile.export(outfile, level, namespace_, name_='softwareDevelopmentFile')
        if self.softwareDevelopmentFileFormat is not None:
            self.softwareDevelopmentFileFormat.export(outfile, level, namespace_, name_='softwareDevelopmentFileFormat')
    def hasContent_(self):
        if (
            self.name is not None or
            self.schemaLanguage is not None or
            self.constraintLanguage is not None or
            self.schemaAscii is not None or
            self.graphicsFile is not None or
            self.softwareDevelopmentFile is not None or
            self.softwareDevelopmentFileFormat is not None or
            super(MD_ApplicationSchemaInformation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ApplicationSchemaInformation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_ApplicationSchemaInformation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_ApplicationSchemaInformation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.CI_Citation_PropertyType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.schemaLanguage is not None:
            showIndent(outfile, level)
            outfile.write('schemaLanguage=model_.CharacterString_PropertyType(\n')
            self.schemaLanguage.exportLiteral(outfile, level, name_='schemaLanguage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.constraintLanguage is not None:
            showIndent(outfile, level)
            outfile.write('constraintLanguage=model_.CharacterString_PropertyType(\n')
            self.constraintLanguage.exportLiteral(outfile, level, name_='constraintLanguage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.schemaAscii is not None:
            showIndent(outfile, level)
            outfile.write('schemaAscii=model_.CharacterString_PropertyType(\n')
            self.schemaAscii.exportLiteral(outfile, level, name_='schemaAscii')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.graphicsFile is not None:
            showIndent(outfile, level)
            outfile.write('graphicsFile=model_.Binary_PropertyType(\n')
            self.graphicsFile.exportLiteral(outfile, level, name_='graphicsFile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.softwareDevelopmentFile is not None:
            showIndent(outfile, level)
            outfile.write('softwareDevelopmentFile=model_.Binary_PropertyType(\n')
            self.softwareDevelopmentFile.exportLiteral(outfile, level, name_='softwareDevelopmentFile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.softwareDevelopmentFileFormat is not None:
            showIndent(outfile, level)
            outfile.write('softwareDevelopmentFileFormat=model_.CharacterString_PropertyType(\n')
            self.softwareDevelopmentFileFormat.exportLiteral(outfile, level, name_='softwareDevelopmentFileFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_ApplicationSchemaInformation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'schemaLanguage':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_schemaLanguage(obj_)
        elif nodeName_ == 'constraintLanguage':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_constraintLanguage(obj_)
        elif nodeName_ == 'schemaAscii':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_schemaAscii(obj_)
        elif nodeName_ == 'graphicsFile':
            obj_ = Binary_PropertyType.factory()
            obj_.build(child_)
            self.set_graphicsFile(obj_)
        elif nodeName_ == 'softwareDevelopmentFile':
            obj_ = Binary_PropertyType.factory()
            obj_.build(child_)
            self.set_softwareDevelopmentFile(obj_)
        elif nodeName_ == 'softwareDevelopmentFileFormat':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_softwareDevelopmentFileFormat(obj_)
        super(MD_ApplicationSchemaInformation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_ApplicationSchemaInformation_Type


class MD_ApplicationSchemaInformation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ApplicationSchemaInformation=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ApplicationSchemaInformation = MD_ApplicationSchemaInformation
    def factory(*args_, **kwargs_):
        if MD_ApplicationSchemaInformation_PropertyType.subclass:
            return MD_ApplicationSchemaInformation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ApplicationSchemaInformation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ApplicationSchemaInformation(self): return self.MD_ApplicationSchemaInformation
    def set_MD_ApplicationSchemaInformation(self, MD_ApplicationSchemaInformation): self.MD_ApplicationSchemaInformation = MD_ApplicationSchemaInformation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ApplicationSchemaInformation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ApplicationSchemaInformation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ApplicationSchemaInformation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ApplicationSchemaInformation_PropertyType', fromsubclass_=False):
        if self.MD_ApplicationSchemaInformation is not None:
            self.MD_ApplicationSchemaInformation.export(outfile, level, namespace_, name_='MD_ApplicationSchemaInformation', )
    def hasContent_(self):
        if (
            self.MD_ApplicationSchemaInformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ApplicationSchemaInformation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ApplicationSchemaInformation is not None:
            showIndent(outfile, level)
            outfile.write('MD_ApplicationSchemaInformation=model_.MD_ApplicationSchemaInformation(\n')
            self.MD_ApplicationSchemaInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ApplicationSchemaInformation':
            obj_ = MD_ApplicationSchemaInformation_Type.factory()
            obj_.build(child_)
            self.set_MD_ApplicationSchemaInformation(obj_)
# end class MD_ApplicationSchemaInformation_PropertyType


class MD_PortrayalCatalogueReference_Type(AbstractObject_Type):
    """Information identifing the portrayal catalogue used"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, portrayalCatalogueCitation=None):
        super(MD_PortrayalCatalogueReference_Type, self).__init__(id, uuid, )
        if portrayalCatalogueCitation is None:
            self.portrayalCatalogueCitation = []
        else:
            self.portrayalCatalogueCitation = portrayalCatalogueCitation
    def factory(*args_, **kwargs_):
        if MD_PortrayalCatalogueReference_Type.subclass:
            return MD_PortrayalCatalogueReference_Type.subclass(*args_, **kwargs_)
        else:
            return MD_PortrayalCatalogueReference_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_portrayalCatalogueCitation(self): return self.portrayalCatalogueCitation
    def set_portrayalCatalogueCitation(self, portrayalCatalogueCitation): self.portrayalCatalogueCitation = portrayalCatalogueCitation
    def add_portrayalCatalogueCitation(self, value): self.portrayalCatalogueCitation.append(value)
    def insert_portrayalCatalogueCitation(self, index, value): self.portrayalCatalogueCitation[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_PortrayalCatalogueReference_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_PortrayalCatalogueReference_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_PortrayalCatalogueReference_Type'):
        super(MD_PortrayalCatalogueReference_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_PortrayalCatalogueReference_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_PortrayalCatalogueReference_Type', fromsubclass_=False):
        super(MD_PortrayalCatalogueReference_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for portrayalCatalogueCitation_ in self.portrayalCatalogueCitation:
            portrayalCatalogueCitation_.export(outfile, level, namespace_, name_='portrayalCatalogueCitation')
    def hasContent_(self):
        if (
            self.portrayalCatalogueCitation or
            super(MD_PortrayalCatalogueReference_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_PortrayalCatalogueReference_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_PortrayalCatalogueReference_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_PortrayalCatalogueReference_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('portrayalCatalogueCitation=[\n')
        level += 1
        for portrayalCatalogueCitation_ in self.portrayalCatalogueCitation:
            showIndent(outfile, level)
            outfile.write('model_.CI_Citation_PropertyType(\n')
            portrayalCatalogueCitation_.exportLiteral(outfile, level, name_='CI_Citation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_PortrayalCatalogueReference_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'portrayalCatalogueCitation':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.portrayalCatalogueCitation.append(obj_)
        super(MD_PortrayalCatalogueReference_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_PortrayalCatalogueReference_Type


class MD_PortrayalCatalogueReference_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_PortrayalCatalogueReference=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_PortrayalCatalogueReference = MD_PortrayalCatalogueReference
    def factory(*args_, **kwargs_):
        if MD_PortrayalCatalogueReference_PropertyType.subclass:
            return MD_PortrayalCatalogueReference_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_PortrayalCatalogueReference_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_PortrayalCatalogueReference(self): return self.MD_PortrayalCatalogueReference
    def set_MD_PortrayalCatalogueReference(self, MD_PortrayalCatalogueReference): self.MD_PortrayalCatalogueReference = MD_PortrayalCatalogueReference
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_PortrayalCatalogueReference_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_PortrayalCatalogueReference_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_PortrayalCatalogueReference_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_PortrayalCatalogueReference_PropertyType', fromsubclass_=False):
        if self.MD_PortrayalCatalogueReference is not None:
            self.MD_PortrayalCatalogueReference.export(outfile, level, namespace_, name_='MD_PortrayalCatalogueReference', )
    def hasContent_(self):
        if (
            self.MD_PortrayalCatalogueReference is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_PortrayalCatalogueReference_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_PortrayalCatalogueReference is not None:
            showIndent(outfile, level)
            outfile.write('MD_PortrayalCatalogueReference=model_.MD_PortrayalCatalogueReference(\n')
            self.MD_PortrayalCatalogueReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_PortrayalCatalogueReference':
            obj_ = MD_PortrayalCatalogueReference_Type.factory()
            obj_.build(child_)
            self.set_MD_PortrayalCatalogueReference(obj_)
# end class MD_PortrayalCatalogueReference_PropertyType


class LI_ProcessStep_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, description=None, rationale=None, dateTime=None, processor=None, source=None):
        super(LI_ProcessStep_Type, self).__init__(id, uuid, )
        self.description = description
        self.rationale = rationale
        self.dateTime = dateTime
        if processor is None:
            self.processor = []
        else:
            self.processor = processor
        if source is None:
            self.source = []
        else:
            self.source = source
    def factory(*args_, **kwargs_):
        if LI_ProcessStep_Type.subclass:
            return LI_ProcessStep_Type.subclass(*args_, **kwargs_)
        else:
            return LI_ProcessStep_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_rationale(self): return self.rationale
    def set_rationale(self, rationale): self.rationale = rationale
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_processor(self): return self.processor
    def set_processor(self, processor): self.processor = processor
    def add_processor(self, value): self.processor.append(value)
    def insert_processor(self, index, value): self.processor[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def add_source(self, value): self.source.append(value)
    def insert_source(self, index, value): self.source[index] = value
    def export(self, outfile, level, namespace_='', name_='LI_ProcessStep_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LI_ProcessStep_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LI_ProcessStep_Type'):
        super(LI_ProcessStep_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LI_ProcessStep_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='LI_ProcessStep_Type', fromsubclass_=False):
        super(LI_ProcessStep_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', )
        if self.rationale is not None:
            self.rationale.export(outfile, level, namespace_, name_='rationale')
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime')
        for processor_ in self.processor:
            processor_.export(outfile, level, namespace_, name_='processor')
        for source_ in self.source:
            source_.export(outfile, level, namespace_, name_='source')
    def hasContent_(self):
        if (
            self.description is not None or
            self.rationale is not None or
            self.dateTime is not None or
            self.processor or
            self.source or
            super(LI_ProcessStep_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LI_ProcessStep_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LI_ProcessStep_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LI_ProcessStep_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.CharacterString_PropertyType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rationale is not None:
            showIndent(outfile, level)
            outfile.write('rationale=model_.CharacterString_PropertyType(\n')
            self.rationale.exportLiteral(outfile, level, name_='rationale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.DateTime_PropertyType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('processor=[\n')
        level += 1
        for processor_ in self.processor:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            processor_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('source=[\n')
        level += 1
        for source_ in self.source:
            showIndent(outfile, level)
            outfile.write('model_.LI_Source_PropertyType(\n')
            source_.exportLiteral(outfile, level, name_='LI_Source_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LI_ProcessStep_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'rationale':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_rationale(obj_)
        elif nodeName_ == 'dateTime':
            obj_ = DateTime_PropertyType.factory()
            obj_.build(child_)
            self.set_dateTime(obj_)
        elif nodeName_ == 'processor':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.processor.append(obj_)
        elif nodeName_ == 'source':
            obj_ = LI_Source_PropertyType.factory()
            obj_.build(child_)
            self.source.append(obj_)
        super(LI_ProcessStep_Type, self).buildChildren(child_, node, nodeName_, True)
# end class LI_ProcessStep_Type


class LI_ProcessStep_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, LI_ProcessStep=None):
        self.nilReason = _cast(None, nilReason)
        self.LI_ProcessStep = LI_ProcessStep
    def factory(*args_, **kwargs_):
        if LI_ProcessStep_PropertyType.subclass:
            return LI_ProcessStep_PropertyType.subclass(*args_, **kwargs_)
        else:
            return LI_ProcessStep_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LI_ProcessStep(self): return self.LI_ProcessStep
    def set_LI_ProcessStep(self, LI_ProcessStep): self.LI_ProcessStep = LI_ProcessStep
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='LI_ProcessStep_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LI_ProcessStep_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LI_ProcessStep_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LI_ProcessStep_PropertyType', fromsubclass_=False):
        if self.LI_ProcessStep is not None:
            self.LI_ProcessStep.export(outfile, level, namespace_, name_='LI_ProcessStep', )
    def hasContent_(self):
        if (
            self.LI_ProcessStep is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LI_ProcessStep_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LI_ProcessStep is not None:
            showIndent(outfile, level)
            outfile.write('LI_ProcessStep=model_.LI_ProcessStep(\n')
            self.LI_ProcessStep.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LI_ProcessStep':
            obj_ = LI_ProcessStep_Type.factory()
            obj_.build(child_)
            self.set_LI_ProcessStep(obj_)
# end class LI_ProcessStep_PropertyType


class LI_Source_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, description=None, scaleDenominator=None, sourceReferenceSystem=None, sourceCitation=None, sourceExtent=None, sourceStep=None):
        super(LI_Source_Type, self).__init__(id, uuid, )
        self.description = description
        self.scaleDenominator = scaleDenominator
        self.sourceReferenceSystem = sourceReferenceSystem
        self.sourceCitation = sourceCitation
        if sourceExtent is None:
            self.sourceExtent = []
        else:
            self.sourceExtent = sourceExtent
        if sourceStep is None:
            self.sourceStep = []
        else:
            self.sourceStep = sourceStep
    def factory(*args_, **kwargs_):
        if LI_Source_Type.subclass:
            return LI_Source_Type.subclass(*args_, **kwargs_)
        else:
            return LI_Source_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_scaleDenominator(self): return self.scaleDenominator
    def set_scaleDenominator(self, scaleDenominator): self.scaleDenominator = scaleDenominator
    def get_sourceReferenceSystem(self): return self.sourceReferenceSystem
    def set_sourceReferenceSystem(self, sourceReferenceSystem): self.sourceReferenceSystem = sourceReferenceSystem
    def get_sourceCitation(self): return self.sourceCitation
    def set_sourceCitation(self, sourceCitation): self.sourceCitation = sourceCitation
    def get_sourceExtent(self): return self.sourceExtent
    def set_sourceExtent(self, sourceExtent): self.sourceExtent = sourceExtent
    def add_sourceExtent(self, value): self.sourceExtent.append(value)
    def insert_sourceExtent(self, index, value): self.sourceExtent[index] = value
    def get_sourceStep(self): return self.sourceStep
    def set_sourceStep(self, sourceStep): self.sourceStep = sourceStep
    def add_sourceStep(self, value): self.sourceStep.append(value)
    def insert_sourceStep(self, index, value): self.sourceStep[index] = value
    def export(self, outfile, level, namespace_='', name_='LI_Source_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LI_Source_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LI_Source_Type'):
        super(LI_Source_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LI_Source_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='LI_Source_Type', fromsubclass_=False):
        super(LI_Source_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.scaleDenominator is not None:
            self.scaleDenominator.export(outfile, level, namespace_, name_='scaleDenominator')
        if self.sourceReferenceSystem is not None:
            self.sourceReferenceSystem.export(outfile, level, namespace_, name_='sourceReferenceSystem')
        if self.sourceCitation is not None:
            self.sourceCitation.export(outfile, level, namespace_, name_='sourceCitation')
        for sourceExtent_ in self.sourceExtent:
            sourceExtent_.export(outfile, level, namespace_, name_='sourceExtent')
        for sourceStep_ in self.sourceStep:
            sourceStep_.export(outfile, level, namespace_, name_='sourceStep')
    def hasContent_(self):
        if (
            self.description is not None or
            self.scaleDenominator is not None or
            self.sourceReferenceSystem is not None or
            self.sourceCitation is not None or
            self.sourceExtent or
            self.sourceStep or
            super(LI_Source_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LI_Source_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LI_Source_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LI_Source_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.CharacterString_PropertyType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scaleDenominator is not None:
            showIndent(outfile, level)
            outfile.write('scaleDenominator=model_.MD_RepresentativeFraction_PropertyType(\n')
            self.scaleDenominator.exportLiteral(outfile, level, name_='scaleDenominator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sourceReferenceSystem is not None:
            showIndent(outfile, level)
            outfile.write('sourceReferenceSystem=model_.MD_ReferenceSystem_PropertyType(\n')
            self.sourceReferenceSystem.exportLiteral(outfile, level, name_='sourceReferenceSystem')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sourceCitation is not None:
            showIndent(outfile, level)
            outfile.write('sourceCitation=model_.CI_Citation_PropertyType(\n')
            self.sourceCitation.exportLiteral(outfile, level, name_='sourceCitation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('sourceExtent=[\n')
        level += 1
        for sourceExtent_ in self.sourceExtent:
            showIndent(outfile, level)
            outfile.write('model_.EX_Extent_PropertyType(\n')
            sourceExtent_.exportLiteral(outfile, level, name_='EX_Extent_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sourceStep=[\n')
        level += 1
        for sourceStep_ in self.sourceStep:
            showIndent(outfile, level)
            outfile.write('model_.LI_ProcessStep_PropertyType(\n')
            sourceStep_.exportLiteral(outfile, level, name_='LI_ProcessStep_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LI_Source_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'scaleDenominator':
            obj_ = MD_RepresentativeFraction_PropertyType.factory()
            obj_.build(child_)
            self.set_scaleDenominator(obj_)
        elif nodeName_ == 'sourceReferenceSystem':
            obj_ = MD_ReferenceSystem_PropertyType.factory()
            obj_.build(child_)
            self.set_sourceReferenceSystem(obj_)
        elif nodeName_ == 'sourceCitation':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_sourceCitation(obj_)
        elif nodeName_ == 'sourceExtent':
            obj_ = EX_Extent_PropertyType.factory()
            obj_.build(child_)
            self.sourceExtent.append(obj_)
        elif nodeName_ == 'sourceStep':
            obj_ = LI_ProcessStep_PropertyType.factory()
            obj_.build(child_)
            self.sourceStep.append(obj_)
        super(LI_Source_Type, self).buildChildren(child_, node, nodeName_, True)
# end class LI_Source_Type


class LI_Source_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, LI_Source=None):
        self.nilReason = _cast(None, nilReason)
        self.LI_Source = LI_Source
    def factory(*args_, **kwargs_):
        if LI_Source_PropertyType.subclass:
            return LI_Source_PropertyType.subclass(*args_, **kwargs_)
        else:
            return LI_Source_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LI_Source(self): return self.LI_Source
    def set_LI_Source(self, LI_Source): self.LI_Source = LI_Source
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='LI_Source_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LI_Source_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LI_Source_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LI_Source_PropertyType', fromsubclass_=False):
        if self.LI_Source is not None:
            self.LI_Source.export(outfile, level, namespace_, name_='LI_Source', )
    def hasContent_(self):
        if (
            self.LI_Source is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LI_Source_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LI_Source is not None:
            showIndent(outfile, level)
            outfile.write('LI_Source=model_.LI_Source(\n')
            self.LI_Source.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LI_Source':
            obj_ = LI_Source_Type.factory()
            obj_.build(child_)
            self.set_LI_Source(obj_)
# end class LI_Source_PropertyType


class LI_Lineage_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, statement=None, processStep=None, source=None):
        super(LI_Lineage_Type, self).__init__(id, uuid, )
        self.statement = statement
        if processStep is None:
            self.processStep = []
        else:
            self.processStep = processStep
        if source is None:
            self.source = []
        else:
            self.source = source
    def factory(*args_, **kwargs_):
        if LI_Lineage_Type.subclass:
            return LI_Lineage_Type.subclass(*args_, **kwargs_)
        else:
            return LI_Lineage_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_statement(self): return self.statement
    def set_statement(self, statement): self.statement = statement
    def get_processStep(self): return self.processStep
    def set_processStep(self, processStep): self.processStep = processStep
    def add_processStep(self, value): self.processStep.append(value)
    def insert_processStep(self, index, value): self.processStep[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def add_source(self, value): self.source.append(value)
    def insert_source(self, index, value): self.source[index] = value
    def export(self, outfile, level, namespace_='', name_='LI_Lineage_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LI_Lineage_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LI_Lineage_Type'):
        super(LI_Lineage_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LI_Lineage_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='LI_Lineage_Type', fromsubclass_=False):
        super(LI_Lineage_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.statement is not None:
            self.statement.export(outfile, level, namespace_, name_='statement')
        for processStep_ in self.processStep:
            processStep_.export(outfile, level, namespace_, name_='processStep')
        for source_ in self.source:
            source_.export(outfile, level, namespace_, name_='source')
    def hasContent_(self):
        if (
            self.statement is not None or
            self.processStep or
            self.source or
            super(LI_Lineage_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LI_Lineage_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LI_Lineage_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LI_Lineage_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.statement is not None:
            showIndent(outfile, level)
            outfile.write('statement=model_.CharacterString_PropertyType(\n')
            self.statement.exportLiteral(outfile, level, name_='statement')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('processStep=[\n')
        level += 1
        for processStep_ in self.processStep:
            showIndent(outfile, level)
            outfile.write('model_.LI_ProcessStep_PropertyType(\n')
            processStep_.exportLiteral(outfile, level, name_='LI_ProcessStep_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('source=[\n')
        level += 1
        for source_ in self.source:
            showIndent(outfile, level)
            outfile.write('model_.LI_Source_PropertyType(\n')
            source_.exportLiteral(outfile, level, name_='LI_Source_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LI_Lineage_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'statement':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_statement(obj_)
        elif nodeName_ == 'processStep':
            obj_ = LI_ProcessStep_PropertyType.factory()
            obj_.build(child_)
            self.processStep.append(obj_)
        elif nodeName_ == 'source':
            obj_ = LI_Source_PropertyType.factory()
            obj_.build(child_)
            self.source.append(obj_)
        super(LI_Lineage_Type, self).buildChildren(child_, node, nodeName_, True)
# end class LI_Lineage_Type


class LI_Lineage_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, LI_Lineage=None):
        self.nilReason = _cast(None, nilReason)
        self.LI_Lineage = LI_Lineage
    def factory(*args_, **kwargs_):
        if LI_Lineage_PropertyType.subclass:
            return LI_Lineage_PropertyType.subclass(*args_, **kwargs_)
        else:
            return LI_Lineage_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LI_Lineage(self): return self.LI_Lineage
    def set_LI_Lineage(self, LI_Lineage): self.LI_Lineage = LI_Lineage
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='LI_Lineage_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LI_Lineage_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LI_Lineage_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LI_Lineage_PropertyType', fromsubclass_=False):
        if self.LI_Lineage is not None:
            self.LI_Lineage.export(outfile, level, namespace_, name_='LI_Lineage', )
    def hasContent_(self):
        if (
            self.LI_Lineage is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LI_Lineage_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LI_Lineage is not None:
            showIndent(outfile, level)
            outfile.write('LI_Lineage=model_.LI_Lineage(\n')
            self.LI_Lineage.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LI_Lineage':
            obj_ = LI_Lineage_Type.factory()
            obj_.build(child_)
            self.set_LI_Lineage(obj_)
# end class LI_Lineage_PropertyType


class DQ_ConformanceResult_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_ConformanceResult=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_ConformanceResult = DQ_ConformanceResult
    def factory(*args_, **kwargs_):
        if DQ_ConformanceResult_PropertyType.subclass:
            return DQ_ConformanceResult_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_ConformanceResult_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_ConformanceResult(self): return self.DQ_ConformanceResult
    def set_DQ_ConformanceResult(self, DQ_ConformanceResult): self.DQ_ConformanceResult = DQ_ConformanceResult
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_ConformanceResult_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ConformanceResult_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_ConformanceResult_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_ConformanceResult_PropertyType', fromsubclass_=False):
        if self.DQ_ConformanceResult is not None:
            self.DQ_ConformanceResult.export(outfile, level, namespace_, name_='DQ_ConformanceResult', )
    def hasContent_(self):
        if (
            self.DQ_ConformanceResult is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_ConformanceResult_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_ConformanceResult is not None:
            showIndent(outfile, level)
            outfile.write('DQ_ConformanceResult=model_.DQ_ConformanceResult(\n')
            self.DQ_ConformanceResult.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_ConformanceResult':
            obj_ = DQ_ConformanceResult_Type.factory()
            obj_.build(child_)
            self.set_DQ_ConformanceResult(obj_)
# end class DQ_ConformanceResult_PropertyType


class DQ_QuantitativeResult_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_QuantitativeResult=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_QuantitativeResult = DQ_QuantitativeResult
    def factory(*args_, **kwargs_):
        if DQ_QuantitativeResult_PropertyType.subclass:
            return DQ_QuantitativeResult_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_QuantitativeResult_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_QuantitativeResult(self): return self.DQ_QuantitativeResult
    def set_DQ_QuantitativeResult(self, DQ_QuantitativeResult): self.DQ_QuantitativeResult = DQ_QuantitativeResult
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_QuantitativeResult_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_QuantitativeResult_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_QuantitativeResult_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_QuantitativeResult_PropertyType', fromsubclass_=False):
        if self.DQ_QuantitativeResult is not None:
            self.DQ_QuantitativeResult.export(outfile, level, namespace_, name_='DQ_QuantitativeResult', )
    def hasContent_(self):
        if (
            self.DQ_QuantitativeResult is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_QuantitativeResult_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_QuantitativeResult is not None:
            showIndent(outfile, level)
            outfile.write('DQ_QuantitativeResult=model_.DQ_QuantitativeResult(\n')
            self.DQ_QuantitativeResult.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_QuantitativeResult':
            obj_ = DQ_QuantitativeResult_Type.factory()
            obj_.build(child_)
            self.set_DQ_QuantitativeResult(obj_)
# end class DQ_QuantitativeResult_PropertyType


class AbstractDQ_Result_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extensiontype_=None):
        super(AbstractDQ_Result_Type, self).__init__(id, uuid, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDQ_Result_Type.subclass:
            return AbstractDQ_Result_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_Result_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDQ_Result_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Result_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDQ_Result_Type'):
        super(AbstractDQ_Result_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Result_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDQ_Result_Type', fromsubclass_=False):
        super(AbstractDQ_Result_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(AbstractDQ_Result_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDQ_Result_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDQ_Result_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDQ_Result_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_Result_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_Result_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_Result_Type


class DQ_Result_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDQ_Result=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_Result = AbstractDQ_Result
    def factory(*args_, **kwargs_):
        if DQ_Result_PropertyType.subclass:
            return DQ_Result_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_Result_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_Result(self): return self.AbstractDQ_Result
    def set_AbstractDQ_Result(self, AbstractDQ_Result): self.AbstractDQ_Result = AbstractDQ_Result
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_Result_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_Result_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_Result_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_Result_PropertyType', fromsubclass_=False):
        if self.AbstractDQ_Result is not None:
            self.AbstractDQ_Result.export(outfile, level, namespace_, name_='AbstractDQ_Result')
    def hasContent_(self):
        if (
            self.AbstractDQ_Result is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_Result_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_Result is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_Result=model_.AbstractDQ_Result(\n')
            self.AbstractDQ_Result.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_Result':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_Result> element')
            self.set_AbstractDQ_Result(obj_)
# end class DQ_Result_PropertyType


class DQ_TemporalValidity_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_TemporalValidity=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_TemporalValidity = DQ_TemporalValidity
    def factory(*args_, **kwargs_):
        if DQ_TemporalValidity_PropertyType.subclass:
            return DQ_TemporalValidity_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_TemporalValidity_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_TemporalValidity(self): return self.DQ_TemporalValidity
    def set_DQ_TemporalValidity(self, DQ_TemporalValidity): self.DQ_TemporalValidity = DQ_TemporalValidity
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_TemporalValidity_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TemporalValidity_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_TemporalValidity_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_TemporalValidity_PropertyType', fromsubclass_=False):
        if self.DQ_TemporalValidity is not None:
            self.DQ_TemporalValidity.export(outfile, level, namespace_, name_='DQ_TemporalValidity', )
    def hasContent_(self):
        if (
            self.DQ_TemporalValidity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_TemporalValidity_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_TemporalValidity is not None:
            showIndent(outfile, level)
            outfile.write('DQ_TemporalValidity=model_.DQ_TemporalValidity(\n')
            self.DQ_TemporalValidity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_TemporalValidity':
            obj_ = DQ_TemporalValidity_Type.factory()
            obj_.build(child_)
            self.set_DQ_TemporalValidity(obj_)
# end class DQ_TemporalValidity_PropertyType


class DQ_TemporalConsistency_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_TemporalConsistency=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_TemporalConsistency = DQ_TemporalConsistency
    def factory(*args_, **kwargs_):
        if DQ_TemporalConsistency_PropertyType.subclass:
            return DQ_TemporalConsistency_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_TemporalConsistency_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_TemporalConsistency(self): return self.DQ_TemporalConsistency
    def set_DQ_TemporalConsistency(self, DQ_TemporalConsistency): self.DQ_TemporalConsistency = DQ_TemporalConsistency
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_TemporalConsistency_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TemporalConsistency_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_TemporalConsistency_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_TemporalConsistency_PropertyType', fromsubclass_=False):
        if self.DQ_TemporalConsistency is not None:
            self.DQ_TemporalConsistency.export(outfile, level, namespace_, name_='DQ_TemporalConsistency', )
    def hasContent_(self):
        if (
            self.DQ_TemporalConsistency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_TemporalConsistency_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_TemporalConsistency is not None:
            showIndent(outfile, level)
            outfile.write('DQ_TemporalConsistency=model_.DQ_TemporalConsistency(\n')
            self.DQ_TemporalConsistency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_TemporalConsistency':
            obj_ = DQ_TemporalConsistency_Type.factory()
            obj_.build(child_)
            self.set_DQ_TemporalConsistency(obj_)
# end class DQ_TemporalConsistency_PropertyType


class DQ_AccuracyOfATimeMeasurement_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_AccuracyOfATimeMeasurement=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_AccuracyOfATimeMeasurement = DQ_AccuracyOfATimeMeasurement
    def factory(*args_, **kwargs_):
        if DQ_AccuracyOfATimeMeasurement_PropertyType.subclass:
            return DQ_AccuracyOfATimeMeasurement_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_AccuracyOfATimeMeasurement_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_AccuracyOfATimeMeasurement(self): return self.DQ_AccuracyOfATimeMeasurement
    def set_DQ_AccuracyOfATimeMeasurement(self, DQ_AccuracyOfATimeMeasurement): self.DQ_AccuracyOfATimeMeasurement = DQ_AccuracyOfATimeMeasurement
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_AccuracyOfATimeMeasurement_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_AccuracyOfATimeMeasurement_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_AccuracyOfATimeMeasurement_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_AccuracyOfATimeMeasurement_PropertyType', fromsubclass_=False):
        if self.DQ_AccuracyOfATimeMeasurement is not None:
            self.DQ_AccuracyOfATimeMeasurement.export(outfile, level, namespace_, name_='DQ_AccuracyOfATimeMeasurement', )
    def hasContent_(self):
        if (
            self.DQ_AccuracyOfATimeMeasurement is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_AccuracyOfATimeMeasurement_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_AccuracyOfATimeMeasurement is not None:
            showIndent(outfile, level)
            outfile.write('DQ_AccuracyOfATimeMeasurement=model_.DQ_AccuracyOfATimeMeasurement(\n')
            self.DQ_AccuracyOfATimeMeasurement.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_AccuracyOfATimeMeasurement':
            obj_ = DQ_AccuracyOfATimeMeasurement_Type.factory()
            obj_.build(child_)
            self.set_DQ_AccuracyOfATimeMeasurement(obj_)
# end class DQ_AccuracyOfATimeMeasurement_PropertyType


class DQ_QuantitativeAttributeAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_QuantitativeAttributeAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_QuantitativeAttributeAccuracy = DQ_QuantitativeAttributeAccuracy
    def factory(*args_, **kwargs_):
        if DQ_QuantitativeAttributeAccuracy_PropertyType.subclass:
            return DQ_QuantitativeAttributeAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_QuantitativeAttributeAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_QuantitativeAttributeAccuracy(self): return self.DQ_QuantitativeAttributeAccuracy
    def set_DQ_QuantitativeAttributeAccuracy(self, DQ_QuantitativeAttributeAccuracy): self.DQ_QuantitativeAttributeAccuracy = DQ_QuantitativeAttributeAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_QuantitativeAttributeAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_QuantitativeAttributeAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_QuantitativeAttributeAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_QuantitativeAttributeAccuracy_PropertyType', fromsubclass_=False):
        if self.DQ_QuantitativeAttributeAccuracy is not None:
            self.DQ_QuantitativeAttributeAccuracy.export(outfile, level, namespace_, name_='DQ_QuantitativeAttributeAccuracy', )
    def hasContent_(self):
        if (
            self.DQ_QuantitativeAttributeAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_QuantitativeAttributeAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_QuantitativeAttributeAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('DQ_QuantitativeAttributeAccuracy=model_.DQ_QuantitativeAttributeAccuracy(\n')
            self.DQ_QuantitativeAttributeAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_QuantitativeAttributeAccuracy':
            obj_ = DQ_QuantitativeAttributeAccuracy_Type.factory()
            obj_.build(child_)
            self.set_DQ_QuantitativeAttributeAccuracy(obj_)
# end class DQ_QuantitativeAttributeAccuracy_PropertyType


class DQ_NonQuantitativeAttributeAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_NonQuantitativeAttributeAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_NonQuantitativeAttributeAccuracy = DQ_NonQuantitativeAttributeAccuracy
    def factory(*args_, **kwargs_):
        if DQ_NonQuantitativeAttributeAccuracy_PropertyType.subclass:
            return DQ_NonQuantitativeAttributeAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_NonQuantitativeAttributeAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_NonQuantitativeAttributeAccuracy(self): return self.DQ_NonQuantitativeAttributeAccuracy
    def set_DQ_NonQuantitativeAttributeAccuracy(self, DQ_NonQuantitativeAttributeAccuracy): self.DQ_NonQuantitativeAttributeAccuracy = DQ_NonQuantitativeAttributeAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_NonQuantitativeAttributeAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_NonQuantitativeAttributeAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_NonQuantitativeAttributeAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_NonQuantitativeAttributeAccuracy_PropertyType', fromsubclass_=False):
        if self.DQ_NonQuantitativeAttributeAccuracy is not None:
            self.DQ_NonQuantitativeAttributeAccuracy.export(outfile, level, namespace_, name_='DQ_NonQuantitativeAttributeAccuracy', )
    def hasContent_(self):
        if (
            self.DQ_NonQuantitativeAttributeAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_NonQuantitativeAttributeAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_NonQuantitativeAttributeAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('DQ_NonQuantitativeAttributeAccuracy=model_.DQ_NonQuantitativeAttributeAccuracy(\n')
            self.DQ_NonQuantitativeAttributeAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_NonQuantitativeAttributeAccuracy':
            obj_ = DQ_NonQuantitativeAttributeAccuracy_Type.factory()
            obj_.build(child_)
            self.set_DQ_NonQuantitativeAttributeAccuracy(obj_)
# end class DQ_NonQuantitativeAttributeAccuracy_PropertyType


class DQ_ThematicClassificationCorrectness_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_ThematicClassificationCorrectness=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_ThematicClassificationCorrectness = DQ_ThematicClassificationCorrectness
    def factory(*args_, **kwargs_):
        if DQ_ThematicClassificationCorrectness_PropertyType.subclass:
            return DQ_ThematicClassificationCorrectness_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_ThematicClassificationCorrectness_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_ThematicClassificationCorrectness(self): return self.DQ_ThematicClassificationCorrectness
    def set_DQ_ThematicClassificationCorrectness(self, DQ_ThematicClassificationCorrectness): self.DQ_ThematicClassificationCorrectness = DQ_ThematicClassificationCorrectness
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_ThematicClassificationCorrectness_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ThematicClassificationCorrectness_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_ThematicClassificationCorrectness_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_ThematicClassificationCorrectness_PropertyType', fromsubclass_=False):
        if self.DQ_ThematicClassificationCorrectness is not None:
            self.DQ_ThematicClassificationCorrectness.export(outfile, level, namespace_, name_='DQ_ThematicClassificationCorrectness', )
    def hasContent_(self):
        if (
            self.DQ_ThematicClassificationCorrectness is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_ThematicClassificationCorrectness_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_ThematicClassificationCorrectness is not None:
            showIndent(outfile, level)
            outfile.write('DQ_ThematicClassificationCorrectness=model_.DQ_ThematicClassificationCorrectness(\n')
            self.DQ_ThematicClassificationCorrectness.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_ThematicClassificationCorrectness':
            obj_ = DQ_ThematicClassificationCorrectness_Type.factory()
            obj_.build(child_)
            self.set_DQ_ThematicClassificationCorrectness(obj_)
# end class DQ_ThematicClassificationCorrectness_PropertyType


class DQ_RelativeInternalPositionalAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_RelativeInternalPositionalAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_RelativeInternalPositionalAccuracy = DQ_RelativeInternalPositionalAccuracy
    def factory(*args_, **kwargs_):
        if DQ_RelativeInternalPositionalAccuracy_PropertyType.subclass:
            return DQ_RelativeInternalPositionalAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_RelativeInternalPositionalAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_RelativeInternalPositionalAccuracy(self): return self.DQ_RelativeInternalPositionalAccuracy
    def set_DQ_RelativeInternalPositionalAccuracy(self, DQ_RelativeInternalPositionalAccuracy): self.DQ_RelativeInternalPositionalAccuracy = DQ_RelativeInternalPositionalAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_RelativeInternalPositionalAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_RelativeInternalPositionalAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_RelativeInternalPositionalAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_RelativeInternalPositionalAccuracy_PropertyType', fromsubclass_=False):
        if self.DQ_RelativeInternalPositionalAccuracy is not None:
            self.DQ_RelativeInternalPositionalAccuracy.export(outfile, level, namespace_, name_='DQ_RelativeInternalPositionalAccuracy', )
    def hasContent_(self):
        if (
            self.DQ_RelativeInternalPositionalAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_RelativeInternalPositionalAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_RelativeInternalPositionalAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('DQ_RelativeInternalPositionalAccuracy=model_.DQ_RelativeInternalPositionalAccuracy(\n')
            self.DQ_RelativeInternalPositionalAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_RelativeInternalPositionalAccuracy':
            obj_ = DQ_RelativeInternalPositionalAccuracy_Type.factory()
            obj_.build(child_)
            self.set_DQ_RelativeInternalPositionalAccuracy(obj_)
# end class DQ_RelativeInternalPositionalAccuracy_PropertyType


class DQ_GriddedDataPositionalAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_GriddedDataPositionalAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_GriddedDataPositionalAccuracy = DQ_GriddedDataPositionalAccuracy
    def factory(*args_, **kwargs_):
        if DQ_GriddedDataPositionalAccuracy_PropertyType.subclass:
            return DQ_GriddedDataPositionalAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_GriddedDataPositionalAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_GriddedDataPositionalAccuracy(self): return self.DQ_GriddedDataPositionalAccuracy
    def set_DQ_GriddedDataPositionalAccuracy(self, DQ_GriddedDataPositionalAccuracy): self.DQ_GriddedDataPositionalAccuracy = DQ_GriddedDataPositionalAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_GriddedDataPositionalAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_GriddedDataPositionalAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_GriddedDataPositionalAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_GriddedDataPositionalAccuracy_PropertyType', fromsubclass_=False):
        if self.DQ_GriddedDataPositionalAccuracy is not None:
            self.DQ_GriddedDataPositionalAccuracy.export(outfile, level, namespace_, name_='DQ_GriddedDataPositionalAccuracy', )
    def hasContent_(self):
        if (
            self.DQ_GriddedDataPositionalAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_GriddedDataPositionalAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_GriddedDataPositionalAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('DQ_GriddedDataPositionalAccuracy=model_.DQ_GriddedDataPositionalAccuracy(\n')
            self.DQ_GriddedDataPositionalAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_GriddedDataPositionalAccuracy':
            obj_ = DQ_GriddedDataPositionalAccuracy_Type.factory()
            obj_.build(child_)
            self.set_DQ_GriddedDataPositionalAccuracy(obj_)
# end class DQ_GriddedDataPositionalAccuracy_PropertyType


class DQ_AbsoluteExternalPositionalAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_AbsoluteExternalPositionalAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_AbsoluteExternalPositionalAccuracy = DQ_AbsoluteExternalPositionalAccuracy
    def factory(*args_, **kwargs_):
        if DQ_AbsoluteExternalPositionalAccuracy_PropertyType.subclass:
            return DQ_AbsoluteExternalPositionalAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_AbsoluteExternalPositionalAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_AbsoluteExternalPositionalAccuracy(self): return self.DQ_AbsoluteExternalPositionalAccuracy
    def set_DQ_AbsoluteExternalPositionalAccuracy(self, DQ_AbsoluteExternalPositionalAccuracy): self.DQ_AbsoluteExternalPositionalAccuracy = DQ_AbsoluteExternalPositionalAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_AbsoluteExternalPositionalAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_AbsoluteExternalPositionalAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_AbsoluteExternalPositionalAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_AbsoluteExternalPositionalAccuracy_PropertyType', fromsubclass_=False):
        if self.DQ_AbsoluteExternalPositionalAccuracy is not None:
            self.DQ_AbsoluteExternalPositionalAccuracy.export(outfile, level, namespace_, name_='DQ_AbsoluteExternalPositionalAccuracy', )
    def hasContent_(self):
        if (
            self.DQ_AbsoluteExternalPositionalAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_AbsoluteExternalPositionalAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_AbsoluteExternalPositionalAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('DQ_AbsoluteExternalPositionalAccuracy=model_.DQ_AbsoluteExternalPositionalAccuracy(\n')
            self.DQ_AbsoluteExternalPositionalAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_AbsoluteExternalPositionalAccuracy':
            obj_ = DQ_AbsoluteExternalPositionalAccuracy_Type.factory()
            obj_.build(child_)
            self.set_DQ_AbsoluteExternalPositionalAccuracy(obj_)
# end class DQ_AbsoluteExternalPositionalAccuracy_PropertyType


class DQ_TopologicalConsistency_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_TopologicalConsistency=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_TopologicalConsistency = DQ_TopologicalConsistency
    def factory(*args_, **kwargs_):
        if DQ_TopologicalConsistency_PropertyType.subclass:
            return DQ_TopologicalConsistency_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_TopologicalConsistency_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_TopologicalConsistency(self): return self.DQ_TopologicalConsistency
    def set_DQ_TopologicalConsistency(self, DQ_TopologicalConsistency): self.DQ_TopologicalConsistency = DQ_TopologicalConsistency
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_TopologicalConsistency_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TopologicalConsistency_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_TopologicalConsistency_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_TopologicalConsistency_PropertyType', fromsubclass_=False):
        if self.DQ_TopologicalConsistency is not None:
            self.DQ_TopologicalConsistency.export(outfile, level, namespace_, name_='DQ_TopologicalConsistency', )
    def hasContent_(self):
        if (
            self.DQ_TopologicalConsistency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_TopologicalConsistency_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_TopologicalConsistency is not None:
            showIndent(outfile, level)
            outfile.write('DQ_TopologicalConsistency=model_.DQ_TopologicalConsistency(\n')
            self.DQ_TopologicalConsistency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_TopologicalConsistency':
            obj_ = DQ_TopologicalConsistency_Type.factory()
            obj_.build(child_)
            self.set_DQ_TopologicalConsistency(obj_)
# end class DQ_TopologicalConsistency_PropertyType


class DQ_FormatConsistency_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_FormatConsistency=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_FormatConsistency = DQ_FormatConsistency
    def factory(*args_, **kwargs_):
        if DQ_FormatConsistency_PropertyType.subclass:
            return DQ_FormatConsistency_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_FormatConsistency_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_FormatConsistency(self): return self.DQ_FormatConsistency
    def set_DQ_FormatConsistency(self, DQ_FormatConsistency): self.DQ_FormatConsistency = DQ_FormatConsistency
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_FormatConsistency_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_FormatConsistency_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_FormatConsistency_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_FormatConsistency_PropertyType', fromsubclass_=False):
        if self.DQ_FormatConsistency is not None:
            self.DQ_FormatConsistency.export(outfile, level, namespace_, name_='DQ_FormatConsistency', )
    def hasContent_(self):
        if (
            self.DQ_FormatConsistency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_FormatConsistency_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_FormatConsistency is not None:
            showIndent(outfile, level)
            outfile.write('DQ_FormatConsistency=model_.DQ_FormatConsistency(\n')
            self.DQ_FormatConsistency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_FormatConsistency':
            obj_ = DQ_FormatConsistency_Type.factory()
            obj_.build(child_)
            self.set_DQ_FormatConsistency(obj_)
# end class DQ_FormatConsistency_PropertyType


class DQ_DomainConsistency_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_DomainConsistency=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_DomainConsistency = DQ_DomainConsistency
    def factory(*args_, **kwargs_):
        if DQ_DomainConsistency_PropertyType.subclass:
            return DQ_DomainConsistency_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_DomainConsistency_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_DomainConsistency(self): return self.DQ_DomainConsistency
    def set_DQ_DomainConsistency(self, DQ_DomainConsistency): self.DQ_DomainConsistency = DQ_DomainConsistency
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_DomainConsistency_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_DomainConsistency_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_DomainConsistency_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_DomainConsistency_PropertyType', fromsubclass_=False):
        if self.DQ_DomainConsistency is not None:
            self.DQ_DomainConsistency.export(outfile, level, namespace_, name_='DQ_DomainConsistency', )
    def hasContent_(self):
        if (
            self.DQ_DomainConsistency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_DomainConsistency_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_DomainConsistency is not None:
            showIndent(outfile, level)
            outfile.write('DQ_DomainConsistency=model_.DQ_DomainConsistency(\n')
            self.DQ_DomainConsistency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_DomainConsistency':
            obj_ = DQ_DomainConsistency_Type.factory()
            obj_.build(child_)
            self.set_DQ_DomainConsistency(obj_)
# end class DQ_DomainConsistency_PropertyType


class DQ_ConceptualConsistency_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_ConceptualConsistency=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_ConceptualConsistency = DQ_ConceptualConsistency
    def factory(*args_, **kwargs_):
        if DQ_ConceptualConsistency_PropertyType.subclass:
            return DQ_ConceptualConsistency_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_ConceptualConsistency_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_ConceptualConsistency(self): return self.DQ_ConceptualConsistency
    def set_DQ_ConceptualConsistency(self, DQ_ConceptualConsistency): self.DQ_ConceptualConsistency = DQ_ConceptualConsistency
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_ConceptualConsistency_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ConceptualConsistency_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_ConceptualConsistency_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_ConceptualConsistency_PropertyType', fromsubclass_=False):
        if self.DQ_ConceptualConsistency is not None:
            self.DQ_ConceptualConsistency.export(outfile, level, namespace_, name_='DQ_ConceptualConsistency', )
    def hasContent_(self):
        if (
            self.DQ_ConceptualConsistency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_ConceptualConsistency_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_ConceptualConsistency is not None:
            showIndent(outfile, level)
            outfile.write('DQ_ConceptualConsistency=model_.DQ_ConceptualConsistency(\n')
            self.DQ_ConceptualConsistency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_ConceptualConsistency':
            obj_ = DQ_ConceptualConsistency_Type.factory()
            obj_.build(child_)
            self.set_DQ_ConceptualConsistency(obj_)
# end class DQ_ConceptualConsistency_PropertyType


class DQ_CompletenessOmission_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_CompletenessOmission=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_CompletenessOmission = DQ_CompletenessOmission
    def factory(*args_, **kwargs_):
        if DQ_CompletenessOmission_PropertyType.subclass:
            return DQ_CompletenessOmission_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_CompletenessOmission_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_CompletenessOmission(self): return self.DQ_CompletenessOmission
    def set_DQ_CompletenessOmission(self, DQ_CompletenessOmission): self.DQ_CompletenessOmission = DQ_CompletenessOmission
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_CompletenessOmission_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_CompletenessOmission_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_CompletenessOmission_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_CompletenessOmission_PropertyType', fromsubclass_=False):
        if self.DQ_CompletenessOmission is not None:
            self.DQ_CompletenessOmission.export(outfile, level, namespace_, name_='DQ_CompletenessOmission', )
    def hasContent_(self):
        if (
            self.DQ_CompletenessOmission is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_CompletenessOmission_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_CompletenessOmission is not None:
            showIndent(outfile, level)
            outfile.write('DQ_CompletenessOmission=model_.DQ_CompletenessOmission(\n')
            self.DQ_CompletenessOmission.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_CompletenessOmission':
            obj_ = DQ_CompletenessOmission_Type.factory()
            obj_.build(child_)
            self.set_DQ_CompletenessOmission(obj_)
# end class DQ_CompletenessOmission_PropertyType


class DQ_CompletenessCommission_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_CompletenessCommission=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_CompletenessCommission = DQ_CompletenessCommission
    def factory(*args_, **kwargs_):
        if DQ_CompletenessCommission_PropertyType.subclass:
            return DQ_CompletenessCommission_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_CompletenessCommission_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_CompletenessCommission(self): return self.DQ_CompletenessCommission
    def set_DQ_CompletenessCommission(self, DQ_CompletenessCommission): self.DQ_CompletenessCommission = DQ_CompletenessCommission
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_CompletenessCommission_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_CompletenessCommission_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_CompletenessCommission_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_CompletenessCommission_PropertyType', fromsubclass_=False):
        if self.DQ_CompletenessCommission is not None:
            self.DQ_CompletenessCommission.export(outfile, level, namespace_, name_='DQ_CompletenessCommission', )
    def hasContent_(self):
        if (
            self.DQ_CompletenessCommission is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_CompletenessCommission_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_CompletenessCommission is not None:
            showIndent(outfile, level)
            outfile.write('DQ_CompletenessCommission=model_.DQ_CompletenessCommission(\n')
            self.DQ_CompletenessCommission.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_CompletenessCommission':
            obj_ = DQ_CompletenessCommission_Type.factory()
            obj_.build(child_)
            self.set_DQ_CompletenessCommission(obj_)
# end class DQ_CompletenessCommission_PropertyType


class DQ_TemporalAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDQ_TemporalAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_TemporalAccuracy = AbstractDQ_TemporalAccuracy
    def factory(*args_, **kwargs_):
        if DQ_TemporalAccuracy_PropertyType.subclass:
            return DQ_TemporalAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_TemporalAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_TemporalAccuracy(self): return self.AbstractDQ_TemporalAccuracy
    def set_AbstractDQ_TemporalAccuracy(self, AbstractDQ_TemporalAccuracy): self.AbstractDQ_TemporalAccuracy = AbstractDQ_TemporalAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_TemporalAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TemporalAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_TemporalAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_TemporalAccuracy_PropertyType', fromsubclass_=False):
        if self.AbstractDQ_TemporalAccuracy is not None:
            self.AbstractDQ_TemporalAccuracy.export(outfile, level, namespace_, name_='AbstractDQ_TemporalAccuracy')
    def hasContent_(self):
        if (
            self.AbstractDQ_TemporalAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_TemporalAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_TemporalAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_TemporalAccuracy=model_.AbstractDQ_TemporalAccuracy(\n')
            self.AbstractDQ_TemporalAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_TemporalAccuracy':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_TemporalAccuracy> element')
            self.set_AbstractDQ_TemporalAccuracy(obj_)
# end class DQ_TemporalAccuracy_PropertyType


class DQ_ThematicAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDQ_ThematicAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_ThematicAccuracy = AbstractDQ_ThematicAccuracy
    def factory(*args_, **kwargs_):
        if DQ_ThematicAccuracy_PropertyType.subclass:
            return DQ_ThematicAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_ThematicAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_ThematicAccuracy(self): return self.AbstractDQ_ThematicAccuracy
    def set_AbstractDQ_ThematicAccuracy(self, AbstractDQ_ThematicAccuracy): self.AbstractDQ_ThematicAccuracy = AbstractDQ_ThematicAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_ThematicAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ThematicAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_ThematicAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_ThematicAccuracy_PropertyType', fromsubclass_=False):
        if self.AbstractDQ_ThematicAccuracy is not None:
            self.AbstractDQ_ThematicAccuracy.export(outfile, level, namespace_, name_='AbstractDQ_ThematicAccuracy')
    def hasContent_(self):
        if (
            self.AbstractDQ_ThematicAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_ThematicAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_ThematicAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_ThematicAccuracy=model_.AbstractDQ_ThematicAccuracy(\n')
            self.AbstractDQ_ThematicAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_ThematicAccuracy':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_ThematicAccuracy> element')
            self.set_AbstractDQ_ThematicAccuracy(obj_)
# end class DQ_ThematicAccuracy_PropertyType


class DQ_PositionalAccuracy_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDQ_PositionalAccuracy=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_PositionalAccuracy = AbstractDQ_PositionalAccuracy
    def factory(*args_, **kwargs_):
        if DQ_PositionalAccuracy_PropertyType.subclass:
            return DQ_PositionalAccuracy_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_PositionalAccuracy_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_PositionalAccuracy(self): return self.AbstractDQ_PositionalAccuracy
    def set_AbstractDQ_PositionalAccuracy(self, AbstractDQ_PositionalAccuracy): self.AbstractDQ_PositionalAccuracy = AbstractDQ_PositionalAccuracy
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_PositionalAccuracy_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_PositionalAccuracy_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_PositionalAccuracy_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_PositionalAccuracy_PropertyType', fromsubclass_=False):
        if self.AbstractDQ_PositionalAccuracy is not None:
            self.AbstractDQ_PositionalAccuracy.export(outfile, level, namespace_, name_='AbstractDQ_PositionalAccuracy')
    def hasContent_(self):
        if (
            self.AbstractDQ_PositionalAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_PositionalAccuracy_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_PositionalAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_PositionalAccuracy=model_.AbstractDQ_PositionalAccuracy(\n')
            self.AbstractDQ_PositionalAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_PositionalAccuracy':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_PositionalAccuracy> element')
            self.set_AbstractDQ_PositionalAccuracy(obj_)
# end class DQ_PositionalAccuracy_PropertyType


class DQ_LogicalConsistency_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDQ_LogicalConsistency=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_LogicalConsistency = AbstractDQ_LogicalConsistency
    def factory(*args_, **kwargs_):
        if DQ_LogicalConsistency_PropertyType.subclass:
            return DQ_LogicalConsistency_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_LogicalConsistency_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_LogicalConsistency(self): return self.AbstractDQ_LogicalConsistency
    def set_AbstractDQ_LogicalConsistency(self, AbstractDQ_LogicalConsistency): self.AbstractDQ_LogicalConsistency = AbstractDQ_LogicalConsistency
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_LogicalConsistency_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_LogicalConsistency_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_LogicalConsistency_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_LogicalConsistency_PropertyType', fromsubclass_=False):
        if self.AbstractDQ_LogicalConsistency is not None:
            self.AbstractDQ_LogicalConsistency.export(outfile, level, namespace_, name_='AbstractDQ_LogicalConsistency')
    def hasContent_(self):
        if (
            self.AbstractDQ_LogicalConsistency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_LogicalConsistency_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_LogicalConsistency is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_LogicalConsistency=model_.AbstractDQ_LogicalConsistency(\n')
            self.AbstractDQ_LogicalConsistency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_LogicalConsistency':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_LogicalConsistency> element')
            self.set_AbstractDQ_LogicalConsistency(obj_)
# end class DQ_LogicalConsistency_PropertyType


class DQ_Completeness_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDQ_Completeness=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_Completeness = AbstractDQ_Completeness
    def factory(*args_, **kwargs_):
        if DQ_Completeness_PropertyType.subclass:
            return DQ_Completeness_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_Completeness_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_Completeness(self): return self.AbstractDQ_Completeness
    def set_AbstractDQ_Completeness(self, AbstractDQ_Completeness): self.AbstractDQ_Completeness = AbstractDQ_Completeness
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_Completeness_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_Completeness_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_Completeness_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_Completeness_PropertyType', fromsubclass_=False):
        if self.AbstractDQ_Completeness is not None:
            self.AbstractDQ_Completeness.export(outfile, level, namespace_, name_='AbstractDQ_Completeness')
    def hasContent_(self):
        if (
            self.AbstractDQ_Completeness is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_Completeness_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_Completeness is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_Completeness=model_.AbstractDQ_Completeness(\n')
            self.AbstractDQ_Completeness.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_Completeness':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_Completeness> element')
            self.set_AbstractDQ_Completeness(obj_)
# end class DQ_Completeness_PropertyType


class AbstractDQ_Element_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None, extensiontype_=None):
        super(AbstractDQ_Element_Type, self).__init__(id, uuid, extensiontype_, )
        if nameOfMeasure is None:
            self.nameOfMeasure = []
        else:
            self.nameOfMeasure = nameOfMeasure
        self.measureIdentification = measureIdentification
        self.measureDescription = measureDescription
        self.evaluationMethodType = evaluationMethodType
        self.evaluationMethodDescription = evaluationMethodDescription
        self.evaluationProcedure = evaluationProcedure
        if dateTime is None:
            self.dateTime = []
        else:
            self.dateTime = dateTime
        if result is None:
            self.result = []
        else:
            self.result = result
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDQ_Element_Type.subclass:
            return AbstractDQ_Element_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_Element_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nameOfMeasure(self): return self.nameOfMeasure
    def set_nameOfMeasure(self, nameOfMeasure): self.nameOfMeasure = nameOfMeasure
    def add_nameOfMeasure(self, value): self.nameOfMeasure.append(value)
    def insert_nameOfMeasure(self, index, value): self.nameOfMeasure[index] = value
    def get_measureIdentification(self): return self.measureIdentification
    def set_measureIdentification(self, measureIdentification): self.measureIdentification = measureIdentification
    def get_measureDescription(self): return self.measureDescription
    def set_measureDescription(self, measureDescription): self.measureDescription = measureDescription
    def get_evaluationMethodType(self): return self.evaluationMethodType
    def set_evaluationMethodType(self, evaluationMethodType): self.evaluationMethodType = evaluationMethodType
    def get_evaluationMethodDescription(self): return self.evaluationMethodDescription
    def set_evaluationMethodDescription(self, evaluationMethodDescription): self.evaluationMethodDescription = evaluationMethodDescription
    def get_evaluationProcedure(self): return self.evaluationProcedure
    def set_evaluationProcedure(self, evaluationProcedure): self.evaluationProcedure = evaluationProcedure
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def add_dateTime(self, value): self.dateTime.append(value)
    def insert_dateTime(self, index, value): self.dateTime[index] = value
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def add_result(self, value): self.result.append(value)
    def insert_result(self, index, value): self.result[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDQ_Element_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Element_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDQ_Element_Type'):
        super(AbstractDQ_Element_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Element_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDQ_Element_Type', fromsubclass_=False):
        super(AbstractDQ_Element_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for nameOfMeasure_ in self.nameOfMeasure:
            nameOfMeasure_.export(outfile, level, namespace_, name_='nameOfMeasure')
        if self.measureIdentification is not None:
            self.measureIdentification.export(outfile, level, namespace_, name_='measureIdentification')
        if self.measureDescription is not None:
            self.measureDescription.export(outfile, level, namespace_, name_='measureDescription')
        if self.evaluationMethodType is not None:
            self.evaluationMethodType.export(outfile, level, namespace_, name_='evaluationMethodType')
        if self.evaluationMethodDescription is not None:
            self.evaluationMethodDescription.export(outfile, level, namespace_, name_='evaluationMethodDescription')
        if self.evaluationProcedure is not None:
            self.evaluationProcedure.export(outfile, level, namespace_, name_='evaluationProcedure')
        for dateTime_ in self.dateTime:
            dateTime_.export(outfile, level, namespace_, name_='dateTime')
        for result_ in self.result:
            result_.export(outfile, level, namespace_, name_='result')
    def hasContent_(self):
        if (
            self.nameOfMeasure or
            self.measureIdentification is not None or
            self.measureDescription is not None or
            self.evaluationMethodType is not None or
            self.evaluationMethodDescription is not None or
            self.evaluationProcedure is not None or
            self.dateTime or
            self.result or
            super(AbstractDQ_Element_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDQ_Element_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDQ_Element_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDQ_Element_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('nameOfMeasure=[\n')
        level += 1
        for nameOfMeasure_ in self.nameOfMeasure:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            nameOfMeasure_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.measureIdentification is not None:
            showIndent(outfile, level)
            outfile.write('measureIdentification=model_.MD_Identifier_PropertyType(\n')
            self.measureIdentification.exportLiteral(outfile, level, name_='measureIdentification')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.measureDescription is not None:
            showIndent(outfile, level)
            outfile.write('measureDescription=model_.CharacterString_PropertyType(\n')
            self.measureDescription.exportLiteral(outfile, level, name_='measureDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.evaluationMethodType is not None:
            showIndent(outfile, level)
            outfile.write('evaluationMethodType=model_.DQ_EvaluationMethodTypeCode_PropertyType(\n')
            self.evaluationMethodType.exportLiteral(outfile, level, name_='evaluationMethodType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.evaluationMethodDescription is not None:
            showIndent(outfile, level)
            outfile.write('evaluationMethodDescription=model_.CharacterString_PropertyType(\n')
            self.evaluationMethodDescription.exportLiteral(outfile, level, name_='evaluationMethodDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.evaluationProcedure is not None:
            showIndent(outfile, level)
            outfile.write('evaluationProcedure=model_.CI_Citation_PropertyType(\n')
            self.evaluationProcedure.exportLiteral(outfile, level, name_='evaluationProcedure')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('dateTime=[\n')
        level += 1
        for dateTime_ in self.dateTime:
            showIndent(outfile, level)
            outfile.write('model_.DateTime_PropertyType(\n')
            dateTime_.exportLiteral(outfile, level, name_='DateTime_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('result=[\n')
        level += 1
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('model_.DQ_Result_PropertyType(\n')
            result_.exportLiteral(outfile, level, name_='DQ_Result_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_Element_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nameOfMeasure':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.nameOfMeasure.append(obj_)
        elif nodeName_ == 'measureIdentification':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.set_measureIdentification(obj_)
        elif nodeName_ == 'measureDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_measureDescription(obj_)
        elif nodeName_ == 'evaluationMethodType':
            obj_ = DQ_EvaluationMethodTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_evaluationMethodType(obj_)
        elif nodeName_ == 'evaluationMethodDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_evaluationMethodDescription(obj_)
        elif nodeName_ == 'evaluationProcedure':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_evaluationProcedure(obj_)
        elif nodeName_ == 'dateTime':
            obj_ = DateTime_PropertyType.factory()
            obj_.build(child_)
            self.dateTime.append(obj_)
        elif nodeName_ == 'result':
            obj_ = DQ_Result_PropertyType.factory()
            obj_.build(child_)
            self.result.append(obj_)
        super(AbstractDQ_Element_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractDQ_Element_Type


class DQ_Element_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractDQ_Element=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractDQ_Element = AbstractDQ_Element
    def factory(*args_, **kwargs_):
        if DQ_Element_PropertyType.subclass:
            return DQ_Element_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_Element_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_Element(self): return self.AbstractDQ_Element
    def set_AbstractDQ_Element(self, AbstractDQ_Element): self.AbstractDQ_Element = AbstractDQ_Element
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_Element_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_Element_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_Element_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_Element_PropertyType', fromsubclass_=False):
        if self.AbstractDQ_Element is not None:
            self.AbstractDQ_Element.export(outfile, level, namespace_, name_='AbstractDQ_Element')
    def hasContent_(self):
        if (
            self.AbstractDQ_Element is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_Element_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_Element is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_Element=model_.AbstractDQ_Element(\n')
            self.AbstractDQ_Element.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_Element':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_Element> element')
            self.set_AbstractDQ_Element(obj_)
# end class DQ_Element_PropertyType


class DQ_DataQuality_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, scope=None, report=None, lineage=None):
        super(DQ_DataQuality_Type, self).__init__(id, uuid, )
        self.scope = scope
        if report is None:
            self.report = []
        else:
            self.report = report
        self.lineage = lineage
    def factory(*args_, **kwargs_):
        if DQ_DataQuality_Type.subclass:
            return DQ_DataQuality_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_DataQuality_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def get_report(self): return self.report
    def set_report(self, report): self.report = report
    def add_report(self, value): self.report.append(value)
    def insert_report(self, index, value): self.report[index] = value
    def get_lineage(self): return self.lineage
    def set_lineage(self, lineage): self.lineage = lineage
    def export(self, outfile, level, namespace_='', name_='DQ_DataQuality_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_DataQuality_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_DataQuality_Type'):
        super(DQ_DataQuality_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_DataQuality_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_DataQuality_Type', fromsubclass_=False):
        super(DQ_DataQuality_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.scope is not None:
            self.scope.export(outfile, level, namespace_, name_='scope', )
        for report_ in self.report:
            report_.export(outfile, level, namespace_, name_='report')
        if self.lineage is not None:
            self.lineage.export(outfile, level, namespace_, name_='lineage')
    def hasContent_(self):
        if (
            self.scope is not None or
            self.report or
            self.lineage is not None or
            super(DQ_DataQuality_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_DataQuality_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_DataQuality_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_DataQuality_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.scope is not None:
            showIndent(outfile, level)
            outfile.write('scope=model_.DQ_Scope_PropertyType(\n')
            self.scope.exportLiteral(outfile, level, name_='scope')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('report=[\n')
        level += 1
        for report_ in self.report:
            showIndent(outfile, level)
            outfile.write('model_.DQ_Element_PropertyType(\n')
            report_.exportLiteral(outfile, level, name_='DQ_Element_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.lineage is not None:
            showIndent(outfile, level)
            outfile.write('lineage=model_.LI_Lineage_PropertyType(\n')
            self.lineage.exportLiteral(outfile, level, name_='lineage')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_DataQuality_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scope':
            obj_ = DQ_Scope_PropertyType.factory()
            obj_.build(child_)
            self.set_scope(obj_)
        elif nodeName_ == 'report':
            obj_ = DQ_Element_PropertyType.factory()
            obj_.build(child_)
            self.report.append(obj_)
        elif nodeName_ == 'lineage':
            obj_ = LI_Lineage_PropertyType.factory()
            obj_.build(child_)
            self.set_lineage(obj_)
        super(DQ_DataQuality_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DQ_DataQuality_Type


class DQ_DataQuality_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_DataQuality=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_DataQuality = DQ_DataQuality
    def factory(*args_, **kwargs_):
        if DQ_DataQuality_PropertyType.subclass:
            return DQ_DataQuality_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_DataQuality_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_DataQuality(self): return self.DQ_DataQuality
    def set_DQ_DataQuality(self, DQ_DataQuality): self.DQ_DataQuality = DQ_DataQuality
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_DataQuality_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_DataQuality_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_DataQuality_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_DataQuality_PropertyType', fromsubclass_=False):
        if self.DQ_DataQuality is not None:
            self.DQ_DataQuality.export(outfile, level, namespace_, name_='DQ_DataQuality', )
    def hasContent_(self):
        if (
            self.DQ_DataQuality is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_DataQuality_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_DataQuality is not None:
            showIndent(outfile, level)
            outfile.write('DQ_DataQuality=model_.DQ_DataQuality(\n')
            self.DQ_DataQuality.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_DataQuality':
            obj_ = DQ_DataQuality_Type.factory()
            obj_.build(child_)
            self.set_DQ_DataQuality(obj_)
# end class DQ_DataQuality_PropertyType


class DQ_Scope_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, level=None, extent=None, levelDescription=None):
        super(DQ_Scope_Type, self).__init__(id, uuid, )
        self.level = level
        self.extent = extent
        if levelDescription is None:
            self.levelDescription = []
        else:
            self.levelDescription = levelDescription
    def factory(*args_, **kwargs_):
        if DQ_Scope_Type.subclass:
            return DQ_Scope_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_Scope_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    def get_levelDescription(self): return self.levelDescription
    def set_levelDescription(self, levelDescription): self.levelDescription = levelDescription
    def add_levelDescription(self, value): self.levelDescription.append(value)
    def insert_levelDescription(self, index, value): self.levelDescription[index] = value
    def export(self, outfile, level, namespace_='', name_='DQ_Scope_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_Scope_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_Scope_Type'):
        super(DQ_Scope_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_Scope_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_Scope_Type', fromsubclass_=False):
        super(DQ_Scope_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.level is not None:
            self.level.export(outfile, level, namespace_, name_='level', )
        if self.extent is not None:
            self.extent.export(outfile, level, namespace_, name_='extent')
        for levelDescription_ in self.levelDescription:
            levelDescription_.export(outfile, level, namespace_, name_='levelDescription')
    def hasContent_(self):
        if (
            self.level is not None or
            self.extent is not None or
            self.levelDescription or
            super(DQ_Scope_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_Scope_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_Scope_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_Scope_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.level is not None:
            showIndent(outfile, level)
            outfile.write('level=model_.MD_ScopeCode_PropertyType(\n')
            self.level.exportLiteral(outfile, level, name_='level')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extent is not None:
            showIndent(outfile, level)
            outfile.write('extent=model_.EX_Extent_PropertyType(\n')
            self.extent.exportLiteral(outfile, level, name_='extent')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('levelDescription=[\n')
        level += 1
        for levelDescription_ in self.levelDescription:
            showIndent(outfile, level)
            outfile.write('model_.MD_ScopeDescription_PropertyType(\n')
            levelDescription_.exportLiteral(outfile, level, name_='MD_ScopeDescription_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_Scope_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'level':
            obj_ = MD_ScopeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_level(obj_)
        elif nodeName_ == 'extent':
            obj_ = EX_Extent_PropertyType.factory()
            obj_.build(child_)
            self.set_extent(obj_)
        elif nodeName_ == 'levelDescription':
            obj_ = MD_ScopeDescription_PropertyType.factory()
            obj_.build(child_)
            self.levelDescription.append(obj_)
        super(DQ_Scope_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DQ_Scope_Type


class DQ_Scope_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_Scope=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_Scope = DQ_Scope
    def factory(*args_, **kwargs_):
        if DQ_Scope_PropertyType.subclass:
            return DQ_Scope_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_Scope_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_Scope(self): return self.DQ_Scope
    def set_DQ_Scope(self, DQ_Scope): self.DQ_Scope = DQ_Scope
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_Scope_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_Scope_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_Scope_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_Scope_PropertyType', fromsubclass_=False):
        if self.DQ_Scope is not None:
            self.DQ_Scope.export(outfile, level, namespace_, name_='DQ_Scope', )
    def hasContent_(self):
        if (
            self.DQ_Scope is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_Scope_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_Scope is not None:
            showIndent(outfile, level)
            outfile.write('DQ_Scope=model_.DQ_Scope(\n')
            self.DQ_Scope.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_Scope':
            obj_ = DQ_Scope_Type.factory()
            obj_.build(child_)
            self.set_DQ_Scope(obj_)
# end class DQ_Scope_PropertyType


class DQ_EvaluationMethodTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DQ_EvaluationMethodTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.DQ_EvaluationMethodTypeCode = DQ_EvaluationMethodTypeCode
    def factory(*args_, **kwargs_):
        if DQ_EvaluationMethodTypeCode_PropertyType.subclass:
            return DQ_EvaluationMethodTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DQ_EvaluationMethodTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DQ_EvaluationMethodTypeCode(self): return self.DQ_EvaluationMethodTypeCode
    def set_DQ_EvaluationMethodTypeCode(self, DQ_EvaluationMethodTypeCode): self.DQ_EvaluationMethodTypeCode = DQ_EvaluationMethodTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DQ_EvaluationMethodTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_EvaluationMethodTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_EvaluationMethodTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_EvaluationMethodTypeCode_PropertyType', fromsubclass_=False):
        if self.DQ_EvaluationMethodTypeCode is not None:
            self.DQ_EvaluationMethodTypeCode.export(outfile, level, namespace_, name_='DQ_EvaluationMethodTypeCode', )
    def hasContent_(self):
        if (
            self.DQ_EvaluationMethodTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_EvaluationMethodTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DQ_EvaluationMethodTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('DQ_EvaluationMethodTypeCode=model_.DQ_EvaluationMethodTypeCode(\n')
            self.DQ_EvaluationMethodTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DQ_EvaluationMethodTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_DQ_EvaluationMethodTypeCode(obj_)
# end class DQ_EvaluationMethodTypeCode_PropertyType


class AbstractMD_Identification_Type(AbstractObject_Type):
    """Basic information about data"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, citation=None, abstract=None, purpose=None, credit=None, status=None, pointOfContact=None, resourceMaintenance=None, graphicOverview=None, resourceFormat=None, descriptiveKeywords=None, resourceSpecificUsage=None, resourceConstraints=None, aggregationInfo=None, extensiontype_=None):
        super(AbstractMD_Identification_Type, self).__init__(id, uuid, extensiontype_, )
        self.citation = citation
        self.abstract = abstract
        self.purpose = purpose
        if credit is None:
            self.credit = []
        else:
            self.credit = credit
        if status is None:
            self.status = []
        else:
            self.status = status
        if pointOfContact is None:
            self.pointOfContact = []
        else:
            self.pointOfContact = pointOfContact
        if resourceMaintenance is None:
            self.resourceMaintenance = []
        else:
            self.resourceMaintenance = resourceMaintenance
        if graphicOverview is None:
            self.graphicOverview = []
        else:
            self.graphicOverview = graphicOverview
        if resourceFormat is None:
            self.resourceFormat = []
        else:
            self.resourceFormat = resourceFormat
        if descriptiveKeywords is None:
            self.descriptiveKeywords = []
        else:
            self.descriptiveKeywords = descriptiveKeywords
        if resourceSpecificUsage is None:
            self.resourceSpecificUsage = []
        else:
            self.resourceSpecificUsage = resourceSpecificUsage
        if resourceConstraints is None:
            self.resourceConstraints = []
        else:
            self.resourceConstraints = resourceConstraints
        if aggregationInfo is None:
            self.aggregationInfo = []
        else:
            self.aggregationInfo = aggregationInfo
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractMD_Identification_Type.subclass:
            return AbstractMD_Identification_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractMD_Identification_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_citation(self): return self.citation
    def set_citation(self, citation): self.citation = citation
    def get_abstract(self): return self.abstract
    def set_abstract(self, abstract): self.abstract = abstract
    def get_purpose(self): return self.purpose
    def set_purpose(self, purpose): self.purpose = purpose
    def get_credit(self): return self.credit
    def set_credit(self, credit): self.credit = credit
    def add_credit(self, value): self.credit.append(value)
    def insert_credit(self, index, value): self.credit[index] = value
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def add_status(self, value): self.status.append(value)
    def insert_status(self, index, value): self.status[index] = value
    def get_pointOfContact(self): return self.pointOfContact
    def set_pointOfContact(self, pointOfContact): self.pointOfContact = pointOfContact
    def add_pointOfContact(self, value): self.pointOfContact.append(value)
    def insert_pointOfContact(self, index, value): self.pointOfContact[index] = value
    def get_resourceMaintenance(self): return self.resourceMaintenance
    def set_resourceMaintenance(self, resourceMaintenance): self.resourceMaintenance = resourceMaintenance
    def add_resourceMaintenance(self, value): self.resourceMaintenance.append(value)
    def insert_resourceMaintenance(self, index, value): self.resourceMaintenance[index] = value
    def get_graphicOverview(self): return self.graphicOverview
    def set_graphicOverview(self, graphicOverview): self.graphicOverview = graphicOverview
    def add_graphicOverview(self, value): self.graphicOverview.append(value)
    def insert_graphicOverview(self, index, value): self.graphicOverview[index] = value
    def get_resourceFormat(self): return self.resourceFormat
    def set_resourceFormat(self, resourceFormat): self.resourceFormat = resourceFormat
    def add_resourceFormat(self, value): self.resourceFormat.append(value)
    def insert_resourceFormat(self, index, value): self.resourceFormat[index] = value
    def get_descriptiveKeywords(self): return self.descriptiveKeywords
    def set_descriptiveKeywords(self, descriptiveKeywords): self.descriptiveKeywords = descriptiveKeywords
    def add_descriptiveKeywords(self, value): self.descriptiveKeywords.append(value)
    def insert_descriptiveKeywords(self, index, value): self.descriptiveKeywords[index] = value
    def get_resourceSpecificUsage(self): return self.resourceSpecificUsage
    def set_resourceSpecificUsage(self, resourceSpecificUsage): self.resourceSpecificUsage = resourceSpecificUsage
    def add_resourceSpecificUsage(self, value): self.resourceSpecificUsage.append(value)
    def insert_resourceSpecificUsage(self, index, value): self.resourceSpecificUsage[index] = value
    def get_resourceConstraints(self): return self.resourceConstraints
    def set_resourceConstraints(self, resourceConstraints): self.resourceConstraints = resourceConstraints
    def add_resourceConstraints(self, value): self.resourceConstraints.append(value)
    def insert_resourceConstraints(self, index, value): self.resourceConstraints[index] = value
    def get_aggregationInfo(self): return self.aggregationInfo
    def set_aggregationInfo(self, aggregationInfo): self.aggregationInfo = aggregationInfo
    def add_aggregationInfo(self, value): self.aggregationInfo.append(value)
    def insert_aggregationInfo(self, index, value): self.aggregationInfo[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractMD_Identification_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMD_Identification_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractMD_Identification_Type'):
        super(AbstractMD_Identification_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMD_Identification_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractMD_Identification_Type', fromsubclass_=False):
        super(AbstractMD_Identification_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.citation is not None:
            self.citation.export(outfile, level, namespace_, name_='citation', )
        if self.abstract is not None:
            self.abstract.export(outfile, level, namespace_, name_='abstract', )
        if self.purpose is not None:
            self.purpose.export(outfile, level, namespace_, name_='purpose')
        for credit_ in self.credit:
            credit_.export(outfile, level, namespace_, name_='credit')
        for status_ in self.status:
            status_.export(outfile, level, namespace_, name_='status')
        for pointOfContact_ in self.pointOfContact:
            pointOfContact_.export(outfile, level, namespace_, name_='pointOfContact')
        for resourceMaintenance_ in self.resourceMaintenance:
            resourceMaintenance_.export(outfile, level, namespace_, name_='resourceMaintenance')
        for graphicOverview_ in self.graphicOverview:
            graphicOverview_.export(outfile, level, namespace_, name_='graphicOverview')
        for resourceFormat_ in self.resourceFormat:
            resourceFormat_.export(outfile, level, namespace_, name_='resourceFormat')
        for descriptiveKeywords_ in self.descriptiveKeywords:
            descriptiveKeywords_.export(outfile, level, namespace_, name_='descriptiveKeywords')
        for resourceSpecificUsage_ in self.resourceSpecificUsage:
            resourceSpecificUsage_.export(outfile, level, namespace_, name_='resourceSpecificUsage')
        for resourceConstraints_ in self.resourceConstraints:
            resourceConstraints_.export(outfile, level, namespace_, name_='resourceConstraints')
        for aggregationInfo_ in self.aggregationInfo:
            aggregationInfo_.export(outfile, level, namespace_, name_='aggregationInfo')
    def hasContent_(self):
        if (
            self.citation is not None or
            self.abstract is not None or
            self.purpose is not None or
            self.credit or
            self.status or
            self.pointOfContact or
            self.resourceMaintenance or
            self.graphicOverview or
            self.resourceFormat or
            self.descriptiveKeywords or
            self.resourceSpecificUsage or
            self.resourceConstraints or
            self.aggregationInfo or
            super(AbstractMD_Identification_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractMD_Identification_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractMD_Identification_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractMD_Identification_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.citation is not None:
            showIndent(outfile, level)
            outfile.write('citation=model_.CI_Citation_PropertyType(\n')
            self.citation.exportLiteral(outfile, level, name_='citation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.abstract is not None:
            showIndent(outfile, level)
            outfile.write('abstract=model_.CharacterString_PropertyType(\n')
            self.abstract.exportLiteral(outfile, level, name_='abstract')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.purpose is not None:
            showIndent(outfile, level)
            outfile.write('purpose=model_.CharacterString_PropertyType(\n')
            self.purpose.exportLiteral(outfile, level, name_='purpose')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('credit=[\n')
        level += 1
        for credit_ in self.credit:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            credit_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('status=[\n')
        level += 1
        for status_ in self.status:
            showIndent(outfile, level)
            outfile.write('model_.MD_ProgressCode_PropertyType(\n')
            status_.exportLiteral(outfile, level, name_='MD_ProgressCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointOfContact=[\n')
        level += 1
        for pointOfContact_ in self.pointOfContact:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            pointOfContact_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resourceMaintenance=[\n')
        level += 1
        for resourceMaintenance_ in self.resourceMaintenance:
            showIndent(outfile, level)
            outfile.write('model_.MD_MaintenanceInformation_PropertyType(\n')
            resourceMaintenance_.exportLiteral(outfile, level, name_='MD_MaintenanceInformation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('graphicOverview=[\n')
        level += 1
        for graphicOverview_ in self.graphicOverview:
            showIndent(outfile, level)
            outfile.write('model_.MD_BrowseGraphic_PropertyType(\n')
            graphicOverview_.exportLiteral(outfile, level, name_='MD_BrowseGraphic_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resourceFormat=[\n')
        level += 1
        for resourceFormat_ in self.resourceFormat:
            showIndent(outfile, level)
            outfile.write('model_.MD_Format_PropertyType(\n')
            resourceFormat_.exportLiteral(outfile, level, name_='MD_Format_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('descriptiveKeywords=[\n')
        level += 1
        for descriptiveKeywords_ in self.descriptiveKeywords:
            showIndent(outfile, level)
            outfile.write('model_.MD_Keywords_PropertyType(\n')
            descriptiveKeywords_.exportLiteral(outfile, level, name_='MD_Keywords_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resourceSpecificUsage=[\n')
        level += 1
        for resourceSpecificUsage_ in self.resourceSpecificUsage:
            showIndent(outfile, level)
            outfile.write('model_.MD_Usage_PropertyType(\n')
            resourceSpecificUsage_.exportLiteral(outfile, level, name_='MD_Usage_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resourceConstraints=[\n')
        level += 1
        for resourceConstraints_ in self.resourceConstraints:
            showIndent(outfile, level)
            outfile.write('model_.MD_Constraints_PropertyType(\n')
            resourceConstraints_.exportLiteral(outfile, level, name_='MD_Constraints_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('aggregationInfo=[\n')
        level += 1
        for aggregationInfo_ in self.aggregationInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_AggregateInformation_PropertyType(\n')
            aggregationInfo_.exportLiteral(outfile, level, name_='MD_AggregateInformation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractMD_Identification_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'citation':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_citation(obj_)
        elif nodeName_ == 'abstract':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_abstract(obj_)
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_purpose(obj_)
        elif nodeName_ == 'credit':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.credit.append(obj_)
        elif nodeName_ == 'status':
            obj_ = MD_ProgressCode_PropertyType.factory()
            obj_.build(child_)
            self.status.append(obj_)
        elif nodeName_ == 'pointOfContact':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.pointOfContact.append(obj_)
        elif nodeName_ == 'resourceMaintenance':
            obj_ = MD_MaintenanceInformation_PropertyType.factory()
            obj_.build(child_)
            self.resourceMaintenance.append(obj_)
        elif nodeName_ == 'graphicOverview':
            obj_ = MD_BrowseGraphic_PropertyType.factory()
            obj_.build(child_)
            self.graphicOverview.append(obj_)
        elif nodeName_ == 'resourceFormat':
            obj_ = MD_Format_PropertyType.factory()
            obj_.build(child_)
            self.resourceFormat.append(obj_)
        elif nodeName_ == 'descriptiveKeywords':
            obj_ = MD_Keywords_PropertyType.factory()
            obj_.build(child_)
            self.descriptiveKeywords.append(obj_)
        elif nodeName_ == 'resourceSpecificUsage':
            obj_ = MD_Usage_PropertyType.factory()
            obj_.build(child_)
            self.resourceSpecificUsage.append(obj_)
        elif nodeName_ == 'resourceConstraints':
            obj_ = MD_Constraints_PropertyType.factory()
            obj_.build(child_)
            self.resourceConstraints.append(obj_)
        elif nodeName_ == 'aggregationInfo':
            obj_ = MD_AggregateInformation_PropertyType.factory()
            obj_.build(child_)
            self.aggregationInfo.append(obj_)
        super(AbstractMD_Identification_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractMD_Identification_Type


class MD_Identification_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, AbstractMD_Identification=None):
        self.nilReason = _cast(None, nilReason)
        self.AbstractMD_Identification = AbstractMD_Identification
    def factory(*args_, **kwargs_):
        if MD_Identification_PropertyType.subclass:
            return MD_Identification_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Identification_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractMD_Identification(self): return self.AbstractMD_Identification
    def set_AbstractMD_Identification(self, AbstractMD_Identification): self.AbstractMD_Identification = AbstractMD_Identification
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Identification_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Identification_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Identification_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Identification_PropertyType', fromsubclass_=False):
        if self.AbstractMD_Identification is not None:
            self.AbstractMD_Identification.export(outfile, level, namespace_, name_='AbstractMD_Identification')
    def hasContent_(self):
        if (
            self.AbstractMD_Identification is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Identification_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractMD_Identification is not None:
            showIndent(outfile, level)
            outfile.write('AbstractMD_Identification=model_.AbstractMD_Identification(\n')
            self.AbstractMD_Identification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractMD_Identification':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractMD_Identification> element')
            self.set_AbstractMD_Identification(obj_)
# end class MD_Identification_PropertyType


class MD_BrowseGraphic_Type(AbstractObject_Type):
    """Graphic that provides an illustration of the dataset (should include
    a legend for the graphic)"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, fileName=None, fileDescription=None, fileType=None):
        super(MD_BrowseGraphic_Type, self).__init__(id, uuid, )
        self.fileName = fileName
        self.fileDescription = fileDescription
        self.fileType = fileType
    def factory(*args_, **kwargs_):
        if MD_BrowseGraphic_Type.subclass:
            return MD_BrowseGraphic_Type.subclass(*args_, **kwargs_)
        else:
            return MD_BrowseGraphic_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileName(self): return self.fileName
    def set_fileName(self, fileName): self.fileName = fileName
    def get_fileDescription(self): return self.fileDescription
    def set_fileDescription(self, fileDescription): self.fileDescription = fileDescription
    def get_fileType(self): return self.fileType
    def set_fileType(self, fileType): self.fileType = fileType
    def export(self, outfile, level, namespace_='', name_='MD_BrowseGraphic_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_BrowseGraphic_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_BrowseGraphic_Type'):
        super(MD_BrowseGraphic_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_BrowseGraphic_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_BrowseGraphic_Type', fromsubclass_=False):
        super(MD_BrowseGraphic_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.fileName is not None:
            self.fileName.export(outfile, level, namespace_, name_='fileName', )
        if self.fileDescription is not None:
            self.fileDescription.export(outfile, level, namespace_, name_='fileDescription')
        if self.fileType is not None:
            self.fileType.export(outfile, level, namespace_, name_='fileType')
    def hasContent_(self):
        if (
            self.fileName is not None or
            self.fileDescription is not None or
            self.fileType is not None or
            super(MD_BrowseGraphic_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_BrowseGraphic_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_BrowseGraphic_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_BrowseGraphic_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.fileName is not None:
            showIndent(outfile, level)
            outfile.write('fileName=model_.CharacterString_PropertyType(\n')
            self.fileName.exportLiteral(outfile, level, name_='fileName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fileDescription is not None:
            showIndent(outfile, level)
            outfile.write('fileDescription=model_.CharacterString_PropertyType(\n')
            self.fileDescription.exportLiteral(outfile, level, name_='fileDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fileType is not None:
            showIndent(outfile, level)
            outfile.write('fileType=model_.CharacterString_PropertyType(\n')
            self.fileType.exportLiteral(outfile, level, name_='fileType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_BrowseGraphic_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_fileName(obj_)
        elif nodeName_ == 'fileDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_fileDescription(obj_)
        elif nodeName_ == 'fileType':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_fileType(obj_)
        super(MD_BrowseGraphic_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_BrowseGraphic_Type


class MD_BrowseGraphic_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_BrowseGraphic=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_BrowseGraphic = MD_BrowseGraphic
    def factory(*args_, **kwargs_):
        if MD_BrowseGraphic_PropertyType.subclass:
            return MD_BrowseGraphic_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_BrowseGraphic_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_BrowseGraphic(self): return self.MD_BrowseGraphic
    def set_MD_BrowseGraphic(self, MD_BrowseGraphic): self.MD_BrowseGraphic = MD_BrowseGraphic
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_BrowseGraphic_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_BrowseGraphic_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_BrowseGraphic_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_BrowseGraphic_PropertyType', fromsubclass_=False):
        if self.MD_BrowseGraphic is not None:
            self.MD_BrowseGraphic.export(outfile, level, namespace_, name_='MD_BrowseGraphic', )
    def hasContent_(self):
        if (
            self.MD_BrowseGraphic is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_BrowseGraphic_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_BrowseGraphic is not None:
            showIndent(outfile, level)
            outfile.write('MD_BrowseGraphic=model_.MD_BrowseGraphic(\n')
            self.MD_BrowseGraphic.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_BrowseGraphic':
            obj_ = MD_BrowseGraphic_Type.factory()
            obj_.build(child_)
            self.set_MD_BrowseGraphic(obj_)
# end class MD_BrowseGraphic_PropertyType


class MD_DataIdentification_Type(AbstractMD_Identification_Type):
    subclass = None
    superclass = AbstractMD_Identification_Type
    def __init__(self, id=None, uuid=None, citation=None, abstract=None, purpose=None, credit=None, status=None, pointOfContact=None, resourceMaintenance=None, graphicOverview=None, resourceFormat=None, descriptiveKeywords=None, resourceSpecificUsage=None, resourceConstraints=None, aggregationInfo=None, spatialRepresentationType=None, spatialResolution=None, language=None, characterSet=None, topicCategory=None, environmentDescription=None, extent=None, supplementalInformation=None):
        super(MD_DataIdentification_Type, self).__init__(id, uuid, citation, abstract, purpose, credit, status, pointOfContact, resourceMaintenance, graphicOverview, resourceFormat, descriptiveKeywords, resourceSpecificUsage, resourceConstraints, aggregationInfo, )
        if spatialRepresentationType is None:
            self.spatialRepresentationType = []
        else:
            self.spatialRepresentationType = spatialRepresentationType
        if spatialResolution is None:
            self.spatialResolution = []
        else:
            self.spatialResolution = spatialResolution
        if language is None:
            self.language = []
        else:
            self.language = language
        if characterSet is None:
            self.characterSet = []
        else:
            self.characterSet = characterSet
        if topicCategory is None:
            self.topicCategory = []
        else:
            self.topicCategory = topicCategory
        self.environmentDescription = environmentDescription
        if extent is None:
            self.extent = []
        else:
            self.extent = extent
        self.supplementalInformation = supplementalInformation
    def factory(*args_, **kwargs_):
        if MD_DataIdentification_Type.subclass:
            return MD_DataIdentification_Type.subclass(*args_, **kwargs_)
        else:
            return MD_DataIdentification_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spatialRepresentationType(self): return self.spatialRepresentationType
    def set_spatialRepresentationType(self, spatialRepresentationType): self.spatialRepresentationType = spatialRepresentationType
    def add_spatialRepresentationType(self, value): self.spatialRepresentationType.append(value)
    def insert_spatialRepresentationType(self, index, value): self.spatialRepresentationType[index] = value
    def get_spatialResolution(self): return self.spatialResolution
    def set_spatialResolution(self, spatialResolution): self.spatialResolution = spatialResolution
    def add_spatialResolution(self, value): self.spatialResolution.append(value)
    def insert_spatialResolution(self, index, value): self.spatialResolution[index] = value
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language(self, index, value): self.language[index] = value
    def get_characterSet(self): return self.characterSet
    def set_characterSet(self, characterSet): self.characterSet = characterSet
    def add_characterSet(self, value): self.characterSet.append(value)
    def insert_characterSet(self, index, value): self.characterSet[index] = value
    def get_topicCategory(self): return self.topicCategory
    def set_topicCategory(self, topicCategory): self.topicCategory = topicCategory
    def add_topicCategory(self, value): self.topicCategory.append(value)
    def insert_topicCategory(self, index, value): self.topicCategory[index] = value
    def get_environmentDescription(self): return self.environmentDescription
    def set_environmentDescription(self, environmentDescription): self.environmentDescription = environmentDescription
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    def add_extent(self, value): self.extent.append(value)
    def insert_extent(self, index, value): self.extent[index] = value
    def get_supplementalInformation(self): return self.supplementalInformation
    def set_supplementalInformation(self, supplementalInformation): self.supplementalInformation = supplementalInformation
    def export(self, outfile, level, namespace_='', name_='MD_DataIdentification_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DataIdentification_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_DataIdentification_Type'):
        super(MD_DataIdentification_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DataIdentification_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_DataIdentification_Type', fromsubclass_=False):
        super(MD_DataIdentification_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for spatialRepresentationType_ in self.spatialRepresentationType:
            spatialRepresentationType_.export(outfile, level, namespace_, name_='spatialRepresentationType')
        for spatialResolution_ in self.spatialResolution:
            spatialResolution_.export(outfile, level, namespace_, name_='spatialResolution')
        for language_ in self.language:
            language_.export(outfile, level, namespace_, name_='language')
        for characterSet_ in self.characterSet:
            characterSet_.export(outfile, level, namespace_, name_='characterSet')
        for topicCategory_ in self.topicCategory:
            topicCategory_.export(outfile, level, namespace_, name_='topicCategory')
        if self.environmentDescription is not None:
            self.environmentDescription.export(outfile, level, namespace_, name_='environmentDescription')
        for extent_ in self.extent:
            extent_.export(outfile, level, namespace_, name_='extent')
        if self.supplementalInformation is not None:
            self.supplementalInformation.export(outfile, level, namespace_, name_='supplementalInformation')
    def hasContent_(self):
        if (
            self.spatialRepresentationType or
            self.spatialResolution or
            self.language or
            self.characterSet or
            self.topicCategory or
            self.environmentDescription is not None or
            self.extent or
            self.supplementalInformation is not None or
            super(MD_DataIdentification_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_DataIdentification_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_DataIdentification_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_DataIdentification_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('spatialRepresentationType=[\n')
        level += 1
        for spatialRepresentationType_ in self.spatialRepresentationType:
            showIndent(outfile, level)
            outfile.write('model_.MD_SpatialRepresentationTypeCode_PropertyType(\n')
            spatialRepresentationType_.exportLiteral(outfile, level, name_='MD_SpatialRepresentationTypeCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('spatialResolution=[\n')
        level += 1
        for spatialResolution_ in self.spatialResolution:
            showIndent(outfile, level)
            outfile.write('model_.MD_Resolution_PropertyType(\n')
            spatialResolution_.exportLiteral(outfile, level, name_='MD_Resolution_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('language=[\n')
        level += 1
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            language_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('characterSet=[\n')
        level += 1
        for characterSet_ in self.characterSet:
            showIndent(outfile, level)
            outfile.write('model_.MD_CharacterSetCode_PropertyType(\n')
            characterSet_.exportLiteral(outfile, level, name_='MD_CharacterSetCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('topicCategory=[\n')
        level += 1
        for topicCategory_ in self.topicCategory:
            showIndent(outfile, level)
            outfile.write('model_.MD_TopicCategoryCode_PropertyType(\n')
            topicCategory_.exportLiteral(outfile, level, name_='MD_TopicCategoryCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.environmentDescription is not None:
            showIndent(outfile, level)
            outfile.write('environmentDescription=model_.CharacterString_PropertyType(\n')
            self.environmentDescription.exportLiteral(outfile, level, name_='environmentDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('extent=[\n')
        level += 1
        for extent_ in self.extent:
            showIndent(outfile, level)
            outfile.write('model_.EX_Extent_PropertyType(\n')
            extent_.exportLiteral(outfile, level, name_='EX_Extent_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.supplementalInformation is not None:
            showIndent(outfile, level)
            outfile.write('supplementalInformation=model_.CharacterString_PropertyType(\n')
            self.supplementalInformation.exportLiteral(outfile, level, name_='supplementalInformation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_DataIdentification_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spatialRepresentationType':
            obj_ = MD_SpatialRepresentationTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.spatialRepresentationType.append(obj_)
        elif nodeName_ == 'spatialResolution':
            obj_ = MD_Resolution_PropertyType.factory()
            obj_.build(child_)
            self.spatialResolution.append(obj_)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.language.append(obj_)
        elif nodeName_ == 'characterSet':
            obj_ = MD_CharacterSetCode_PropertyType.factory()
            obj_.build(child_)
            self.characterSet.append(obj_)
        elif nodeName_ == 'topicCategory':
            obj_ = MD_TopicCategoryCode_PropertyType.factory()
            obj_.build(child_)
            self.topicCategory.append(obj_)
        elif nodeName_ == 'environmentDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_environmentDescription(obj_)
        elif nodeName_ == 'extent':
            obj_ = EX_Extent_PropertyType.factory()
            obj_.build(child_)
            self.extent.append(obj_)
        elif nodeName_ == 'supplementalInformation':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_supplementalInformation(obj_)
        super(MD_DataIdentification_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_DataIdentification_Type


class MD_DataIdentification_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_DataIdentification=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_DataIdentification = MD_DataIdentification
    def factory(*args_, **kwargs_):
        if MD_DataIdentification_PropertyType.subclass:
            return MD_DataIdentification_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_DataIdentification_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_DataIdentification(self): return self.MD_DataIdentification
    def set_MD_DataIdentification(self, MD_DataIdentification): self.MD_DataIdentification = MD_DataIdentification
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_DataIdentification_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DataIdentification_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_DataIdentification_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_DataIdentification_PropertyType', fromsubclass_=False):
        if self.MD_DataIdentification is not None:
            self.MD_DataIdentification.export(outfile, level, namespace_, name_='MD_DataIdentification', )
    def hasContent_(self):
        if (
            self.MD_DataIdentification is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_DataIdentification_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_DataIdentification is not None:
            showIndent(outfile, level)
            outfile.write('MD_DataIdentification=model_.MD_DataIdentification(\n')
            self.MD_DataIdentification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_DataIdentification':
            obj_ = MD_DataIdentification_Type.factory()
            obj_.build(child_)
            self.set_MD_DataIdentification(obj_)
# end class MD_DataIdentification_PropertyType


class MD_ServiceIdentification_Type(AbstractMD_Identification_Type):
    """See 19119 for further info"""
    subclass = None
    superclass = AbstractMD_Identification_Type
    def __init__(self, id=None, uuid=None, citation=None, abstract=None, purpose=None, credit=None, status=None, pointOfContact=None, resourceMaintenance=None, graphicOverview=None, resourceFormat=None, descriptiveKeywords=None, resourceSpecificUsage=None, resourceConstraints=None, aggregationInfo=None):
        super(MD_ServiceIdentification_Type, self).__init__(id, uuid, citation, abstract, purpose, credit, status, pointOfContact, resourceMaintenance, graphicOverview, resourceFormat, descriptiveKeywords, resourceSpecificUsage, resourceConstraints, aggregationInfo, )
        pass
    def factory(*args_, **kwargs_):
        if MD_ServiceIdentification_Type.subclass:
            return MD_ServiceIdentification_Type.subclass(*args_, **kwargs_)
        else:
            return MD_ServiceIdentification_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='MD_ServiceIdentification_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ServiceIdentification_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ServiceIdentification_Type'):
        super(MD_ServiceIdentification_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ServiceIdentification_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ServiceIdentification_Type', fromsubclass_=False):
        super(MD_ServiceIdentification_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(MD_ServiceIdentification_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ServiceIdentification_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_ServiceIdentification_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_ServiceIdentification_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_ServiceIdentification_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MD_ServiceIdentification_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MD_ServiceIdentification_Type


class MD_ServiceIdentification_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ServiceIdentification=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ServiceIdentification = MD_ServiceIdentification
    def factory(*args_, **kwargs_):
        if MD_ServiceIdentification_PropertyType.subclass:
            return MD_ServiceIdentification_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ServiceIdentification_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ServiceIdentification(self): return self.MD_ServiceIdentification
    def set_MD_ServiceIdentification(self, MD_ServiceIdentification): self.MD_ServiceIdentification = MD_ServiceIdentification
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ServiceIdentification_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ServiceIdentification_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ServiceIdentification_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ServiceIdentification_PropertyType', fromsubclass_=False):
        if self.MD_ServiceIdentification is not None:
            self.MD_ServiceIdentification.export(outfile, level, namespace_, name_='MD_ServiceIdentification', )
    def hasContent_(self):
        if (
            self.MD_ServiceIdentification is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ServiceIdentification_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ServiceIdentification is not None:
            showIndent(outfile, level)
            outfile.write('MD_ServiceIdentification=model_.MD_ServiceIdentification(\n')
            self.MD_ServiceIdentification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ServiceIdentification':
            obj_ = MD_ServiceIdentification_Type.factory()
            obj_.build(child_)
            self.set_MD_ServiceIdentification(obj_)
# end class MD_ServiceIdentification_PropertyType


class MD_RepresentativeFraction_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, denominator=None):
        super(MD_RepresentativeFraction_Type, self).__init__(id, uuid, )
        self.denominator = denominator
    def factory(*args_, **kwargs_):
        if MD_RepresentativeFraction_Type.subclass:
            return MD_RepresentativeFraction_Type.subclass(*args_, **kwargs_)
        else:
            return MD_RepresentativeFraction_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_denominator(self): return self.denominator
    def set_denominator(self, denominator): self.denominator = denominator
    def export(self, outfile, level, namespace_='', name_='MD_RepresentativeFraction_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_RepresentativeFraction_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_RepresentativeFraction_Type'):
        super(MD_RepresentativeFraction_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_RepresentativeFraction_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_RepresentativeFraction_Type', fromsubclass_=False):
        super(MD_RepresentativeFraction_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.denominator is not None:
            self.denominator.export(outfile, level, namespace_, name_='denominator', )
    def hasContent_(self):
        if (
            self.denominator is not None or
            super(MD_RepresentativeFraction_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_RepresentativeFraction_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_RepresentativeFraction_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_RepresentativeFraction_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.denominator is not None:
            showIndent(outfile, level)
            outfile.write('denominator=model_.Integer_PropertyType(\n')
            self.denominator.exportLiteral(outfile, level, name_='denominator')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_RepresentativeFraction_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'denominator':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_denominator(obj_)
        super(MD_RepresentativeFraction_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_RepresentativeFraction_Type


class MD_RepresentativeFraction_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_RepresentativeFraction=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_RepresentativeFraction = MD_RepresentativeFraction
    def factory(*args_, **kwargs_):
        if MD_RepresentativeFraction_PropertyType.subclass:
            return MD_RepresentativeFraction_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_RepresentativeFraction_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_RepresentativeFraction(self): return self.MD_RepresentativeFraction
    def set_MD_RepresentativeFraction(self, MD_RepresentativeFraction): self.MD_RepresentativeFraction = MD_RepresentativeFraction
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_RepresentativeFraction_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_RepresentativeFraction_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_RepresentativeFraction_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_RepresentativeFraction_PropertyType', fromsubclass_=False):
        if self.MD_RepresentativeFraction is not None:
            self.MD_RepresentativeFraction.export(outfile, level, namespace_, name_='MD_RepresentativeFraction', )
    def hasContent_(self):
        if (
            self.MD_RepresentativeFraction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_RepresentativeFraction_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_RepresentativeFraction is not None:
            showIndent(outfile, level)
            outfile.write('MD_RepresentativeFraction=model_.MD_RepresentativeFraction(\n')
            self.MD_RepresentativeFraction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_RepresentativeFraction':
            obj_ = MD_RepresentativeFraction_Type.factory()
            obj_.build(child_)
            self.set_MD_RepresentativeFraction(obj_)
# end class MD_RepresentativeFraction_PropertyType


class MD_Usage_Type(AbstractObject_Type):
    """Brief description of ways in which the dataset is currently used."""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, specificUsage=None, usageDateTime=None, userDeterminedLimitations=None, userContactInfo=None):
        super(MD_Usage_Type, self).__init__(id, uuid, )
        self.specificUsage = specificUsage
        self.usageDateTime = usageDateTime
        self.userDeterminedLimitations = userDeterminedLimitations
        if userContactInfo is None:
            self.userContactInfo = []
        else:
            self.userContactInfo = userContactInfo
    def factory(*args_, **kwargs_):
        if MD_Usage_Type.subclass:
            return MD_Usage_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Usage_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specificUsage(self): return self.specificUsage
    def set_specificUsage(self, specificUsage): self.specificUsage = specificUsage
    def get_usageDateTime(self): return self.usageDateTime
    def set_usageDateTime(self, usageDateTime): self.usageDateTime = usageDateTime
    def get_userDeterminedLimitations(self): return self.userDeterminedLimitations
    def set_userDeterminedLimitations(self, userDeterminedLimitations): self.userDeterminedLimitations = userDeterminedLimitations
    def get_userContactInfo(self): return self.userContactInfo
    def set_userContactInfo(self, userContactInfo): self.userContactInfo = userContactInfo
    def add_userContactInfo(self, value): self.userContactInfo.append(value)
    def insert_userContactInfo(self, index, value): self.userContactInfo[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_Usage_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Usage_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Usage_Type'):
        super(MD_Usage_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Usage_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Usage_Type', fromsubclass_=False):
        super(MD_Usage_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.specificUsage is not None:
            self.specificUsage.export(outfile, level, namespace_, name_='specificUsage', )
        if self.usageDateTime is not None:
            self.usageDateTime.export(outfile, level, namespace_, name_='usageDateTime')
        if self.userDeterminedLimitations is not None:
            self.userDeterminedLimitations.export(outfile, level, namespace_, name_='userDeterminedLimitations')
        for userContactInfo_ in self.userContactInfo:
            userContactInfo_.export(outfile, level, namespace_, name_='userContactInfo')
    def hasContent_(self):
        if (
            self.specificUsage is not None or
            self.usageDateTime is not None or
            self.userDeterminedLimitations is not None or
            self.userContactInfo or
            super(MD_Usage_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Usage_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Usage_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Usage_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.specificUsage is not None:
            showIndent(outfile, level)
            outfile.write('specificUsage=model_.CharacterString_PropertyType(\n')
            self.specificUsage.exportLiteral(outfile, level, name_='specificUsage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usageDateTime is not None:
            showIndent(outfile, level)
            outfile.write('usageDateTime=model_.DateTime_PropertyType(\n')
            self.usageDateTime.exportLiteral(outfile, level, name_='usageDateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.userDeterminedLimitations is not None:
            showIndent(outfile, level)
            outfile.write('userDeterminedLimitations=model_.CharacterString_PropertyType(\n')
            self.userDeterminedLimitations.exportLiteral(outfile, level, name_='userDeterminedLimitations')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('userContactInfo=[\n')
        level += 1
        for userContactInfo_ in self.userContactInfo:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            userContactInfo_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Usage_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'specificUsage':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_specificUsage(obj_)
        elif nodeName_ == 'usageDateTime':
            obj_ = DateTime_PropertyType.factory()
            obj_.build(child_)
            self.set_usageDateTime(obj_)
        elif nodeName_ == 'userDeterminedLimitations':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_userDeterminedLimitations(obj_)
        elif nodeName_ == 'userContactInfo':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.userContactInfo.append(obj_)
        super(MD_Usage_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Usage_Type


class MD_Usage_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Usage=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Usage = MD_Usage
    def factory(*args_, **kwargs_):
        if MD_Usage_PropertyType.subclass:
            return MD_Usage_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Usage_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Usage(self): return self.MD_Usage
    def set_MD_Usage(self, MD_Usage): self.MD_Usage = MD_Usage
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Usage_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Usage_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Usage_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Usage_PropertyType', fromsubclass_=False):
        if self.MD_Usage is not None:
            self.MD_Usage.export(outfile, level, namespace_, name_='MD_Usage', )
    def hasContent_(self):
        if (
            self.MD_Usage is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Usage_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Usage is not None:
            showIndent(outfile, level)
            outfile.write('MD_Usage=model_.MD_Usage(\n')
            self.MD_Usage.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Usage':
            obj_ = MD_Usage_Type.factory()
            obj_.build(child_)
            self.set_MD_Usage(obj_)
# end class MD_Usage_PropertyType


class MD_Keywords_Type(AbstractObject_Type):
    """Keywords, their type and reference source"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, keyword=None, type_=None, thesaurusName=None):
        super(MD_Keywords_Type, self).__init__(id, uuid, )
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        self.type_ = type_
        self.thesaurusName = thesaurusName
    def factory(*args_, **kwargs_):
        if MD_Keywords_Type.subclass:
            return MD_Keywords_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Keywords_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_keyword(self): return self.keyword
    def set_keyword(self, keyword): self.keyword = keyword
    def add_keyword(self, value): self.keyword.append(value)
    def insert_keyword(self, index, value): self.keyword[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_thesaurusName(self): return self.thesaurusName
    def set_thesaurusName(self, thesaurusName): self.thesaurusName = thesaurusName
    def export(self, outfile, level, namespace_='', name_='MD_Keywords_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Keywords_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Keywords_Type'):
        super(MD_Keywords_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Keywords_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Keywords_Type', fromsubclass_=False):
        super(MD_Keywords_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for keyword_ in self.keyword:
            keyword_.export(outfile, level, namespace_, name_='keyword')
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type')
        if self.thesaurusName is not None:
            self.thesaurusName.export(outfile, level, namespace_, name_='thesaurusName')
    def hasContent_(self):
        if (
            self.keyword or
            self.type_ is not None or
            self.thesaurusName is not None or
            super(MD_Keywords_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Keywords_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Keywords_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Keywords_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('keyword=[\n')
        level += 1
        for keyword_ in self.keyword:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            keyword_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.MD_KeywordTypeCode_PropertyType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.thesaurusName is not None:
            showIndent(outfile, level)
            outfile.write('thesaurusName=model_.CI_Citation_PropertyType(\n')
            self.thesaurusName.exportLiteral(outfile, level, name_='thesaurusName')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Keywords_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'keyword':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.keyword.append(obj_)
        elif nodeName_ == 'type':
            obj_ = MD_KeywordTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_type(obj_)
        elif nodeName_ == 'thesaurusName':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_thesaurusName(obj_)
        super(MD_Keywords_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Keywords_Type


class MD_Keywords_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Keywords=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Keywords = MD_Keywords
    def factory(*args_, **kwargs_):
        if MD_Keywords_PropertyType.subclass:
            return MD_Keywords_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Keywords_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Keywords(self): return self.MD_Keywords
    def set_MD_Keywords(self, MD_Keywords): self.MD_Keywords = MD_Keywords
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Keywords_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Keywords_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Keywords_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Keywords_PropertyType', fromsubclass_=False):
        if self.MD_Keywords is not None:
            self.MD_Keywords.export(outfile, level, namespace_, name_='MD_Keywords', )
    def hasContent_(self):
        if (
            self.MD_Keywords is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Keywords_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Keywords is not None:
            showIndent(outfile, level)
            outfile.write('MD_Keywords=model_.MD_Keywords(\n')
            self.MD_Keywords.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Keywords':
            obj_ = MD_Keywords_Type.factory()
            obj_.build(child_)
            self.set_MD_Keywords(obj_)
# end class MD_Keywords_PropertyType


class DS_Association_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None):
        super(DS_Association_Type, self).__init__(id, uuid, )
        pass
    def factory(*args_, **kwargs_):
        if DS_Association_Type.subclass:
            return DS_Association_Type.subclass(*args_, **kwargs_)
        else:
            return DS_Association_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DS_Association_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Association_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Association_Type'):
        super(DS_Association_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Association_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Association_Type', fromsubclass_=False):
        super(DS_Association_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(DS_Association_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Association_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_Association_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_Association_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DS_Association_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_Association_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_Association_Type


class DS_Association_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_Association=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_Association = DS_Association
    def factory(*args_, **kwargs_):
        if DS_Association_PropertyType.subclass:
            return DS_Association_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_Association_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_Association(self): return self.DS_Association
    def set_DS_Association(self, DS_Association): self.DS_Association = DS_Association
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_Association_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Association_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Association_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Association_PropertyType', fromsubclass_=False):
        if self.DS_Association is not None:
            self.DS_Association.export(outfile, level, namespace_, name_='DS_Association', )
    def hasContent_(self):
        if (
            self.DS_Association is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Association_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_Association is not None:
            showIndent(outfile, level)
            outfile.write('DS_Association=model_.DS_Association(\n')
            self.DS_Association.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_Association':
            obj_ = DS_Association_Type.factory()
            obj_.build(child_)
            self.set_DS_Association(obj_)
# end class DS_Association_PropertyType


class MD_AggregateInformation_Type(AbstractObject_Type):
    """Encapsulates the dataset aggregation information"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, aggregateDataSetName=None, aggregateDataSetIdentifier=None, associationType=None, initiativeType=None):
        super(MD_AggregateInformation_Type, self).__init__(id, uuid, )
        self.aggregateDataSetName = aggregateDataSetName
        self.aggregateDataSetIdentifier = aggregateDataSetIdentifier
        self.associationType = associationType
        self.initiativeType = initiativeType
    def factory(*args_, **kwargs_):
        if MD_AggregateInformation_Type.subclass:
            return MD_AggregateInformation_Type.subclass(*args_, **kwargs_)
        else:
            return MD_AggregateInformation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregateDataSetName(self): return self.aggregateDataSetName
    def set_aggregateDataSetName(self, aggregateDataSetName): self.aggregateDataSetName = aggregateDataSetName
    def get_aggregateDataSetIdentifier(self): return self.aggregateDataSetIdentifier
    def set_aggregateDataSetIdentifier(self, aggregateDataSetIdentifier): self.aggregateDataSetIdentifier = aggregateDataSetIdentifier
    def get_associationType(self): return self.associationType
    def set_associationType(self, associationType): self.associationType = associationType
    def get_initiativeType(self): return self.initiativeType
    def set_initiativeType(self, initiativeType): self.initiativeType = initiativeType
    def export(self, outfile, level, namespace_='', name_='MD_AggregateInformation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_AggregateInformation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_AggregateInformation_Type'):
        super(MD_AggregateInformation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_AggregateInformation_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_AggregateInformation_Type', fromsubclass_=False):
        super(MD_AggregateInformation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.aggregateDataSetName is not None:
            self.aggregateDataSetName.export(outfile, level, namespace_, name_='aggregateDataSetName')
        if self.aggregateDataSetIdentifier is not None:
            self.aggregateDataSetIdentifier.export(outfile, level, namespace_, name_='aggregateDataSetIdentifier')
        if self.associationType is not None:
            self.associationType.export(outfile, level, namespace_, name_='associationType', )
        if self.initiativeType is not None:
            self.initiativeType.export(outfile, level, namespace_, name_='initiativeType')
    def hasContent_(self):
        if (
            self.aggregateDataSetName is not None or
            self.aggregateDataSetIdentifier is not None or
            self.associationType is not None or
            self.initiativeType is not None or
            super(MD_AggregateInformation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_AggregateInformation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_AggregateInformation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_AggregateInformation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.aggregateDataSetName is not None:
            showIndent(outfile, level)
            outfile.write('aggregateDataSetName=model_.CI_Citation_PropertyType(\n')
            self.aggregateDataSetName.exportLiteral(outfile, level, name_='aggregateDataSetName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.aggregateDataSetIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('aggregateDataSetIdentifier=model_.MD_Identifier_PropertyType(\n')
            self.aggregateDataSetIdentifier.exportLiteral(outfile, level, name_='aggregateDataSetIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.associationType is not None:
            showIndent(outfile, level)
            outfile.write('associationType=model_.DS_AssociationTypeCode_PropertyType(\n')
            self.associationType.exportLiteral(outfile, level, name_='associationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.initiativeType is not None:
            showIndent(outfile, level)
            outfile.write('initiativeType=model_.DS_InitiativeTypeCode_PropertyType(\n')
            self.initiativeType.exportLiteral(outfile, level, name_='initiativeType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_AggregateInformation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aggregateDataSetName':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_aggregateDataSetName(obj_)
        elif nodeName_ == 'aggregateDataSetIdentifier':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.set_aggregateDataSetIdentifier(obj_)
        elif nodeName_ == 'associationType':
            obj_ = DS_AssociationTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_associationType(obj_)
        elif nodeName_ == 'initiativeType':
            obj_ = DS_InitiativeTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_initiativeType(obj_)
        super(MD_AggregateInformation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_AggregateInformation_Type


class MD_AggregateInformation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_AggregateInformation=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_AggregateInformation = MD_AggregateInformation
    def factory(*args_, **kwargs_):
        if MD_AggregateInformation_PropertyType.subclass:
            return MD_AggregateInformation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_AggregateInformation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_AggregateInformation(self): return self.MD_AggregateInformation
    def set_MD_AggregateInformation(self, MD_AggregateInformation): self.MD_AggregateInformation = MD_AggregateInformation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_AggregateInformation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_AggregateInformation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_AggregateInformation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_AggregateInformation_PropertyType', fromsubclass_=False):
        if self.MD_AggregateInformation is not None:
            self.MD_AggregateInformation.export(outfile, level, namespace_, name_='MD_AggregateInformation', )
    def hasContent_(self):
        if (
            self.MD_AggregateInformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_AggregateInformation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_AggregateInformation is not None:
            showIndent(outfile, level)
            outfile.write('MD_AggregateInformation=model_.MD_AggregateInformation(\n')
            self.MD_AggregateInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_AggregateInformation':
            obj_ = MD_AggregateInformation_Type.factory()
            obj_.build(child_)
            self.set_MD_AggregateInformation(obj_)
# end class MD_AggregateInformation_PropertyType


class MD_Resolution_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, equivalentScale=None, distance=None):
        self.equivalentScale = equivalentScale
        self.distance = distance
    def factory(*args_, **kwargs_):
        if MD_Resolution_Type.subclass:
            return MD_Resolution_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Resolution_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_equivalentScale(self): return self.equivalentScale
    def set_equivalentScale(self, equivalentScale): self.equivalentScale = equivalentScale
    def get_distance(self): return self.distance
    def set_distance(self, distance): self.distance = distance
    def export(self, outfile, level, namespace_='', name_='MD_Resolution_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Resolution_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Resolution_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Resolution_Type', fromsubclass_=False):
        if self.equivalentScale is not None:
            self.equivalentScale.export(outfile, level, namespace_, name_='equivalentScale', )
        if self.distance is not None:
            self.distance.export(outfile, level, namespace_, name_='distance', )
    def hasContent_(self):
        if (
            self.equivalentScale is not None or
            self.distance is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Resolution_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.equivalentScale is not None:
            showIndent(outfile, level)
            outfile.write('equivalentScale=model_.MD_RepresentativeFraction_PropertyType(\n')
            self.equivalentScale.exportLiteral(outfile, level, name_='equivalentScale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distance is not None:
            showIndent(outfile, level)
            outfile.write('distance=model_.Distance_PropertyType(\n')
            self.distance.exportLiteral(outfile, level, name_='distance')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'equivalentScale':
            obj_ = MD_RepresentativeFraction_PropertyType.factory()
            obj_.build(child_)
            self.set_equivalentScale(obj_)
        elif nodeName_ == 'distance':
            obj_ = Distance_PropertyType.factory()
            obj_.build(child_)
            self.set_distance(obj_)
# end class MD_Resolution_Type


class MD_Resolution_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Resolution=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Resolution = MD_Resolution
    def factory(*args_, **kwargs_):
        if MD_Resolution_PropertyType.subclass:
            return MD_Resolution_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Resolution_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Resolution(self): return self.MD_Resolution
    def set_MD_Resolution(self, MD_Resolution): self.MD_Resolution = MD_Resolution
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Resolution_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Resolution_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Resolution_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Resolution_PropertyType', fromsubclass_=False):
        if self.MD_Resolution is not None:
            self.MD_Resolution.export(outfile, level, namespace_, name_='MD_Resolution', )
    def hasContent_(self):
        if (
            self.MD_Resolution is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Resolution_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Resolution is not None:
            showIndent(outfile, level)
            outfile.write('MD_Resolution=model_.MD_Resolution(\n')
            self.MD_Resolution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Resolution':
            obj_ = MD_Resolution_Type.factory()
            obj_.build(child_)
            self.set_MD_Resolution(obj_)
# end class MD_Resolution_PropertyType


class MD_TopicCategoryCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_TopicCategoryCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_TopicCategoryCode = MD_TopicCategoryCode
    def factory(*args_, **kwargs_):
        if MD_TopicCategoryCode_PropertyType.subclass:
            return MD_TopicCategoryCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_TopicCategoryCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_TopicCategoryCode(self): return self.MD_TopicCategoryCode
    def set_MD_TopicCategoryCode(self, MD_TopicCategoryCode): self.MD_TopicCategoryCode = MD_TopicCategoryCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_TopicCategoryCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_TopicCategoryCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_TopicCategoryCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_TopicCategoryCode_PropertyType', fromsubclass_=False):
        if self.MD_TopicCategoryCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sMD_TopicCategoryCode>%s</%sMD_TopicCategoryCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.MD_TopicCategoryCode).encode(ExternalEncoding), input_name='MD_TopicCategoryCode'), namespace_))
    def hasContent_(self):
        if (
            self.MD_TopicCategoryCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_TopicCategoryCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_TopicCategoryCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_TopicCategoryCode=%s,\n' % quote_python(self.MD_TopicCategoryCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_TopicCategoryCode':
            MD_TopicCategoryCode_ = child_.text
            MD_TopicCategoryCode_ = self.gds_validate_string(MD_TopicCategoryCode_, node, 'MD_TopicCategoryCode')
            self.MD_TopicCategoryCode = MD_TopicCategoryCode_
# end class MD_TopicCategoryCode_PropertyType


class MD_CharacterSetCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_CharacterSetCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_CharacterSetCode = MD_CharacterSetCode
    def factory(*args_, **kwargs_):
        if MD_CharacterSetCode_PropertyType.subclass:
            return MD_CharacterSetCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_CharacterSetCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_CharacterSetCode(self): return self.MD_CharacterSetCode
    def set_MD_CharacterSetCode(self, MD_CharacterSetCode): self.MD_CharacterSetCode = MD_CharacterSetCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_CharacterSetCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_CharacterSetCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_CharacterSetCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_CharacterSetCode_PropertyType', fromsubclass_=False):
        if self.MD_CharacterSetCode is not None:
            self.MD_CharacterSetCode.export(outfile, level, namespace_, name_='MD_CharacterSetCode', )
    def hasContent_(self):
        if (
            self.MD_CharacterSetCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_CharacterSetCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_CharacterSetCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_CharacterSetCode=model_.MD_CharacterSetCode(\n')
            self.MD_CharacterSetCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_CharacterSetCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_CharacterSetCode(obj_)
# end class MD_CharacterSetCode_PropertyType


class MD_SpatialRepresentationTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_SpatialRepresentationTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_SpatialRepresentationTypeCode = MD_SpatialRepresentationTypeCode
    def factory(*args_, **kwargs_):
        if MD_SpatialRepresentationTypeCode_PropertyType.subclass:
            return MD_SpatialRepresentationTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_SpatialRepresentationTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_SpatialRepresentationTypeCode(self): return self.MD_SpatialRepresentationTypeCode
    def set_MD_SpatialRepresentationTypeCode(self, MD_SpatialRepresentationTypeCode): self.MD_SpatialRepresentationTypeCode = MD_SpatialRepresentationTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_SpatialRepresentationTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_SpatialRepresentationTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_SpatialRepresentationTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_SpatialRepresentationTypeCode_PropertyType', fromsubclass_=False):
        if self.MD_SpatialRepresentationTypeCode is not None:
            self.MD_SpatialRepresentationTypeCode.export(outfile, level, namespace_, name_='MD_SpatialRepresentationTypeCode', )
    def hasContent_(self):
        if (
            self.MD_SpatialRepresentationTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_SpatialRepresentationTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_SpatialRepresentationTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_SpatialRepresentationTypeCode=model_.MD_SpatialRepresentationTypeCode(\n')
            self.MD_SpatialRepresentationTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_SpatialRepresentationTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_SpatialRepresentationTypeCode(obj_)
# end class MD_SpatialRepresentationTypeCode_PropertyType


class MD_ProgressCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ProgressCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ProgressCode = MD_ProgressCode
    def factory(*args_, **kwargs_):
        if MD_ProgressCode_PropertyType.subclass:
            return MD_ProgressCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ProgressCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ProgressCode(self): return self.MD_ProgressCode
    def set_MD_ProgressCode(self, MD_ProgressCode): self.MD_ProgressCode = MD_ProgressCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ProgressCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ProgressCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ProgressCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ProgressCode_PropertyType', fromsubclass_=False):
        if self.MD_ProgressCode is not None:
            self.MD_ProgressCode.export(outfile, level, namespace_, name_='MD_ProgressCode', )
    def hasContent_(self):
        if (
            self.MD_ProgressCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ProgressCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ProgressCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_ProgressCode=model_.MD_ProgressCode(\n')
            self.MD_ProgressCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ProgressCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_ProgressCode(obj_)
# end class MD_ProgressCode_PropertyType


class MD_KeywordTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_KeywordTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_KeywordTypeCode = MD_KeywordTypeCode
    def factory(*args_, **kwargs_):
        if MD_KeywordTypeCode_PropertyType.subclass:
            return MD_KeywordTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_KeywordTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_KeywordTypeCode(self): return self.MD_KeywordTypeCode
    def set_MD_KeywordTypeCode(self, MD_KeywordTypeCode): self.MD_KeywordTypeCode = MD_KeywordTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_KeywordTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_KeywordTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_KeywordTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_KeywordTypeCode_PropertyType', fromsubclass_=False):
        if self.MD_KeywordTypeCode is not None:
            self.MD_KeywordTypeCode.export(outfile, level, namespace_, name_='MD_KeywordTypeCode', )
    def hasContent_(self):
        if (
            self.MD_KeywordTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_KeywordTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_KeywordTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_KeywordTypeCode=model_.MD_KeywordTypeCode(\n')
            self.MD_KeywordTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_KeywordTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_KeywordTypeCode(obj_)
# end class MD_KeywordTypeCode_PropertyType


class DS_AssociationTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_AssociationTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_AssociationTypeCode = DS_AssociationTypeCode
    def factory(*args_, **kwargs_):
        if DS_AssociationTypeCode_PropertyType.subclass:
            return DS_AssociationTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_AssociationTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_AssociationTypeCode(self): return self.DS_AssociationTypeCode
    def set_DS_AssociationTypeCode(self, DS_AssociationTypeCode): self.DS_AssociationTypeCode = DS_AssociationTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_AssociationTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_AssociationTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_AssociationTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_AssociationTypeCode_PropertyType', fromsubclass_=False):
        if self.DS_AssociationTypeCode is not None:
            self.DS_AssociationTypeCode.export(outfile, level, namespace_, name_='DS_AssociationTypeCode', )
    def hasContent_(self):
        if (
            self.DS_AssociationTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_AssociationTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_AssociationTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('DS_AssociationTypeCode=model_.DS_AssociationTypeCode(\n')
            self.DS_AssociationTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_AssociationTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_DS_AssociationTypeCode(obj_)
# end class DS_AssociationTypeCode_PropertyType


class DS_InitiativeTypeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, DS_InitiativeTypeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.DS_InitiativeTypeCode = DS_InitiativeTypeCode
    def factory(*args_, **kwargs_):
        if DS_InitiativeTypeCode_PropertyType.subclass:
            return DS_InitiativeTypeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return DS_InitiativeTypeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_InitiativeTypeCode(self): return self.DS_InitiativeTypeCode
    def set_DS_InitiativeTypeCode(self, DS_InitiativeTypeCode): self.DS_InitiativeTypeCode = DS_InitiativeTypeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='DS_InitiativeTypeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_InitiativeTypeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_InitiativeTypeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DS_InitiativeTypeCode_PropertyType', fromsubclass_=False):
        if self.DS_InitiativeTypeCode is not None:
            self.DS_InitiativeTypeCode.export(outfile, level, namespace_, name_='DS_InitiativeTypeCode', )
    def hasContent_(self):
        if (
            self.DS_InitiativeTypeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_InitiativeTypeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_InitiativeTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('DS_InitiativeTypeCode=model_.DS_InitiativeTypeCode(\n')
            self.DS_InitiativeTypeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_InitiativeTypeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_DS_InitiativeTypeCode(obj_)
# end class DS_InitiativeTypeCode_PropertyType


class MD_Constraints_Type(AbstractObject_Type):
    """Restrictions on the access and use of a dataset or metadata"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, useLimitation=None, extensiontype_=None):
        super(MD_Constraints_Type, self).__init__(id, uuid, extensiontype_, )
        if useLimitation is None:
            self.useLimitation = []
        else:
            self.useLimitation = useLimitation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MD_Constraints_Type.subclass:
            return MD_Constraints_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Constraints_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_useLimitation(self): return self.useLimitation
    def set_useLimitation(self, useLimitation): self.useLimitation = useLimitation
    def add_useLimitation(self, value): self.useLimitation.append(value)
    def insert_useLimitation(self, index, value): self.useLimitation[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MD_Constraints_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Constraints_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Constraints_Type'):
        super(MD_Constraints_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Constraints_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Constraints_Type', fromsubclass_=False):
        super(MD_Constraints_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for useLimitation_ in self.useLimitation:
            useLimitation_.export(outfile, level, namespace_, name_='useLimitation')
    def hasContent_(self):
        if (
            self.useLimitation or
            super(MD_Constraints_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Constraints_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Constraints_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Constraints_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('useLimitation=[\n')
        level += 1
        for useLimitation_ in self.useLimitation:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            useLimitation_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(MD_Constraints_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'useLimitation':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.useLimitation.append(obj_)
        super(MD_Constraints_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Constraints_Type


class MD_Constraints_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Constraints=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Constraints = MD_Constraints
    def factory(*args_, **kwargs_):
        if MD_Constraints_PropertyType.subclass:
            return MD_Constraints_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Constraints_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Constraints(self): return self.MD_Constraints
    def set_MD_Constraints(self, MD_Constraints): self.MD_Constraints = MD_Constraints
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Constraints_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Constraints_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Constraints_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Constraints_PropertyType', fromsubclass_=False):
        if self.MD_Constraints is not None:
            self.MD_Constraints.export(outfile, level, namespace_, name_='MD_Constraints', )
    def hasContent_(self):
        if (
            self.MD_Constraints is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Constraints_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Constraints is not None:
            showIndent(outfile, level)
            outfile.write('MD_Constraints=model_.MD_Constraints(\n')
            self.MD_Constraints.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Constraints':
            class_obj_ = self.get_class_obj_(child_, MD_Constraints_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_MD_Constraints(obj_)
# end class MD_Constraints_PropertyType


class MD_LegalConstraints_Type(MD_Constraints_Type):
    """Restrictions and legal prerequisites for accessing and using the
    dataset."""
    subclass = None
    superclass = MD_Constraints_Type
    def __init__(self, id=None, uuid=None, useLimitation=None, accessConstraints=None, useConstraints=None, otherConstraints=None):
        super(MD_LegalConstraints_Type, self).__init__(id, uuid, useLimitation, )
        if accessConstraints is None:
            self.accessConstraints = []
        else:
            self.accessConstraints = accessConstraints
        if useConstraints is None:
            self.useConstraints = []
        else:
            self.useConstraints = useConstraints
        if otherConstraints is None:
            self.otherConstraints = []
        else:
            self.otherConstraints = otherConstraints
    def factory(*args_, **kwargs_):
        if MD_LegalConstraints_Type.subclass:
            return MD_LegalConstraints_Type.subclass(*args_, **kwargs_)
        else:
            return MD_LegalConstraints_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessConstraints(self): return self.accessConstraints
    def set_accessConstraints(self, accessConstraints): self.accessConstraints = accessConstraints
    def add_accessConstraints(self, value): self.accessConstraints.append(value)
    def insert_accessConstraints(self, index, value): self.accessConstraints[index] = value
    def get_useConstraints(self): return self.useConstraints
    def set_useConstraints(self, useConstraints): self.useConstraints = useConstraints
    def add_useConstraints(self, value): self.useConstraints.append(value)
    def insert_useConstraints(self, index, value): self.useConstraints[index] = value
    def get_otherConstraints(self): return self.otherConstraints
    def set_otherConstraints(self, otherConstraints): self.otherConstraints = otherConstraints
    def add_otherConstraints(self, value): self.otherConstraints.append(value)
    def insert_otherConstraints(self, index, value): self.otherConstraints[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_LegalConstraints_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_LegalConstraints_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_LegalConstraints_Type'):
        super(MD_LegalConstraints_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_LegalConstraints_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_LegalConstraints_Type', fromsubclass_=False):
        super(MD_LegalConstraints_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for accessConstraints_ in self.accessConstraints:
            accessConstraints_.export(outfile, level, namespace_, name_='accessConstraints')
        for useConstraints_ in self.useConstraints:
            useConstraints_.export(outfile, level, namespace_, name_='useConstraints')
        for otherConstraints_ in self.otherConstraints:
            otherConstraints_.export(outfile, level, namespace_, name_='otherConstraints')
    def hasContent_(self):
        if (
            self.accessConstraints or
            self.useConstraints or
            self.otherConstraints or
            super(MD_LegalConstraints_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_LegalConstraints_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_LegalConstraints_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_LegalConstraints_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('accessConstraints=[\n')
        level += 1
        for accessConstraints_ in self.accessConstraints:
            showIndent(outfile, level)
            outfile.write('model_.MD_RestrictionCode_PropertyType(\n')
            accessConstraints_.exportLiteral(outfile, level, name_='MD_RestrictionCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('useConstraints=[\n')
        level += 1
        for useConstraints_ in self.useConstraints:
            showIndent(outfile, level)
            outfile.write('model_.MD_RestrictionCode_PropertyType(\n')
            useConstraints_.exportLiteral(outfile, level, name_='MD_RestrictionCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('otherConstraints=[\n')
        level += 1
        for otherConstraints_ in self.otherConstraints:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            otherConstraints_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_LegalConstraints_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessConstraints':
            obj_ = MD_RestrictionCode_PropertyType.factory()
            obj_.build(child_)
            self.accessConstraints.append(obj_)
        elif nodeName_ == 'useConstraints':
            obj_ = MD_RestrictionCode_PropertyType.factory()
            obj_.build(child_)
            self.useConstraints.append(obj_)
        elif nodeName_ == 'otherConstraints':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.otherConstraints.append(obj_)
        super(MD_LegalConstraints_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_LegalConstraints_Type


class MD_LegalConstraints_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_LegalConstraints=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_LegalConstraints = MD_LegalConstraints
    def factory(*args_, **kwargs_):
        if MD_LegalConstraints_PropertyType.subclass:
            return MD_LegalConstraints_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_LegalConstraints_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_LegalConstraints(self): return self.MD_LegalConstraints
    def set_MD_LegalConstraints(self, MD_LegalConstraints): self.MD_LegalConstraints = MD_LegalConstraints
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_LegalConstraints_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_LegalConstraints_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_LegalConstraints_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_LegalConstraints_PropertyType', fromsubclass_=False):
        if self.MD_LegalConstraints is not None:
            self.MD_LegalConstraints.export(outfile, level, namespace_, name_='MD_LegalConstraints', )
    def hasContent_(self):
        if (
            self.MD_LegalConstraints is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_LegalConstraints_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_LegalConstraints is not None:
            showIndent(outfile, level)
            outfile.write('MD_LegalConstraints=model_.MD_LegalConstraints(\n')
            self.MD_LegalConstraints.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_LegalConstraints':
            obj_ = MD_LegalConstraints_Type.factory()
            obj_.build(child_)
            self.set_MD_LegalConstraints(obj_)
# end class MD_LegalConstraints_PropertyType


class MD_SecurityConstraints_Type(MD_Constraints_Type):
    """Handling restrictions imposed on the dataset because of national
    security, privacy, or other concerns"""
    subclass = None
    superclass = MD_Constraints_Type
    def __init__(self, id=None, uuid=None, useLimitation=None, classification=None, userNote=None, classificationSystem=None, handlingDescription=None):
        super(MD_SecurityConstraints_Type, self).__init__(id, uuid, useLimitation, )
        self.classification = classification
        self.userNote = userNote
        self.classificationSystem = classificationSystem
        self.handlingDescription = handlingDescription
    def factory(*args_, **kwargs_):
        if MD_SecurityConstraints_Type.subclass:
            return MD_SecurityConstraints_Type.subclass(*args_, **kwargs_)
        else:
            return MD_SecurityConstraints_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_userNote(self): return self.userNote
    def set_userNote(self, userNote): self.userNote = userNote
    def get_classificationSystem(self): return self.classificationSystem
    def set_classificationSystem(self, classificationSystem): self.classificationSystem = classificationSystem
    def get_handlingDescription(self): return self.handlingDescription
    def set_handlingDescription(self, handlingDescription): self.handlingDescription = handlingDescription
    def export(self, outfile, level, namespace_='', name_='MD_SecurityConstraints_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_SecurityConstraints_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_SecurityConstraints_Type'):
        super(MD_SecurityConstraints_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_SecurityConstraints_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_SecurityConstraints_Type', fromsubclass_=False):
        super(MD_SecurityConstraints_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.classification is not None:
            self.classification.export(outfile, level, namespace_, name_='classification', )
        if self.userNote is not None:
            self.userNote.export(outfile, level, namespace_, name_='userNote')
        if self.classificationSystem is not None:
            self.classificationSystem.export(outfile, level, namespace_, name_='classificationSystem')
        if self.handlingDescription is not None:
            self.handlingDescription.export(outfile, level, namespace_, name_='handlingDescription')
    def hasContent_(self):
        if (
            self.classification is not None or
            self.userNote is not None or
            self.classificationSystem is not None or
            self.handlingDescription is not None or
            super(MD_SecurityConstraints_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_SecurityConstraints_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_SecurityConstraints_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_SecurityConstraints_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.classification is not None:
            showIndent(outfile, level)
            outfile.write('classification=model_.MD_ClassificationCode_PropertyType(\n')
            self.classification.exportLiteral(outfile, level, name_='classification')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.userNote is not None:
            showIndent(outfile, level)
            outfile.write('userNote=model_.CharacterString_PropertyType(\n')
            self.userNote.exportLiteral(outfile, level, name_='userNote')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.classificationSystem is not None:
            showIndent(outfile, level)
            outfile.write('classificationSystem=model_.CharacterString_PropertyType(\n')
            self.classificationSystem.exportLiteral(outfile, level, name_='classificationSystem')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.handlingDescription is not None:
            showIndent(outfile, level)
            outfile.write('handlingDescription=model_.CharacterString_PropertyType(\n')
            self.handlingDescription.exportLiteral(outfile, level, name_='handlingDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_SecurityConstraints_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'classification':
            obj_ = MD_ClassificationCode_PropertyType.factory()
            obj_.build(child_)
            self.set_classification(obj_)
        elif nodeName_ == 'userNote':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_userNote(obj_)
        elif nodeName_ == 'classificationSystem':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_classificationSystem(obj_)
        elif nodeName_ == 'handlingDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_handlingDescription(obj_)
        super(MD_SecurityConstraints_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_SecurityConstraints_Type


class MD_SecurityConstraints_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_SecurityConstraints=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_SecurityConstraints = MD_SecurityConstraints
    def factory(*args_, **kwargs_):
        if MD_SecurityConstraints_PropertyType.subclass:
            return MD_SecurityConstraints_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_SecurityConstraints_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_SecurityConstraints(self): return self.MD_SecurityConstraints
    def set_MD_SecurityConstraints(self, MD_SecurityConstraints): self.MD_SecurityConstraints = MD_SecurityConstraints
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_SecurityConstraints_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_SecurityConstraints_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_SecurityConstraints_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_SecurityConstraints_PropertyType', fromsubclass_=False):
        if self.MD_SecurityConstraints is not None:
            self.MD_SecurityConstraints.export(outfile, level, namespace_, name_='MD_SecurityConstraints', )
    def hasContent_(self):
        if (
            self.MD_SecurityConstraints is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_SecurityConstraints_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_SecurityConstraints is not None:
            showIndent(outfile, level)
            outfile.write('MD_SecurityConstraints=model_.MD_SecurityConstraints(\n')
            self.MD_SecurityConstraints.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_SecurityConstraints':
            obj_ = MD_SecurityConstraints_Type.factory()
            obj_.build(child_)
            self.set_MD_SecurityConstraints(obj_)
# end class MD_SecurityConstraints_PropertyType


class MD_ClassificationCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ClassificationCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ClassificationCode = MD_ClassificationCode
    def factory(*args_, **kwargs_):
        if MD_ClassificationCode_PropertyType.subclass:
            return MD_ClassificationCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ClassificationCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ClassificationCode(self): return self.MD_ClassificationCode
    def set_MD_ClassificationCode(self, MD_ClassificationCode): self.MD_ClassificationCode = MD_ClassificationCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ClassificationCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ClassificationCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ClassificationCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ClassificationCode_PropertyType', fromsubclass_=False):
        if self.MD_ClassificationCode is not None:
            self.MD_ClassificationCode.export(outfile, level, namespace_, name_='MD_ClassificationCode', )
    def hasContent_(self):
        if (
            self.MD_ClassificationCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ClassificationCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ClassificationCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_ClassificationCode=model_.MD_ClassificationCode(\n')
            self.MD_ClassificationCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ClassificationCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_ClassificationCode(obj_)
# end class MD_ClassificationCode_PropertyType


class MD_RestrictionCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_RestrictionCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_RestrictionCode = MD_RestrictionCode
    def factory(*args_, **kwargs_):
        if MD_RestrictionCode_PropertyType.subclass:
            return MD_RestrictionCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_RestrictionCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_RestrictionCode(self): return self.MD_RestrictionCode
    def set_MD_RestrictionCode(self, MD_RestrictionCode): self.MD_RestrictionCode = MD_RestrictionCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_RestrictionCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_RestrictionCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_RestrictionCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_RestrictionCode_PropertyType', fromsubclass_=False):
        if self.MD_RestrictionCode is not None:
            self.MD_RestrictionCode.export(outfile, level, namespace_, name_='MD_RestrictionCode', )
    def hasContent_(self):
        if (
            self.MD_RestrictionCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_RestrictionCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_RestrictionCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_RestrictionCode=model_.MD_RestrictionCode(\n')
            self.MD_RestrictionCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_RestrictionCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_RestrictionCode(obj_)
# end class MD_RestrictionCode_PropertyType


class MD_Medium_Type(AbstractObject_Type):
    """Information about the media on which the data can be distributed"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, name=None, density=None, densityUnits=None, volumes=None, mediumFormat=None, mediumNote=None):
        super(MD_Medium_Type, self).__init__(id, uuid, )
        self.name = name
        if density is None:
            self.density = []
        else:
            self.density = density
        self.densityUnits = densityUnits
        self.volumes = volumes
        if mediumFormat is None:
            self.mediumFormat = []
        else:
            self.mediumFormat = mediumFormat
        self.mediumNote = mediumNote
    def factory(*args_, **kwargs_):
        if MD_Medium_Type.subclass:
            return MD_Medium_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Medium_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_density(self): return self.density
    def set_density(self, density): self.density = density
    def add_density(self, value): self.density.append(value)
    def insert_density(self, index, value): self.density[index] = value
    def get_densityUnits(self): return self.densityUnits
    def set_densityUnits(self, densityUnits): self.densityUnits = densityUnits
    def get_volumes(self): return self.volumes
    def set_volumes(self, volumes): self.volumes = volumes
    def get_mediumFormat(self): return self.mediumFormat
    def set_mediumFormat(self, mediumFormat): self.mediumFormat = mediumFormat
    def add_mediumFormat(self, value): self.mediumFormat.append(value)
    def insert_mediumFormat(self, index, value): self.mediumFormat[index] = value
    def get_mediumNote(self): return self.mediumNote
    def set_mediumNote(self, mediumNote): self.mediumNote = mediumNote
    def export(self, outfile, level, namespace_='', name_='MD_Medium_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Medium_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Medium_Type'):
        super(MD_Medium_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Medium_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Medium_Type', fromsubclass_=False):
        super(MD_Medium_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name')
        for density_ in self.density:
            density_.export(outfile, level, namespace_, name_='density')
        if self.densityUnits is not None:
            self.densityUnits.export(outfile, level, namespace_, name_='densityUnits')
        if self.volumes is not None:
            self.volumes.export(outfile, level, namespace_, name_='volumes')
        for mediumFormat_ in self.mediumFormat:
            mediumFormat_.export(outfile, level, namespace_, name_='mediumFormat')
        if self.mediumNote is not None:
            self.mediumNote.export(outfile, level, namespace_, name_='mediumNote')
    def hasContent_(self):
        if (
            self.name is not None or
            self.density or
            self.densityUnits is not None or
            self.volumes is not None or
            self.mediumFormat or
            self.mediumNote is not None or
            super(MD_Medium_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Medium_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Medium_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Medium_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.MD_MediumNameCode_PropertyType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('density=[\n')
        level += 1
        for density_ in self.density:
            showIndent(outfile, level)
            outfile.write('model_.Real_PropertyType(\n')
            density_.exportLiteral(outfile, level, name_='Real_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.densityUnits is not None:
            showIndent(outfile, level)
            outfile.write('densityUnits=model_.CharacterString_PropertyType(\n')
            self.densityUnits.exportLiteral(outfile, level, name_='densityUnits')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.volumes is not None:
            showIndent(outfile, level)
            outfile.write('volumes=model_.Integer_PropertyType(\n')
            self.volumes.exportLiteral(outfile, level, name_='volumes')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('mediumFormat=[\n')
        level += 1
        for mediumFormat_ in self.mediumFormat:
            showIndent(outfile, level)
            outfile.write('model_.MD_MediumFormatCode_PropertyType(\n')
            mediumFormat_.exportLiteral(outfile, level, name_='MD_MediumFormatCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.mediumNote is not None:
            showIndent(outfile, level)
            outfile.write('mediumNote=model_.CharacterString_PropertyType(\n')
            self.mediumNote.exportLiteral(outfile, level, name_='mediumNote')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Medium_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = MD_MediumNameCode_PropertyType.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'density':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.density.append(obj_)
        elif nodeName_ == 'densityUnits':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_densityUnits(obj_)
        elif nodeName_ == 'volumes':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_volumes(obj_)
        elif nodeName_ == 'mediumFormat':
            obj_ = MD_MediumFormatCode_PropertyType.factory()
            obj_.build(child_)
            self.mediumFormat.append(obj_)
        elif nodeName_ == 'mediumNote':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_mediumNote(obj_)
        super(MD_Medium_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Medium_Type


class MD_Medium_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Medium=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Medium = MD_Medium
    def factory(*args_, **kwargs_):
        if MD_Medium_PropertyType.subclass:
            return MD_Medium_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Medium_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Medium(self): return self.MD_Medium
    def set_MD_Medium(self, MD_Medium): self.MD_Medium = MD_Medium
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Medium_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Medium_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Medium_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Medium_PropertyType', fromsubclass_=False):
        if self.MD_Medium is not None:
            self.MD_Medium.export(outfile, level, namespace_, name_='MD_Medium', )
    def hasContent_(self):
        if (
            self.MD_Medium is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Medium_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Medium is not None:
            showIndent(outfile, level)
            outfile.write('MD_Medium=model_.MD_Medium(\n')
            self.MD_Medium.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Medium':
            obj_ = MD_Medium_Type.factory()
            obj_.build(child_)
            self.set_MD_Medium(obj_)
# end class MD_Medium_PropertyType


class MD_DigitalTransferOptions_Type(AbstractObject_Type):
    """Technical means and media by which a dataset is obtained from the
    distributor"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, unitsOfDistribution=None, transferSize=None, onLine=None, offLine=None):
        super(MD_DigitalTransferOptions_Type, self).__init__(id, uuid, )
        self.unitsOfDistribution = unitsOfDistribution
        self.transferSize = transferSize
        if onLine is None:
            self.onLine = []
        else:
            self.onLine = onLine
        self.offLine = offLine
    def factory(*args_, **kwargs_):
        if MD_DigitalTransferOptions_Type.subclass:
            return MD_DigitalTransferOptions_Type.subclass(*args_, **kwargs_)
        else:
            return MD_DigitalTransferOptions_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitsOfDistribution(self): return self.unitsOfDistribution
    def set_unitsOfDistribution(self, unitsOfDistribution): self.unitsOfDistribution = unitsOfDistribution
    def get_transferSize(self): return self.transferSize
    def set_transferSize(self, transferSize): self.transferSize = transferSize
    def get_onLine(self): return self.onLine
    def set_onLine(self, onLine): self.onLine = onLine
    def add_onLine(self, value): self.onLine.append(value)
    def insert_onLine(self, index, value): self.onLine[index] = value
    def get_offLine(self): return self.offLine
    def set_offLine(self, offLine): self.offLine = offLine
    def export(self, outfile, level, namespace_='', name_='MD_DigitalTransferOptions_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DigitalTransferOptions_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_DigitalTransferOptions_Type'):
        super(MD_DigitalTransferOptions_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DigitalTransferOptions_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_DigitalTransferOptions_Type', fromsubclass_=False):
        super(MD_DigitalTransferOptions_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.unitsOfDistribution is not None:
            self.unitsOfDistribution.export(outfile, level, namespace_, name_='unitsOfDistribution')
        if self.transferSize is not None:
            self.transferSize.export(outfile, level, namespace_, name_='transferSize')
        for onLine_ in self.onLine:
            onLine_.export(outfile, level, namespace_, name_='onLine')
        if self.offLine is not None:
            self.offLine.export(outfile, level, namespace_, name_='offLine')
    def hasContent_(self):
        if (
            self.unitsOfDistribution is not None or
            self.transferSize is not None or
            self.onLine or
            self.offLine is not None or
            super(MD_DigitalTransferOptions_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_DigitalTransferOptions_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_DigitalTransferOptions_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_DigitalTransferOptions_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.unitsOfDistribution is not None:
            showIndent(outfile, level)
            outfile.write('unitsOfDistribution=model_.CharacterString_PropertyType(\n')
            self.unitsOfDistribution.exportLiteral(outfile, level, name_='unitsOfDistribution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transferSize is not None:
            showIndent(outfile, level)
            outfile.write('transferSize=model_.Real_PropertyType(\n')
            self.transferSize.exportLiteral(outfile, level, name_='transferSize')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('onLine=[\n')
        level += 1
        for onLine_ in self.onLine:
            showIndent(outfile, level)
            outfile.write('model_.CI_OnlineResource_PropertyType(\n')
            onLine_.exportLiteral(outfile, level, name_='CI_OnlineResource_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.offLine is not None:
            showIndent(outfile, level)
            outfile.write('offLine=model_.MD_Medium_PropertyType(\n')
            self.offLine.exportLiteral(outfile, level, name_='offLine')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_DigitalTransferOptions_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unitsOfDistribution':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_unitsOfDistribution(obj_)
        elif nodeName_ == 'transferSize':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_transferSize(obj_)
        elif nodeName_ == 'onLine':
            obj_ = CI_OnlineResource_PropertyType.factory()
            obj_.build(child_)
            self.onLine.append(obj_)
        elif nodeName_ == 'offLine':
            obj_ = MD_Medium_PropertyType.factory()
            obj_.build(child_)
            self.set_offLine(obj_)
        super(MD_DigitalTransferOptions_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_DigitalTransferOptions_Type


class MD_DigitalTransferOptions_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_DigitalTransferOptions=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_DigitalTransferOptions = MD_DigitalTransferOptions
    def factory(*args_, **kwargs_):
        if MD_DigitalTransferOptions_PropertyType.subclass:
            return MD_DigitalTransferOptions_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_DigitalTransferOptions_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_DigitalTransferOptions(self): return self.MD_DigitalTransferOptions
    def set_MD_DigitalTransferOptions(self, MD_DigitalTransferOptions): self.MD_DigitalTransferOptions = MD_DigitalTransferOptions
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_DigitalTransferOptions_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DigitalTransferOptions_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_DigitalTransferOptions_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_DigitalTransferOptions_PropertyType', fromsubclass_=False):
        if self.MD_DigitalTransferOptions is not None:
            self.MD_DigitalTransferOptions.export(outfile, level, namespace_, name_='MD_DigitalTransferOptions', )
    def hasContent_(self):
        if (
            self.MD_DigitalTransferOptions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_DigitalTransferOptions_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_DigitalTransferOptions is not None:
            showIndent(outfile, level)
            outfile.write('MD_DigitalTransferOptions=model_.MD_DigitalTransferOptions(\n')
            self.MD_DigitalTransferOptions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_DigitalTransferOptions':
            obj_ = MD_DigitalTransferOptions_Type.factory()
            obj_.build(child_)
            self.set_MD_DigitalTransferOptions(obj_)
# end class MD_DigitalTransferOptions_PropertyType


class MD_StandardOrderProcess_Type(AbstractObject_Type):
    """Common ways in which the dataset may be obtained or received, and
    related instructions and fee information"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, fees=None, plannedAvailableDateTime=None, orderingInstructions=None, turnaround=None):
        super(MD_StandardOrderProcess_Type, self).__init__(id, uuid, )
        self.fees = fees
        self.plannedAvailableDateTime = plannedAvailableDateTime
        self.orderingInstructions = orderingInstructions
        self.turnaround = turnaround
    def factory(*args_, **kwargs_):
        if MD_StandardOrderProcess_Type.subclass:
            return MD_StandardOrderProcess_Type.subclass(*args_, **kwargs_)
        else:
            return MD_StandardOrderProcess_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fees(self): return self.fees
    def set_fees(self, fees): self.fees = fees
    def get_plannedAvailableDateTime(self): return self.plannedAvailableDateTime
    def set_plannedAvailableDateTime(self, plannedAvailableDateTime): self.plannedAvailableDateTime = plannedAvailableDateTime
    def get_orderingInstructions(self): return self.orderingInstructions
    def set_orderingInstructions(self, orderingInstructions): self.orderingInstructions = orderingInstructions
    def get_turnaround(self): return self.turnaround
    def set_turnaround(self, turnaround): self.turnaround = turnaround
    def export(self, outfile, level, namespace_='', name_='MD_StandardOrderProcess_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_StandardOrderProcess_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_StandardOrderProcess_Type'):
        super(MD_StandardOrderProcess_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_StandardOrderProcess_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_StandardOrderProcess_Type', fromsubclass_=False):
        super(MD_StandardOrderProcess_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.fees is not None:
            self.fees.export(outfile, level, namespace_, name_='fees')
        if self.plannedAvailableDateTime is not None:
            self.plannedAvailableDateTime.export(outfile, level, namespace_, name_='plannedAvailableDateTime')
        if self.orderingInstructions is not None:
            self.orderingInstructions.export(outfile, level, namespace_, name_='orderingInstructions')
        if self.turnaround is not None:
            self.turnaround.export(outfile, level, namespace_, name_='turnaround')
    def hasContent_(self):
        if (
            self.fees is not None or
            self.plannedAvailableDateTime is not None or
            self.orderingInstructions is not None or
            self.turnaround is not None or
            super(MD_StandardOrderProcess_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_StandardOrderProcess_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_StandardOrderProcess_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_StandardOrderProcess_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.fees is not None:
            showIndent(outfile, level)
            outfile.write('fees=model_.CharacterString_PropertyType(\n')
            self.fees.exportLiteral(outfile, level, name_='fees')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.plannedAvailableDateTime is not None:
            showIndent(outfile, level)
            outfile.write('plannedAvailableDateTime=model_.DateTime_PropertyType(\n')
            self.plannedAvailableDateTime.exportLiteral(outfile, level, name_='plannedAvailableDateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orderingInstructions is not None:
            showIndent(outfile, level)
            outfile.write('orderingInstructions=model_.CharacterString_PropertyType(\n')
            self.orderingInstructions.exportLiteral(outfile, level, name_='orderingInstructions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.turnaround is not None:
            showIndent(outfile, level)
            outfile.write('turnaround=model_.CharacterString_PropertyType(\n')
            self.turnaround.exportLiteral(outfile, level, name_='turnaround')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_StandardOrderProcess_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fees':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_fees(obj_)
        elif nodeName_ == 'plannedAvailableDateTime':
            obj_ = DateTime_PropertyType.factory()
            obj_.build(child_)
            self.set_plannedAvailableDateTime(obj_)
        elif nodeName_ == 'orderingInstructions':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_orderingInstructions(obj_)
        elif nodeName_ == 'turnaround':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_turnaround(obj_)
        super(MD_StandardOrderProcess_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_StandardOrderProcess_Type


class MD_StandardOrderProcess_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_StandardOrderProcess=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_StandardOrderProcess = MD_StandardOrderProcess
    def factory(*args_, **kwargs_):
        if MD_StandardOrderProcess_PropertyType.subclass:
            return MD_StandardOrderProcess_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_StandardOrderProcess_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_StandardOrderProcess(self): return self.MD_StandardOrderProcess
    def set_MD_StandardOrderProcess(self, MD_StandardOrderProcess): self.MD_StandardOrderProcess = MD_StandardOrderProcess
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_StandardOrderProcess_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_StandardOrderProcess_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_StandardOrderProcess_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_StandardOrderProcess_PropertyType', fromsubclass_=False):
        if self.MD_StandardOrderProcess is not None:
            self.MD_StandardOrderProcess.export(outfile, level, namespace_, name_='MD_StandardOrderProcess', )
    def hasContent_(self):
        if (
            self.MD_StandardOrderProcess is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_StandardOrderProcess_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_StandardOrderProcess is not None:
            showIndent(outfile, level)
            outfile.write('MD_StandardOrderProcess=model_.MD_StandardOrderProcess(\n')
            self.MD_StandardOrderProcess.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_StandardOrderProcess':
            obj_ = MD_StandardOrderProcess_Type.factory()
            obj_.build(child_)
            self.set_MD_StandardOrderProcess(obj_)
# end class MD_StandardOrderProcess_PropertyType


class MD_Distributor_Type(AbstractObject_Type):
    """Information about the distributor"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, distributorContact=None, distributionOrderProcess=None, distributorFormat=None, distributorTransferOptions=None):
        super(MD_Distributor_Type, self).__init__(id, uuid, )
        self.distributorContact = distributorContact
        if distributionOrderProcess is None:
            self.distributionOrderProcess = []
        else:
            self.distributionOrderProcess = distributionOrderProcess
        if distributorFormat is None:
            self.distributorFormat = []
        else:
            self.distributorFormat = distributorFormat
        if distributorTransferOptions is None:
            self.distributorTransferOptions = []
        else:
            self.distributorTransferOptions = distributorTransferOptions
    def factory(*args_, **kwargs_):
        if MD_Distributor_Type.subclass:
            return MD_Distributor_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Distributor_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distributorContact(self): return self.distributorContact
    def set_distributorContact(self, distributorContact): self.distributorContact = distributorContact
    def get_distributionOrderProcess(self): return self.distributionOrderProcess
    def set_distributionOrderProcess(self, distributionOrderProcess): self.distributionOrderProcess = distributionOrderProcess
    def add_distributionOrderProcess(self, value): self.distributionOrderProcess.append(value)
    def insert_distributionOrderProcess(self, index, value): self.distributionOrderProcess[index] = value
    def get_distributorFormat(self): return self.distributorFormat
    def set_distributorFormat(self, distributorFormat): self.distributorFormat = distributorFormat
    def add_distributorFormat(self, value): self.distributorFormat.append(value)
    def insert_distributorFormat(self, index, value): self.distributorFormat[index] = value
    def get_distributorTransferOptions(self): return self.distributorTransferOptions
    def set_distributorTransferOptions(self, distributorTransferOptions): self.distributorTransferOptions = distributorTransferOptions
    def add_distributorTransferOptions(self, value): self.distributorTransferOptions.append(value)
    def insert_distributorTransferOptions(self, index, value): self.distributorTransferOptions[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_Distributor_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Distributor_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Distributor_Type'):
        super(MD_Distributor_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Distributor_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Distributor_Type', fromsubclass_=False):
        super(MD_Distributor_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.distributorContact is not None:
            self.distributorContact.export(outfile, level, namespace_, name_='distributorContact', )
        for distributionOrderProcess_ in self.distributionOrderProcess:
            distributionOrderProcess_.export(outfile, level, namespace_, name_='distributionOrderProcess')
        for distributorFormat_ in self.distributorFormat:
            distributorFormat_.export(outfile, level, namespace_, name_='distributorFormat')
        for distributorTransferOptions_ in self.distributorTransferOptions:
            distributorTransferOptions_.export(outfile, level, namespace_, name_='distributorTransferOptions')
    def hasContent_(self):
        if (
            self.distributorContact is not None or
            self.distributionOrderProcess or
            self.distributorFormat or
            self.distributorTransferOptions or
            super(MD_Distributor_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Distributor_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Distributor_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Distributor_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.distributorContact is not None:
            showIndent(outfile, level)
            outfile.write('distributorContact=model_.CI_ResponsibleParty_PropertyType(\n')
            self.distributorContact.exportLiteral(outfile, level, name_='distributorContact')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('distributionOrderProcess=[\n')
        level += 1
        for distributionOrderProcess_ in self.distributionOrderProcess:
            showIndent(outfile, level)
            outfile.write('model_.MD_StandardOrderProcess_PropertyType(\n')
            distributionOrderProcess_.exportLiteral(outfile, level, name_='MD_StandardOrderProcess_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('distributorFormat=[\n')
        level += 1
        for distributorFormat_ in self.distributorFormat:
            showIndent(outfile, level)
            outfile.write('model_.MD_Format_PropertyType(\n')
            distributorFormat_.exportLiteral(outfile, level, name_='MD_Format_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('distributorTransferOptions=[\n')
        level += 1
        for distributorTransferOptions_ in self.distributorTransferOptions:
            showIndent(outfile, level)
            outfile.write('model_.MD_DigitalTransferOptions_PropertyType(\n')
            distributorTransferOptions_.exportLiteral(outfile, level, name_='MD_DigitalTransferOptions_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Distributor_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'distributorContact':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.set_distributorContact(obj_)
        elif nodeName_ == 'distributionOrderProcess':
            obj_ = MD_StandardOrderProcess_PropertyType.factory()
            obj_.build(child_)
            self.distributionOrderProcess.append(obj_)
        elif nodeName_ == 'distributorFormat':
            obj_ = MD_Format_PropertyType.factory()
            obj_.build(child_)
            self.distributorFormat.append(obj_)
        elif nodeName_ == 'distributorTransferOptions':
            obj_ = MD_DigitalTransferOptions_PropertyType.factory()
            obj_.build(child_)
            self.distributorTransferOptions.append(obj_)
        super(MD_Distributor_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Distributor_Type


class MD_Distributor_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Distributor=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Distributor = MD_Distributor
    def factory(*args_, **kwargs_):
        if MD_Distributor_PropertyType.subclass:
            return MD_Distributor_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Distributor_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Distributor(self): return self.MD_Distributor
    def set_MD_Distributor(self, MD_Distributor): self.MD_Distributor = MD_Distributor
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Distributor_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Distributor_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Distributor_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Distributor_PropertyType', fromsubclass_=False):
        if self.MD_Distributor is not None:
            self.MD_Distributor.export(outfile, level, namespace_, name_='MD_Distributor', )
    def hasContent_(self):
        if (
            self.MD_Distributor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Distributor_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Distributor is not None:
            showIndent(outfile, level)
            outfile.write('MD_Distributor=model_.MD_Distributor(\n')
            self.MD_Distributor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Distributor':
            obj_ = MD_Distributor_Type.factory()
            obj_.build(child_)
            self.set_MD_Distributor(obj_)
# end class MD_Distributor_PropertyType


class MD_Distribution_Type(AbstractObject_Type):
    """Information about the distributor of and options for obtaining the
    dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, distributionFormat=None, distributor=None, transferOptions=None):
        super(MD_Distribution_Type, self).__init__(id, uuid, )
        if distributionFormat is None:
            self.distributionFormat = []
        else:
            self.distributionFormat = distributionFormat
        if distributor is None:
            self.distributor = []
        else:
            self.distributor = distributor
        if transferOptions is None:
            self.transferOptions = []
        else:
            self.transferOptions = transferOptions
    def factory(*args_, **kwargs_):
        if MD_Distribution_Type.subclass:
            return MD_Distribution_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Distribution_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distributionFormat(self): return self.distributionFormat
    def set_distributionFormat(self, distributionFormat): self.distributionFormat = distributionFormat
    def add_distributionFormat(self, value): self.distributionFormat.append(value)
    def insert_distributionFormat(self, index, value): self.distributionFormat[index] = value
    def get_distributor(self): return self.distributor
    def set_distributor(self, distributor): self.distributor = distributor
    def add_distributor(self, value): self.distributor.append(value)
    def insert_distributor(self, index, value): self.distributor[index] = value
    def get_transferOptions(self): return self.transferOptions
    def set_transferOptions(self, transferOptions): self.transferOptions = transferOptions
    def add_transferOptions(self, value): self.transferOptions.append(value)
    def insert_transferOptions(self, index, value): self.transferOptions[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_Distribution_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Distribution_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Distribution_Type'):
        super(MD_Distribution_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Distribution_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Distribution_Type', fromsubclass_=False):
        super(MD_Distribution_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for distributionFormat_ in self.distributionFormat:
            distributionFormat_.export(outfile, level, namespace_, name_='distributionFormat')
        for distributor_ in self.distributor:
            distributor_.export(outfile, level, namespace_, name_='distributor')
        for transferOptions_ in self.transferOptions:
            transferOptions_.export(outfile, level, namespace_, name_='transferOptions')
    def hasContent_(self):
        if (
            self.distributionFormat or
            self.distributor or
            self.transferOptions or
            super(MD_Distribution_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Distribution_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Distribution_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Distribution_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('distributionFormat=[\n')
        level += 1
        for distributionFormat_ in self.distributionFormat:
            showIndent(outfile, level)
            outfile.write('model_.MD_Format_PropertyType(\n')
            distributionFormat_.exportLiteral(outfile, level, name_='MD_Format_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('distributor=[\n')
        level += 1
        for distributor_ in self.distributor:
            showIndent(outfile, level)
            outfile.write('model_.MD_Distributor_PropertyType(\n')
            distributor_.exportLiteral(outfile, level, name_='MD_Distributor_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transferOptions=[\n')
        level += 1
        for transferOptions_ in self.transferOptions:
            showIndent(outfile, level)
            outfile.write('model_.MD_DigitalTransferOptions_PropertyType(\n')
            transferOptions_.exportLiteral(outfile, level, name_='MD_DigitalTransferOptions_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Distribution_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'distributionFormat':
            obj_ = MD_Format_PropertyType.factory()
            obj_.build(child_)
            self.distributionFormat.append(obj_)
        elif nodeName_ == 'distributor':
            obj_ = MD_Distributor_PropertyType.factory()
            obj_.build(child_)
            self.distributor.append(obj_)
        elif nodeName_ == 'transferOptions':
            obj_ = MD_DigitalTransferOptions_PropertyType.factory()
            obj_.build(child_)
            self.transferOptions.append(obj_)
        super(MD_Distribution_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Distribution_Type


class MD_Distribution_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Distribution=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Distribution = MD_Distribution
    def factory(*args_, **kwargs_):
        if MD_Distribution_PropertyType.subclass:
            return MD_Distribution_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Distribution_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Distribution(self): return self.MD_Distribution
    def set_MD_Distribution(self, MD_Distribution): self.MD_Distribution = MD_Distribution
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Distribution_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Distribution_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Distribution_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Distribution_PropertyType', fromsubclass_=False):
        if self.MD_Distribution is not None:
            self.MD_Distribution.export(outfile, level, namespace_, name_='MD_Distribution', )
    def hasContent_(self):
        if (
            self.MD_Distribution is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Distribution_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Distribution is not None:
            showIndent(outfile, level)
            outfile.write('MD_Distribution=model_.MD_Distribution(\n')
            self.MD_Distribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Distribution':
            obj_ = MD_Distribution_Type.factory()
            obj_.build(child_)
            self.set_MD_Distribution(obj_)
# end class MD_Distribution_PropertyType


class MD_Format_Type(AbstractObject_Type):
    """Description of the form of the data to be distributed"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, name=None, version=None, amendmentNumber=None, specification=None, fileDecompressionTechnique=None, formatDistributor=None):
        super(MD_Format_Type, self).__init__(id, uuid, )
        self.name = name
        self.version = version
        self.amendmentNumber = amendmentNumber
        self.specification = specification
        self.fileDecompressionTechnique = fileDecompressionTechnique
        if formatDistributor is None:
            self.formatDistributor = []
        else:
            self.formatDistributor = formatDistributor
    def factory(*args_, **kwargs_):
        if MD_Format_Type.subclass:
            return MD_Format_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Format_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_amendmentNumber(self): return self.amendmentNumber
    def set_amendmentNumber(self, amendmentNumber): self.amendmentNumber = amendmentNumber
    def get_specification(self): return self.specification
    def set_specification(self, specification): self.specification = specification
    def get_fileDecompressionTechnique(self): return self.fileDecompressionTechnique
    def set_fileDecompressionTechnique(self, fileDecompressionTechnique): self.fileDecompressionTechnique = fileDecompressionTechnique
    def get_formatDistributor(self): return self.formatDistributor
    def set_formatDistributor(self, formatDistributor): self.formatDistributor = formatDistributor
    def add_formatDistributor(self, value): self.formatDistributor.append(value)
    def insert_formatDistributor(self, index, value): self.formatDistributor[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_Format_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Format_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Format_Type'):
        super(MD_Format_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Format_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Format_Type', fromsubclass_=False):
        super(MD_Format_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', )
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', )
        if self.amendmentNumber is not None:
            self.amendmentNumber.export(outfile, level, namespace_, name_='amendmentNumber')
        if self.specification is not None:
            self.specification.export(outfile, level, namespace_, name_='specification')
        if self.fileDecompressionTechnique is not None:
            self.fileDecompressionTechnique.export(outfile, level, namespace_, name_='fileDecompressionTechnique')
        for formatDistributor_ in self.formatDistributor:
            formatDistributor_.export(outfile, level, namespace_, name_='formatDistributor')
    def hasContent_(self):
        if (
            self.name is not None or
            self.version is not None or
            self.amendmentNumber is not None or
            self.specification is not None or
            self.fileDecompressionTechnique is not None or
            self.formatDistributor or
            super(MD_Format_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Format_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Format_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Format_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.CharacterString_PropertyType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.CharacterString_PropertyType(\n')
            self.version.exportLiteral(outfile, level, name_='version')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.amendmentNumber is not None:
            showIndent(outfile, level)
            outfile.write('amendmentNumber=model_.CharacterString_PropertyType(\n')
            self.amendmentNumber.exportLiteral(outfile, level, name_='amendmentNumber')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.specification is not None:
            showIndent(outfile, level)
            outfile.write('specification=model_.CharacterString_PropertyType(\n')
            self.specification.exportLiteral(outfile, level, name_='specification')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fileDecompressionTechnique is not None:
            showIndent(outfile, level)
            outfile.write('fileDecompressionTechnique=model_.CharacterString_PropertyType(\n')
            self.fileDecompressionTechnique.exportLiteral(outfile, level, name_='fileDecompressionTechnique')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('formatDistributor=[\n')
        level += 1
        for formatDistributor_ in self.formatDistributor:
            showIndent(outfile, level)
            outfile.write('model_.MD_Distributor_PropertyType(\n')
            formatDistributor_.exportLiteral(outfile, level, name_='MD_Distributor_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Format_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'version':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_version(obj_)
        elif nodeName_ == 'amendmentNumber':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_amendmentNumber(obj_)
        elif nodeName_ == 'specification':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_specification(obj_)
        elif nodeName_ == 'fileDecompressionTechnique':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_fileDecompressionTechnique(obj_)
        elif nodeName_ == 'formatDistributor':
            obj_ = MD_Distributor_PropertyType.factory()
            obj_.build(child_)
            self.formatDistributor.append(obj_)
        super(MD_Format_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Format_Type


class MD_Format_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_Format=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_Format = MD_Format
    def factory(*args_, **kwargs_):
        if MD_Format_PropertyType.subclass:
            return MD_Format_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_Format_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_Format(self): return self.MD_Format
    def set_MD_Format(self, MD_Format): self.MD_Format = MD_Format
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_Format_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Format_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Format_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Format_PropertyType', fromsubclass_=False):
        if self.MD_Format is not None:
            self.MD_Format.export(outfile, level, namespace_, name_='MD_Format', )
    def hasContent_(self):
        if (
            self.MD_Format is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Format_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_Format is not None:
            showIndent(outfile, level)
            outfile.write('MD_Format=model_.MD_Format(\n')
            self.MD_Format.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_Format':
            obj_ = MD_Format_Type.factory()
            obj_.build(child_)
            self.set_MD_Format(obj_)
# end class MD_Format_PropertyType


class MD_DistributionUnits_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_DistributionUnits=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_DistributionUnits = MD_DistributionUnits
    def factory(*args_, **kwargs_):
        if MD_DistributionUnits_PropertyType.subclass:
            return MD_DistributionUnits_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_DistributionUnits_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_DistributionUnits(self): return self.MD_DistributionUnits
    def set_MD_DistributionUnits(self, MD_DistributionUnits): self.MD_DistributionUnits = MD_DistributionUnits
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_DistributionUnits_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_DistributionUnits_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_DistributionUnits_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_DistributionUnits_PropertyType', fromsubclass_=False):
        if self.MD_DistributionUnits is not None:
            self.MD_DistributionUnits.export(outfile, level, namespace_, name_='MD_DistributionUnits', )
    def hasContent_(self):
        if (
            self.MD_DistributionUnits is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_DistributionUnits_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_DistributionUnits is not None:
            showIndent(outfile, level)
            outfile.write('MD_DistributionUnits=model_.MD_DistributionUnits(\n')
            self.MD_DistributionUnits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_DistributionUnits':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_DistributionUnits(obj_)
# end class MD_DistributionUnits_PropertyType


class MD_MediumFormatCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_MediumFormatCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_MediumFormatCode = MD_MediumFormatCode
    def factory(*args_, **kwargs_):
        if MD_MediumFormatCode_PropertyType.subclass:
            return MD_MediumFormatCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_MediumFormatCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_MediumFormatCode(self): return self.MD_MediumFormatCode
    def set_MD_MediumFormatCode(self, MD_MediumFormatCode): self.MD_MediumFormatCode = MD_MediumFormatCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_MediumFormatCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MediumFormatCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_MediumFormatCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_MediumFormatCode_PropertyType', fromsubclass_=False):
        if self.MD_MediumFormatCode is not None:
            self.MD_MediumFormatCode.export(outfile, level, namespace_, name_='MD_MediumFormatCode', )
    def hasContent_(self):
        if (
            self.MD_MediumFormatCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_MediumFormatCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_MediumFormatCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_MediumFormatCode=model_.MD_MediumFormatCode(\n')
            self.MD_MediumFormatCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_MediumFormatCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_MediumFormatCode(obj_)
# end class MD_MediumFormatCode_PropertyType


class MD_MediumNameCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_MediumNameCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_MediumNameCode = MD_MediumNameCode
    def factory(*args_, **kwargs_):
        if MD_MediumNameCode_PropertyType.subclass:
            return MD_MediumNameCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_MediumNameCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_MediumNameCode(self): return self.MD_MediumNameCode
    def set_MD_MediumNameCode(self, MD_MediumNameCode): self.MD_MediumNameCode = MD_MediumNameCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_MediumNameCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MediumNameCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_MediumNameCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_MediumNameCode_PropertyType', fromsubclass_=False):
        if self.MD_MediumNameCode is not None:
            self.MD_MediumNameCode.export(outfile, level, namespace_, name_='MD_MediumNameCode', )
    def hasContent_(self):
        if (
            self.MD_MediumNameCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_MediumNameCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_MediumNameCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_MediumNameCode=model_.MD_MediumNameCode(\n')
            self.MD_MediumNameCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_MediumNameCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_MediumNameCode(obj_)
# end class MD_MediumNameCode_PropertyType


class MD_MaintenanceInformation_Type(AbstractObject_Type):
    """Information about the scope and frequency of updating"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, maintenanceAndUpdateFrequency=None, dateOfNextUpdate=None, userDefinedMaintenanceFrequency=None, updateScope=None, updateScopeDescription=None, maintenanceNote=None, contact=None):
        super(MD_MaintenanceInformation_Type, self).__init__(id, uuid, )
        self.maintenanceAndUpdateFrequency = maintenanceAndUpdateFrequency
        self.dateOfNextUpdate = dateOfNextUpdate
        self.userDefinedMaintenanceFrequency = userDefinedMaintenanceFrequency
        if updateScope is None:
            self.updateScope = []
        else:
            self.updateScope = updateScope
        if updateScopeDescription is None:
            self.updateScopeDescription = []
        else:
            self.updateScopeDescription = updateScopeDescription
        if maintenanceNote is None:
            self.maintenanceNote = []
        else:
            self.maintenanceNote = maintenanceNote
        if contact is None:
            self.contact = []
        else:
            self.contact = contact
    def factory(*args_, **kwargs_):
        if MD_MaintenanceInformation_Type.subclass:
            return MD_MaintenanceInformation_Type.subclass(*args_, **kwargs_)
        else:
            return MD_MaintenanceInformation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maintenanceAndUpdateFrequency(self): return self.maintenanceAndUpdateFrequency
    def set_maintenanceAndUpdateFrequency(self, maintenanceAndUpdateFrequency): self.maintenanceAndUpdateFrequency = maintenanceAndUpdateFrequency
    def get_dateOfNextUpdate(self): return self.dateOfNextUpdate
    def set_dateOfNextUpdate(self, dateOfNextUpdate): self.dateOfNextUpdate = dateOfNextUpdate
    def get_userDefinedMaintenanceFrequency(self): return self.userDefinedMaintenanceFrequency
    def set_userDefinedMaintenanceFrequency(self, userDefinedMaintenanceFrequency): self.userDefinedMaintenanceFrequency = userDefinedMaintenanceFrequency
    def get_updateScope(self): return self.updateScope
    def set_updateScope(self, updateScope): self.updateScope = updateScope
    def add_updateScope(self, value): self.updateScope.append(value)
    def insert_updateScope(self, index, value): self.updateScope[index] = value
    def get_updateScopeDescription(self): return self.updateScopeDescription
    def set_updateScopeDescription(self, updateScopeDescription): self.updateScopeDescription = updateScopeDescription
    def add_updateScopeDescription(self, value): self.updateScopeDescription.append(value)
    def insert_updateScopeDescription(self, index, value): self.updateScopeDescription[index] = value
    def get_maintenanceNote(self): return self.maintenanceNote
    def set_maintenanceNote(self, maintenanceNote): self.maintenanceNote = maintenanceNote
    def add_maintenanceNote(self, value): self.maintenanceNote.append(value)
    def insert_maintenanceNote(self, index, value): self.maintenanceNote[index] = value
    def get_contact(self): return self.contact
    def set_contact(self, contact): self.contact = contact
    def add_contact(self, value): self.contact.append(value)
    def insert_contact(self, index, value): self.contact[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_MaintenanceInformation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MaintenanceInformation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_MaintenanceInformation_Type'):
        super(MD_MaintenanceInformation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MaintenanceInformation_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_MaintenanceInformation_Type', fromsubclass_=False):
        super(MD_MaintenanceInformation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.maintenanceAndUpdateFrequency is not None:
            self.maintenanceAndUpdateFrequency.export(outfile, level, namespace_, name_='maintenanceAndUpdateFrequency', )
        if self.dateOfNextUpdate is not None:
            self.dateOfNextUpdate.export(outfile, level, namespace_, name_='dateOfNextUpdate')
        if self.userDefinedMaintenanceFrequency is not None:
            self.userDefinedMaintenanceFrequency.export(outfile, level, namespace_, name_='userDefinedMaintenanceFrequency')
        for updateScope_ in self.updateScope:
            updateScope_.export(outfile, level, namespace_, name_='updateScope')
        for updateScopeDescription_ in self.updateScopeDescription:
            updateScopeDescription_.export(outfile, level, namespace_, name_='updateScopeDescription')
        for maintenanceNote_ in self.maintenanceNote:
            maintenanceNote_.export(outfile, level, namespace_, name_='maintenanceNote')
        for contact_ in self.contact:
            contact_.export(outfile, level, namespace_, name_='contact')
    def hasContent_(self):
        if (
            self.maintenanceAndUpdateFrequency is not None or
            self.dateOfNextUpdate is not None or
            self.userDefinedMaintenanceFrequency is not None or
            self.updateScope or
            self.updateScopeDescription or
            self.maintenanceNote or
            self.contact or
            super(MD_MaintenanceInformation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_MaintenanceInformation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_MaintenanceInformation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_MaintenanceInformation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.maintenanceAndUpdateFrequency is not None:
            showIndent(outfile, level)
            outfile.write('maintenanceAndUpdateFrequency=model_.MD_MaintenanceFrequencyCode_PropertyType(\n')
            self.maintenanceAndUpdateFrequency.exportLiteral(outfile, level, name_='maintenanceAndUpdateFrequency')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateOfNextUpdate is not None:
            showIndent(outfile, level)
            outfile.write('dateOfNextUpdate=model_.Date_PropertyType(\n')
            self.dateOfNextUpdate.exportLiteral(outfile, level, name_='dateOfNextUpdate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.userDefinedMaintenanceFrequency is not None:
            showIndent(outfile, level)
            outfile.write('userDefinedMaintenanceFrequency=model_.TM_PeriodDuration_PropertyType(\n')
            self.userDefinedMaintenanceFrequency.exportLiteral(outfile, level, name_='userDefinedMaintenanceFrequency')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('updateScope=[\n')
        level += 1
        for updateScope_ in self.updateScope:
            showIndent(outfile, level)
            outfile.write('model_.MD_ScopeCode_PropertyType(\n')
            updateScope_.exportLiteral(outfile, level, name_='MD_ScopeCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('updateScopeDescription=[\n')
        level += 1
        for updateScopeDescription_ in self.updateScopeDescription:
            showIndent(outfile, level)
            outfile.write('model_.MD_ScopeDescription_PropertyType(\n')
            updateScopeDescription_.exportLiteral(outfile, level, name_='MD_ScopeDescription_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('maintenanceNote=[\n')
        level += 1
        for maintenanceNote_ in self.maintenanceNote:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            maintenanceNote_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contact=[\n')
        level += 1
        for contact_ in self.contact:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            contact_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_MaintenanceInformation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'maintenanceAndUpdateFrequency':
            obj_ = MD_MaintenanceFrequencyCode_PropertyType.factory()
            obj_.build(child_)
            self.set_maintenanceAndUpdateFrequency(obj_)
        elif nodeName_ == 'dateOfNextUpdate':
            obj_ = Date_PropertyType.factory()
            obj_.build(child_)
            self.set_dateOfNextUpdate(obj_)
        elif nodeName_ == 'userDefinedMaintenanceFrequency':
            obj_ = TM_PeriodDuration_PropertyType.factory()
            obj_.build(child_)
            self.set_userDefinedMaintenanceFrequency(obj_)
        elif nodeName_ == 'updateScope':
            obj_ = MD_ScopeCode_PropertyType.factory()
            obj_.build(child_)
            self.updateScope.append(obj_)
        elif nodeName_ == 'updateScopeDescription':
            obj_ = MD_ScopeDescription_PropertyType.factory()
            obj_.build(child_)
            self.updateScopeDescription.append(obj_)
        elif nodeName_ == 'maintenanceNote':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.maintenanceNote.append(obj_)
        elif nodeName_ == 'contact':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.contact.append(obj_)
        super(MD_MaintenanceInformation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_MaintenanceInformation_Type


class MD_MaintenanceInformation_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_MaintenanceInformation=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_MaintenanceInformation = MD_MaintenanceInformation
    def factory(*args_, **kwargs_):
        if MD_MaintenanceInformation_PropertyType.subclass:
            return MD_MaintenanceInformation_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_MaintenanceInformation_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_MaintenanceInformation(self): return self.MD_MaintenanceInformation
    def set_MD_MaintenanceInformation(self, MD_MaintenanceInformation): self.MD_MaintenanceInformation = MD_MaintenanceInformation
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_MaintenanceInformation_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MaintenanceInformation_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_MaintenanceInformation_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_MaintenanceInformation_PropertyType', fromsubclass_=False):
        if self.MD_MaintenanceInformation is not None:
            self.MD_MaintenanceInformation.export(outfile, level, namespace_, name_='MD_MaintenanceInformation', )
    def hasContent_(self):
        if (
            self.MD_MaintenanceInformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_MaintenanceInformation_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_MaintenanceInformation is not None:
            showIndent(outfile, level)
            outfile.write('MD_MaintenanceInformation=model_.MD_MaintenanceInformation(\n')
            self.MD_MaintenanceInformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_MaintenanceInformation':
            obj_ = MD_MaintenanceInformation_Type.factory()
            obj_.build(child_)
            self.set_MD_MaintenanceInformation(obj_)
# end class MD_MaintenanceInformation_PropertyType


class MD_ScopeDescription_Type(GeneratedsSuper):
    """Description of the class of information covered by the information"""
    subclass = None
    superclass = None
    def __init__(self, attributes=None, features=None, featureInstances=None, attributeInstances=None, dataset=None, other=None):
        if attributes is None:
            self.attributes = []
        else:
            self.attributes = attributes
        if features is None:
            self.features = []
        else:
            self.features = features
        if featureInstances is None:
            self.featureInstances = []
        else:
            self.featureInstances = featureInstances
        if attributeInstances is None:
            self.attributeInstances = []
        else:
            self.attributeInstances = attributeInstances
        self.dataset = dataset
        self.other = other
    def factory(*args_, **kwargs_):
        if MD_ScopeDescription_Type.subclass:
            return MD_ScopeDescription_Type.subclass(*args_, **kwargs_)
        else:
            return MD_ScopeDescription_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attributes(self): return self.attributes
    def set_attributes(self, attributes): self.attributes = attributes
    def add_attributes(self, value): self.attributes.append(value)
    def insert_attributes(self, index, value): self.attributes[index] = value
    def get_features(self): return self.features
    def set_features(self, features): self.features = features
    def add_features(self, value): self.features.append(value)
    def insert_features(self, index, value): self.features[index] = value
    def get_featureInstances(self): return self.featureInstances
    def set_featureInstances(self, featureInstances): self.featureInstances = featureInstances
    def add_featureInstances(self, value): self.featureInstances.append(value)
    def insert_featureInstances(self, index, value): self.featureInstances[index] = value
    def get_attributeInstances(self): return self.attributeInstances
    def set_attributeInstances(self, attributeInstances): self.attributeInstances = attributeInstances
    def add_attributeInstances(self, value): self.attributeInstances.append(value)
    def insert_attributeInstances(self, index, value): self.attributeInstances[index] = value
    def get_dataset(self): return self.dataset
    def set_dataset(self, dataset): self.dataset = dataset
    def get_other(self): return self.other
    def set_other(self, other): self.other = other
    def export(self, outfile, level, namespace_='', name_='MD_ScopeDescription_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ScopeDescription_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ScopeDescription_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ScopeDescription_Type', fromsubclass_=False):
        for attributes_ in self.attributes:
            attributes_.export(outfile, level, namespace_, name_='attributes')
        for features_ in self.features:
            features_.export(outfile, level, namespace_, name_='features')
        for featureInstances_ in self.featureInstances:
            featureInstances_.export(outfile, level, namespace_, name_='featureInstances')
        for attributeInstances_ in self.attributeInstances:
            attributeInstances_.export(outfile, level, namespace_, name_='attributeInstances')
        if self.dataset is not None:
            self.dataset.export(outfile, level, namespace_, name_='dataset', )
        if self.other is not None:
            self.other.export(outfile, level, namespace_, name_='other', )
    def hasContent_(self):
        if (
            self.attributes or
            self.features or
            self.featureInstances or
            self.attributeInstances or
            self.dataset is not None or
            self.other is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ScopeDescription_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attributes=[\n')
        level += 1
        for attributes_ in self.attributes:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReference_PropertyType(\n')
            attributes_.exportLiteral(outfile, level, name_='ObjectReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('features=[\n')
        level += 1
        for features_ in self.features:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReference_PropertyType(\n')
            features_.exportLiteral(outfile, level, name_='ObjectReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('featureInstances=[\n')
        level += 1
        for featureInstances_ in self.featureInstances:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReference_PropertyType(\n')
            featureInstances_.exportLiteral(outfile, level, name_='ObjectReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attributeInstances=[\n')
        level += 1
        for attributeInstances_ in self.attributeInstances:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReference_PropertyType(\n')
            attributeInstances_.exportLiteral(outfile, level, name_='ObjectReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.dataset is not None:
            showIndent(outfile, level)
            outfile.write('dataset=model_.CharacterString_PropertyType(\n')
            self.dataset.exportLiteral(outfile, level, name_='dataset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other is not None:
            showIndent(outfile, level)
            outfile.write('other=model_.CharacterString_PropertyType(\n')
            self.other.exportLiteral(outfile, level, name_='other')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attributes':
            class_obj_ = self.get_class_obj_(child_, ObjectReference_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.attributes.append(obj_)
        elif nodeName_ == 'features':
            class_obj_ = self.get_class_obj_(child_, ObjectReference_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.features.append(obj_)
        elif nodeName_ == 'featureInstances':
            class_obj_ = self.get_class_obj_(child_, ObjectReference_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.featureInstances.append(obj_)
        elif nodeName_ == 'attributeInstances':
            class_obj_ = self.get_class_obj_(child_, ObjectReference_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.attributeInstances.append(obj_)
        elif nodeName_ == 'dataset':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_dataset(obj_)
        elif nodeName_ == 'other':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_other(obj_)
# end class MD_ScopeDescription_Type


class MD_ScopeDescription_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ScopeDescription=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ScopeDescription = MD_ScopeDescription
    def factory(*args_, **kwargs_):
        if MD_ScopeDescription_PropertyType.subclass:
            return MD_ScopeDescription_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ScopeDescription_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ScopeDescription(self): return self.MD_ScopeDescription
    def set_MD_ScopeDescription(self, MD_ScopeDescription): self.MD_ScopeDescription = MD_ScopeDescription
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ScopeDescription_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ScopeDescription_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ScopeDescription_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ScopeDescription_PropertyType', fromsubclass_=False):
        if self.MD_ScopeDescription is not None:
            self.MD_ScopeDescription.export(outfile, level, namespace_, name_='MD_ScopeDescription', )
    def hasContent_(self):
        if (
            self.MD_ScopeDescription is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ScopeDescription_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ScopeDescription is not None:
            showIndent(outfile, level)
            outfile.write('MD_ScopeDescription=model_.MD_ScopeDescription(\n')
            self.MD_ScopeDescription.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ScopeDescription':
            obj_ = MD_ScopeDescription_Type.factory()
            obj_.build(child_)
            self.set_MD_ScopeDescription(obj_)
# end class MD_ScopeDescription_PropertyType


class MD_MaintenanceFrequencyCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_MaintenanceFrequencyCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_MaintenanceFrequencyCode = MD_MaintenanceFrequencyCode
    def factory(*args_, **kwargs_):
        if MD_MaintenanceFrequencyCode_PropertyType.subclass:
            return MD_MaintenanceFrequencyCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_MaintenanceFrequencyCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_MaintenanceFrequencyCode(self): return self.MD_MaintenanceFrequencyCode
    def set_MD_MaintenanceFrequencyCode(self, MD_MaintenanceFrequencyCode): self.MD_MaintenanceFrequencyCode = MD_MaintenanceFrequencyCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_MaintenanceFrequencyCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_MaintenanceFrequencyCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_MaintenanceFrequencyCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_MaintenanceFrequencyCode_PropertyType', fromsubclass_=False):
        if self.MD_MaintenanceFrequencyCode is not None:
            self.MD_MaintenanceFrequencyCode.export(outfile, level, namespace_, name_='MD_MaintenanceFrequencyCode', )
    def hasContent_(self):
        if (
            self.MD_MaintenanceFrequencyCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_MaintenanceFrequencyCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_MaintenanceFrequencyCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_MaintenanceFrequencyCode=model_.MD_MaintenanceFrequencyCode(\n')
            self.MD_MaintenanceFrequencyCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_MaintenanceFrequencyCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_MaintenanceFrequencyCode(obj_)
# end class MD_MaintenanceFrequencyCode_PropertyType


class MD_ScopeCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, MD_ScopeCode=None):
        self.nilReason = _cast(None, nilReason)
        self.MD_ScopeCode = MD_ScopeCode
    def factory(*args_, **kwargs_):
        if MD_ScopeCode_PropertyType.subclass:
            return MD_ScopeCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return MD_ScopeCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MD_ScopeCode(self): return self.MD_ScopeCode
    def set_MD_ScopeCode(self, MD_ScopeCode): self.MD_ScopeCode = MD_ScopeCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='MD_ScopeCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ScopeCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ScopeCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ScopeCode_PropertyType', fromsubclass_=False):
        if self.MD_ScopeCode is not None:
            self.MD_ScopeCode.export(outfile, level, namespace_, name_='MD_ScopeCode', )
    def hasContent_(self):
        if (
            self.MD_ScopeCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ScopeCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MD_ScopeCode is not None:
            showIndent(outfile, level)
            outfile.write('MD_ScopeCode=model_.MD_ScopeCode(\n')
            self.MD_ScopeCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MD_ScopeCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_MD_ScopeCode(obj_)
# end class MD_ScopeCode_PropertyType


class PT_FreeText_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, textGroup=None):
        super(PT_FreeText_Type, self).__init__(id, uuid, )
        if textGroup is None:
            self.textGroup = []
        else:
            self.textGroup = textGroup
    def factory(*args_, **kwargs_):
        if PT_FreeText_Type.subclass:
            return PT_FreeText_Type.subclass(*args_, **kwargs_)
        else:
            return PT_FreeText_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_textGroup(self): return self.textGroup
    def set_textGroup(self, textGroup): self.textGroup = textGroup
    def add_textGroup(self, value): self.textGroup.append(value)
    def insert_textGroup(self, index, value): self.textGroup[index] = value
    def export(self, outfile, level, namespace_='', name_='PT_FreeText_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PT_FreeText_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PT_FreeText_Type'):
        super(PT_FreeText_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PT_FreeText_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='PT_FreeText_Type', fromsubclass_=False):
        super(PT_FreeText_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for textGroup_ in self.textGroup:
            textGroup_.export(outfile, level, namespace_, name_='textGroup')
    def hasContent_(self):
        if (
            self.textGroup or
            super(PT_FreeText_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PT_FreeText_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PT_FreeText_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PT_FreeText_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('textGroup=[\n')
        level += 1
        for textGroup_ in self.textGroup:
            showIndent(outfile, level)
            outfile.write('model_.LocalisedCharacterString_PropertyType(\n')
            textGroup_.exportLiteral(outfile, level, name_='LocalisedCharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PT_FreeText_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'textGroup':
            obj_ = LocalisedCharacterString_PropertyType.factory()
            obj_.build(child_)
            self.textGroup.append(obj_)
        super(PT_FreeText_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PT_FreeText_Type


class PT_FreeText_PropertyType(CharacterString_PropertyType):
    subclass = None
    superclass = CharacterString_PropertyType
    def __init__(self, nilReason=None, CharacterString=None, PT_FreeText=None):
        super(PT_FreeText_PropertyType, self).__init__(nilReason, CharacterString, )
        self.PT_FreeText = PT_FreeText
    def factory(*args_, **kwargs_):
        if PT_FreeText_PropertyType.subclass:
            return PT_FreeText_PropertyType.subclass(*args_, **kwargs_)
        else:
            return PT_FreeText_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PT_FreeText(self): return self.PT_FreeText
    def set_PT_FreeText(self, PT_FreeText): self.PT_FreeText = PT_FreeText
    def export(self, outfile, level, namespace_='', name_='PT_FreeText_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PT_FreeText_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PT_FreeText_PropertyType'):
        super(PT_FreeText_PropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PT_FreeText_PropertyType')
    def exportChildren(self, outfile, level, namespace_='', name_='PT_FreeText_PropertyType', fromsubclass_=False):
        super(PT_FreeText_PropertyType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.PT_FreeText is not None:
            self.PT_FreeText.export(outfile, level, namespace_, name_='PT_FreeText', )
    def hasContent_(self):
        if (
            self.PT_FreeText is not None or
            super(PT_FreeText_PropertyType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PT_FreeText_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PT_FreeText_PropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PT_FreeText_PropertyType, self).exportLiteralChildren(outfile, level, name_)
        if self.PT_FreeText is not None:
            showIndent(outfile, level)
            outfile.write('PT_FreeText=model_.PT_FreeText(\n')
            self.PT_FreeText.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PT_FreeText_PropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PT_FreeText':
            obj_ = PT_FreeText_Type.factory()
            obj_.build(child_)
            self.set_PT_FreeText(obj_)
        super(PT_FreeText_PropertyType, self).buildChildren(child_, node, nodeName_, True)
# end class PT_FreeText_PropertyType


class PT_Locale_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, languageCode=None, country=None, characterEncoding=None):
        super(PT_Locale_Type, self).__init__(id, uuid, )
        self.languageCode = languageCode
        self.country = country
        self.characterEncoding = characterEncoding
    def factory(*args_, **kwargs_):
        if PT_Locale_Type.subclass:
            return PT_Locale_Type.subclass(*args_, **kwargs_)
        else:
            return PT_Locale_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_languageCode(self): return self.languageCode
    def set_languageCode(self, languageCode): self.languageCode = languageCode
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_characterEncoding(self): return self.characterEncoding
    def set_characterEncoding(self, characterEncoding): self.characterEncoding = characterEncoding
    def export(self, outfile, level, namespace_='', name_='PT_Locale_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PT_Locale_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PT_Locale_Type'):
        super(PT_Locale_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PT_Locale_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='PT_Locale_Type', fromsubclass_=False):
        super(PT_Locale_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.languageCode is not None:
            self.languageCode.export(outfile, level, namespace_, name_='languageCode', )
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country')
        if self.characterEncoding is not None:
            self.characterEncoding.export(outfile, level, namespace_, name_='characterEncoding', )
    def hasContent_(self):
        if (
            self.languageCode is not None or
            self.country is not None or
            self.characterEncoding is not None or
            super(PT_Locale_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PT_Locale_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PT_Locale_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PT_Locale_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.languageCode is not None:
            showIndent(outfile, level)
            outfile.write('languageCode=model_.LanguageCode_PropertyType(\n')
            self.languageCode.exportLiteral(outfile, level, name_='languageCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=model_.Country_PropertyType(\n')
            self.country.exportLiteral(outfile, level, name_='country')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.characterEncoding is not None:
            showIndent(outfile, level)
            outfile.write('characterEncoding=model_.MD_CharacterSetCode_PropertyType(\n')
            self.characterEncoding.exportLiteral(outfile, level, name_='characterEncoding')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PT_Locale_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'languageCode':
            obj_ = LanguageCode_PropertyType.factory()
            obj_.build(child_)
            self.set_languageCode(obj_)
        elif nodeName_ == 'country':
            obj_ = Country_PropertyType.factory()
            obj_.build(child_)
            self.set_country(obj_)
        elif nodeName_ == 'characterEncoding':
            obj_ = MD_CharacterSetCode_PropertyType.factory()
            obj_.build(child_)
            self.set_characterEncoding(obj_)
        super(PT_Locale_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PT_Locale_Type


class PT_Locale_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, PT_Locale=None):
        self.nilReason = _cast(None, nilReason)
        self.PT_Locale = PT_Locale
    def factory(*args_, **kwargs_):
        if PT_Locale_PropertyType.subclass:
            return PT_Locale_PropertyType.subclass(*args_, **kwargs_)
        else:
            return PT_Locale_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PT_Locale(self): return self.PT_Locale
    def set_PT_Locale(self, PT_Locale): self.PT_Locale = PT_Locale
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='PT_Locale_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PT_Locale_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PT_Locale_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PT_Locale_PropertyType', fromsubclass_=False):
        if self.PT_Locale is not None:
            self.PT_Locale.export(outfile, level, namespace_, name_='PT_Locale', )
    def hasContent_(self):
        if (
            self.PT_Locale is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PT_Locale_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PT_Locale is not None:
            showIndent(outfile, level)
            outfile.write('PT_Locale=model_.PT_Locale(\n')
            self.PT_Locale.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PT_Locale':
            obj_ = PT_Locale_Type.factory()
            obj_.build(child_)
            self.set_PT_Locale(obj_)
# end class PT_Locale_PropertyType


class LocalisedCharacterString_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, locale=None, id=None, valueOf_=None):
        self.locale = _cast(None, locale)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LocalisedCharacterString_Type.subclass:
            return LocalisedCharacterString_Type.subclass(*args_, **kwargs_)
        else:
            return LocalisedCharacterString_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='LocalisedCharacterString_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalisedCharacterString_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalisedCharacterString_Type'):
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.append('locale')
            outfile.write(' locale=%s' % (self.gds_format_string(quote_attrib(self.locale).encode(ExternalEncoding), input_name='locale'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LocalisedCharacterString_Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalisedCharacterString_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.append('locale')
            showIndent(outfile, level)
            outfile.write('locale = "%s",\n' % (self.locale,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locale', node)
        if value is not None and 'locale' not in already_processed:
            already_processed.append('locale')
            self.locale = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocalisedCharacterString_Type


class LocalisedCharacterString_PropertyType(ObjectReference_PropertyType):
    subclass = None
    superclass = ObjectReference_PropertyType
    def __init__(self, nilReason=None, LocalisedCharacterString=None):
        super(LocalisedCharacterString_PropertyType, self).__init__(nilReason, )
        self.LocalisedCharacterString = LocalisedCharacterString
    def factory(*args_, **kwargs_):
        if LocalisedCharacterString_PropertyType.subclass:
            return LocalisedCharacterString_PropertyType.subclass(*args_, **kwargs_)
        else:
            return LocalisedCharacterString_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalisedCharacterString(self): return self.LocalisedCharacterString
    def set_LocalisedCharacterString(self, LocalisedCharacterString): self.LocalisedCharacterString = LocalisedCharacterString
    def export(self, outfile, level, namespace_='', name_='LocalisedCharacterString_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalisedCharacterString_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalisedCharacterString_PropertyType'):
        super(LocalisedCharacterString_PropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LocalisedCharacterString_PropertyType')
    def exportChildren(self, outfile, level, namespace_='', name_='LocalisedCharacterString_PropertyType', fromsubclass_=False):
        super(LocalisedCharacterString_PropertyType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.LocalisedCharacterString is not None:
            self.LocalisedCharacterString.export(outfile, level, namespace_, name_='LocalisedCharacterString', )
    def hasContent_(self):
        if (
            self.LocalisedCharacterString is not None or
            super(LocalisedCharacterString_PropertyType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalisedCharacterString_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LocalisedCharacterString_PropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LocalisedCharacterString_PropertyType, self).exportLiteralChildren(outfile, level, name_)
        if self.LocalisedCharacterString is not None:
            showIndent(outfile, level)
            outfile.write('LocalisedCharacterString=model_.LocalisedCharacterString(\n')
            self.LocalisedCharacterString.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LocalisedCharacterString_PropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalisedCharacterString':
            obj_ = LocalisedCharacterString_Type.factory()
            obj_.build(child_)
            self.set_LocalisedCharacterString(obj_)
        super(LocalisedCharacterString_PropertyType, self).buildChildren(child_, node, nodeName_, True)
# end class LocalisedCharacterString_PropertyType


class PT_LocaleContainer_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, locale=None, date=None, responsibleParty=None, localisedString=None):
        self.description = description
        self.locale = locale
        if date is None:
            self.date = []
        else:
            self.date = date
        if responsibleParty is None:
            self.responsibleParty = []
        else:
            self.responsibleParty = responsibleParty
        if localisedString is None:
            self.localisedString = []
        else:
            self.localisedString = localisedString
    def factory(*args_, **kwargs_):
        if PT_LocaleContainer_Type.subclass:
            return PT_LocaleContainer_Type.subclass(*args_, **kwargs_)
        else:
            return PT_LocaleContainer_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def add_date(self, value): self.date.append(value)
    def insert_date(self, index, value): self.date[index] = value
    def get_responsibleParty(self): return self.responsibleParty
    def set_responsibleParty(self, responsibleParty): self.responsibleParty = responsibleParty
    def add_responsibleParty(self, value): self.responsibleParty.append(value)
    def insert_responsibleParty(self, index, value): self.responsibleParty[index] = value
    def get_localisedString(self): return self.localisedString
    def set_localisedString(self, localisedString): self.localisedString = localisedString
    def add_localisedString(self, value): self.localisedString.append(value)
    def insert_localisedString(self, index, value): self.localisedString[index] = value
    def export(self, outfile, level, namespace_='', name_='PT_LocaleContainer_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PT_LocaleContainer_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PT_LocaleContainer_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PT_LocaleContainer_Type', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', )
        if self.locale is not None:
            self.locale.export(outfile, level, namespace_, name_='locale', )
        for date_ in self.date:
            date_.export(outfile, level, namespace_, name_='date')
        for responsibleParty_ in self.responsibleParty:
            responsibleParty_.export(outfile, level, namespace_, name_='responsibleParty')
        for localisedString_ in self.localisedString:
            localisedString_.export(outfile, level, namespace_, name_='localisedString')
    def hasContent_(self):
        if (
            self.description is not None or
            self.locale is not None or
            self.date or
            self.responsibleParty or
            self.localisedString
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PT_LocaleContainer_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.CharacterString_PropertyType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.locale is not None:
            showIndent(outfile, level)
            outfile.write('locale=model_.PT_Locale_PropertyType(\n')
            self.locale.exportLiteral(outfile, level, name_='locale')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('date=[\n')
        level += 1
        for date_ in self.date:
            showIndent(outfile, level)
            outfile.write('model_.CI_Date_PropertyType(\n')
            date_.exportLiteral(outfile, level, name_='CI_Date_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('responsibleParty=[\n')
        level += 1
        for responsibleParty_ in self.responsibleParty:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            responsibleParty_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('localisedString=[\n')
        level += 1
        for localisedString_ in self.localisedString:
            showIndent(outfile, level)
            outfile.write('model_.LocalisedCharacterString_PropertyType(\n')
            localisedString_.exportLiteral(outfile, level, name_='LocalisedCharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'locale':
            obj_ = PT_Locale_PropertyType.factory()
            obj_.build(child_)
            self.set_locale(obj_)
        elif nodeName_ == 'date':
            obj_ = CI_Date_PropertyType.factory()
            obj_.build(child_)
            self.date.append(obj_)
        elif nodeName_ == 'responsibleParty':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.responsibleParty.append(obj_)
        elif nodeName_ == 'localisedString':
            obj_ = LocalisedCharacterString_PropertyType.factory()
            obj_.build(child_)
            self.localisedString.append(obj_)
# end class PT_LocaleContainer_Type


class PT_LocaleContainer_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, PT_LocaleContainer=None):
        self.nilReason = _cast(None, nilReason)
        self.PT_LocaleContainer = PT_LocaleContainer
    def factory(*args_, **kwargs_):
        if PT_LocaleContainer_PropertyType.subclass:
            return PT_LocaleContainer_PropertyType.subclass(*args_, **kwargs_)
        else:
            return PT_LocaleContainer_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PT_LocaleContainer(self): return self.PT_LocaleContainer
    def set_PT_LocaleContainer(self, PT_LocaleContainer): self.PT_LocaleContainer = PT_LocaleContainer
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='PT_LocaleContainer_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PT_LocaleContainer_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PT_LocaleContainer_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PT_LocaleContainer_PropertyType', fromsubclass_=False):
        if self.PT_LocaleContainer is not None:
            self.PT_LocaleContainer.export(outfile, level, namespace_, name_='PT_LocaleContainer', )
    def hasContent_(self):
        if (
            self.PT_LocaleContainer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PT_LocaleContainer_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PT_LocaleContainer is not None:
            showIndent(outfile, level)
            outfile.write('PT_LocaleContainer=model_.PT_LocaleContainer(\n')
            self.PT_LocaleContainer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PT_LocaleContainer':
            obj_ = PT_LocaleContainer_Type.factory()
            obj_.build(child_)
            self.set_PT_LocaleContainer(obj_)
# end class PT_LocaleContainer_PropertyType


class LanguageCode_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, LanguageCode=None):
        self.nilReason = _cast(None, nilReason)
        self.LanguageCode = LanguageCode
    def factory(*args_, **kwargs_):
        if LanguageCode_PropertyType.subclass:
            return LanguageCode_PropertyType.subclass(*args_, **kwargs_)
        else:
            return LanguageCode_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='LanguageCode_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LanguageCode_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LanguageCode_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LanguageCode_PropertyType', fromsubclass_=False):
        if self.LanguageCode is not None:
            self.LanguageCode.export(outfile, level, namespace_, name_='LanguageCode', )
    def hasContent_(self):
        if (
            self.LanguageCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LanguageCode_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LanguageCode is not None:
            showIndent(outfile, level)
            outfile.write('LanguageCode=model_.LanguageCode(\n')
            self.LanguageCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LanguageCode':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_LanguageCode(obj_)
# end class LanguageCode_PropertyType


class Country_PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nilReason=None, Country=None):
        self.nilReason = _cast(None, nilReason)
        self.Country = Country
    def factory(*args_, **kwargs_):
        if Country_PropertyType.subclass:
            return Country_PropertyType.subclass(*args_, **kwargs_)
        else:
            return Country_PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    def get_nilReason(self): return self.nilReason
    def set_nilReason(self, nilReason): self.nilReason = nilReason
    def export(self, outfile, level, namespace_='', name_='Country_PropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Country_PropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Country_PropertyType'):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            outfile.write(' nilReason=%s' % (self.gds_format_string(quote_attrib(self.nilReason).encode(ExternalEncoding), input_name='nilReason'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Country_PropertyType', fromsubclass_=False):
        if self.Country is not None:
            self.Country.export(outfile, level, namespace_, name_='Country', )
    def hasContent_(self):
        if (
            self.Country is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Country_PropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nilReason is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            showIndent(outfile, level)
            outfile.write('nilReason = "%s",\n' % (self.nilReason,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Country is not None:
            showIndent(outfile, level)
            outfile.write('Country=model_.Country(\n')
            self.Country.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nilReason', node)
        if value is not None and 'nilReason' not in already_processed:
            already_processed.append('nilReason')
            self.nilReason = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Country':
            obj_ = CodeListValue_Type.factory()
            obj_.build(child_)
            self.set_Country(obj_)
# end class Country_PropertyType


class AbstractDatumType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None, extensiontype_=None):
        super(AbstractDatumType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.anchorDefinition = anchorDefinition
        self.realizationEpoch = realizationEpoch
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDatumType.subclass:
            return AbstractDatumType.subclass(*args_, **kwargs_)
        else:
            return AbstractDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope(self, index, value): self.scope[index] = value
    def get_anchorDefinition(self): return self.anchorDefinition
    def set_anchorDefinition(self, anchorDefinition): self.anchorDefinition = anchorDefinition
    def get_realizationEpoch(self): return self.realizationEpoch
    def set_realizationEpoch(self, realizationEpoch): self.realizationEpoch = realizationEpoch
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDatumType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDatumType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDatumType'):
        super(AbstractDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDatumType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDatumType', fromsubclass_=False):
        super(AbstractDatumType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_, name_='domainOfValidity')
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.gds_format_string(quote_xml(scope_).encode(ExternalEncoding), input_name='scope'), namespace_))
        if self.anchorDefinition is not None:
            self.anchorDefinition.export(outfile, level, namespace_, name_='anchorDefinition')
        if self.realizationEpoch is not None:
            showIndent(outfile, level)
            outfile.write('<%srealizationEpoch>%s</%srealizationEpoch>\n' % (namespace_, self.gds_format_string(quote_xml(self.realizationEpoch).encode(ExternalEncoding), input_name='realizationEpoch'), namespace_))
    def hasContent_(self):
        if (
            self.domainOfValidity is not None or
            self.scope or
            self.anchorDefinition is not None or
            self.realizationEpoch is not None or
            super(AbstractDatumType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDatumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDatumType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDatumType, self).exportLiteralChildren(outfile, level, name_)
        if self.domainOfValidity is not None:
            showIndent(outfile, level)
            outfile.write('domainOfValidity=model_.domainOfValidity(\n')
            self.domainOfValidity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('scope=[\n')
        level += 1
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anchorDefinition is not None:
            showIndent(outfile, level)
            outfile.write('anchorDefinition=model_.anchorDefinition(\n')
            self.anchorDefinition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.realizationEpoch is not None:
            showIndent(outfile, level)
            outfile.write('realizationEpoch=%s,\n' % quote_python(self.realizationEpoch).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.set_domainOfValidity(obj_)
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'anchorDefinition':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_anchorDefinition(obj_)
        elif nodeName_ == 'realizationEpoch':
            realizationEpoch_ = child_.text
            realizationEpoch_ = self.gds_validate_string(realizationEpoch_, node, 'realizationEpoch')
            self.realizationEpoch = realizationEpoch_
        super(AbstractDatumType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractDatumType


class DatumPropertyType(GeneratedsSuper):
    """gml:DatumPropertyType is a property type for association roles to a
    datum, either referencing or containing the definition of that
    datum."""
    subclass = None
    superclass = None
    def __init__(self, AbstractDatum=None):
        self.AbstractDatum = AbstractDatum
    def factory(*args_, **kwargs_):
        if DatumPropertyType.subclass:
            return DatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return DatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDatum(self): return self.AbstractDatum
    def set_AbstractDatum(self, AbstractDatum): self.AbstractDatum = AbstractDatum
    def export(self, outfile, level, namespace_='', name_='DatumPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatumPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatumPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatumPropertyType', fromsubclass_=False):
        if self.AbstractDatum is not None:
            self.AbstractDatum.export(outfile, level, namespace_, name_='AbstractDatum')
    def hasContent_(self):
        if (
            self.AbstractDatum is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DatumPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDatum is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDatum=model_.AbstractDatum(\n')
            self.AbstractDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDatum':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDatum> element')
            self.set_AbstractDatum(obj_)
# end class DatumPropertyType


class GeodeticDatumType(AbstractDatumType):
    subclass = None
    superclass = AbstractDatumType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None, primeMeridian=None, ellipsoid=None):
        super(GeodeticDatumType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, anchorDefinition, realizationEpoch, )
        self.primeMeridian = primeMeridian
        self.ellipsoid = ellipsoid
    def factory(*args_, **kwargs_):
        if GeodeticDatumType.subclass:
            return GeodeticDatumType.subclass(*args_, **kwargs_)
        else:
            return GeodeticDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primeMeridian(self): return self.primeMeridian
    def set_primeMeridian(self, primeMeridian): self.primeMeridian = primeMeridian
    def get_ellipsoid(self): return self.ellipsoid
    def set_ellipsoid(self, ellipsoid): self.ellipsoid = ellipsoid
    def export(self, outfile, level, namespace_='', name_='GeodeticDatumType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticDatumType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeodeticDatumType'):
        super(GeodeticDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticDatumType')
    def exportChildren(self, outfile, level, namespace_='', name_='GeodeticDatumType', fromsubclass_=False):
        super(GeodeticDatumType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.primeMeridian is not None:
            self.primeMeridian.export(outfile, level, namespace_, name_='primeMeridian', )
        if self.ellipsoid is not None:
            self.ellipsoid.export(outfile, level, namespace_, name_='ellipsoid', )
    def hasContent_(self):
        if (
            self.primeMeridian is not None or
            self.ellipsoid is not None or
            super(GeodeticDatumType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeodeticDatumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeodeticDatumType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GeodeticDatumType, self).exportLiteralChildren(outfile, level, name_)
        if self.primeMeridian is not None:
            showIndent(outfile, level)
            outfile.write('primeMeridian=model_.primeMeridian(\n')
            self.primeMeridian.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ellipsoid is not None:
            showIndent(outfile, level)
            outfile.write('ellipsoid=model_.ellipsoid(\n')
            self.ellipsoid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primeMeridian':
            obj_ = PrimeMeridianPropertyType.factory()
            obj_.build(child_)
            self.set_primeMeridian(obj_)
        elif nodeName_ == 'ellipsoid':
            obj_ = EllipsoidPropertyType.factory()
            obj_.build(child_)
            self.set_ellipsoid(obj_)
        super(GeodeticDatumType, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticDatumType


class GeodeticDatumPropertyType(GeneratedsSuper):
    """gml:GeodeticDatumPropertyType is a property type for association
    roles to a geodetic datum, either referencing or containing the
    definition of that datum."""
    subclass = None
    superclass = None
    def __init__(self, GeodeticDatum=None):
        self.GeodeticDatum = GeodeticDatum
    def factory(*args_, **kwargs_):
        if GeodeticDatumPropertyType.subclass:
            return GeodeticDatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeodeticDatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeodeticDatum(self): return self.GeodeticDatum
    def set_GeodeticDatum(self, GeodeticDatum): self.GeodeticDatum = GeodeticDatum
    def export(self, outfile, level, namespace_='', name_='GeodeticDatumPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticDatumPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeodeticDatumPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeodeticDatumPropertyType', fromsubclass_=False):
        if self.GeodeticDatum is not None:
            self.GeodeticDatum.export(outfile, level, namespace_, name_='GeodeticDatum', )
    def hasContent_(self):
        if (
            self.GeodeticDatum is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeodeticDatumPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GeodeticDatum is not None:
            showIndent(outfile, level)
            outfile.write('GeodeticDatum=model_.GeodeticDatum(\n')
            self.GeodeticDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeodeticDatum':
            obj_ = GeodeticDatumType.factory()
            obj_.build(child_)
            self.set_GeodeticDatum(obj_)
# end class GeodeticDatumPropertyType


class EllipsoidType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, semiMajorAxis=None, secondDefiningParameter=None):
        super(EllipsoidType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        self.semiMajorAxis = semiMajorAxis
        self.secondDefiningParameter = secondDefiningParameter
    def factory(*args_, **kwargs_):
        if EllipsoidType.subclass:
            return EllipsoidType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_semiMajorAxis(self): return self.semiMajorAxis
    def set_semiMajorAxis(self, semiMajorAxis): self.semiMajorAxis = semiMajorAxis
    def get_secondDefiningParameter(self): return self.secondDefiningParameter
    def set_secondDefiningParameter(self, secondDefiningParameter): self.secondDefiningParameter = secondDefiningParameter
    def export(self, outfile, level, namespace_='', name_='EllipsoidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EllipsoidType'):
        super(EllipsoidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidType')
    def exportChildren(self, outfile, level, namespace_='', name_='EllipsoidType', fromsubclass_=False):
        super(EllipsoidType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.semiMajorAxis is not None:
            self.semiMajorAxis.export(outfile, level, namespace_, name_='semiMajorAxis', )
        if self.secondDefiningParameter is not None:
            self.secondDefiningParameter.export(outfile, level, namespace_, name_='secondDefiningParameter', )
    def hasContent_(self):
        if (
            self.semiMajorAxis is not None or
            self.secondDefiningParameter is not None or
            super(EllipsoidType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EllipsoidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EllipsoidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EllipsoidType, self).exportLiteralChildren(outfile, level, name_)
        if self.semiMajorAxis is not None:
            showIndent(outfile, level)
            outfile.write('semiMajorAxis=model_.semiMajorAxis(\n')
            self.semiMajorAxis.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secondDefiningParameter is not None:
            showIndent(outfile, level)
            outfile.write('secondDefiningParameter=model_.secondDefiningParameter(\n')
            self.secondDefiningParameter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EllipsoidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'semiMajorAxis':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_semiMajorAxis(obj_)
        elif nodeName_ == 'secondDefiningParameter':
            obj_ = secondDefiningParameter.factory()
            obj_.build(child_)
            self.set_secondDefiningParameter(obj_)
        super(EllipsoidType, self).buildChildren(child_, node, nodeName_, True)
# end class EllipsoidType


class secondDefiningParameter(GeneratedsSuper):
    """gml:secondDefiningParameter is a property containing the definition
    of the second parameter that defines the shape of an ellipsoid.
    An ellipsoid requires two defining parameters: semi-major axis
    and inverse flattening or semi-major axis and semi-minor axis.
    When the reference body is a sphere rather than an ellipsoid,
    only a single defining parameter is required, namely the radius
    of the sphere; in that case, the semi-major axis "degenerates"
    into the radius of the sphere. The inverseFlattening element
    contains the inverse flattening value of the ellipsoid. This
    value is a scale factor (or ratio). It uses gml:LengthType with
    the restriction that the unit of measure referenced by the uom
    attribute must be suitable for a scale factor, such as percent,
    permil, or parts-per-million. The semiMinorAxis element contains
    the length of the semi-minor axis of the ellipsoid. When the
    isSphere element is included, the ellipsoid is degenerate and is
    actually a sphere. The sphere is completely defined by the semi-
    major axis, which is the radius of the sphere."""
    subclass = None
    superclass = None
    def __init__(self, SecondDefiningParameter=None):
        self.SecondDefiningParameter = SecondDefiningParameter
    def factory(*args_, **kwargs_):
        if secondDefiningParameter.subclass:
            return secondDefiningParameter.subclass(*args_, **kwargs_)
        else:
            return secondDefiningParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SecondDefiningParameter(self): return self.SecondDefiningParameter
    def set_SecondDefiningParameter(self, SecondDefiningParameter): self.SecondDefiningParameter = SecondDefiningParameter
    def export(self, outfile, level, namespace_='', name_='secondDefiningParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='secondDefiningParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='secondDefiningParameter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='secondDefiningParameter', fromsubclass_=False):
        if self.SecondDefiningParameter is not None:
            self.SecondDefiningParameter.export(outfile, level, namespace_, name_='SecondDefiningParameter', )
    def hasContent_(self):
        if (
            self.SecondDefiningParameter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='secondDefiningParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SecondDefiningParameter is not None:
            showIndent(outfile, level)
            outfile.write('SecondDefiningParameter=model_.SecondDefiningParameter(\n')
            self.SecondDefiningParameter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SecondDefiningParameter':
            obj_ = SecondDefiningParameter.factory()
            obj_.build(child_)
            self.set_SecondDefiningParameter(obj_)
# end class secondDefiningParameter


class SecondDefiningParameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inverseFlattening=None, semiMinorAxis=None, isSphere='true'):
        self.inverseFlattening = inverseFlattening
        self.semiMinorAxis = semiMinorAxis
        self.isSphere = isSphere
    def factory(*args_, **kwargs_):
        if SecondDefiningParameter.subclass:
            return SecondDefiningParameter.subclass(*args_, **kwargs_)
        else:
            return SecondDefiningParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inverseFlattening(self): return self.inverseFlattening
    def set_inverseFlattening(self, inverseFlattening): self.inverseFlattening = inverseFlattening
    def get_semiMinorAxis(self): return self.semiMinorAxis
    def set_semiMinorAxis(self, semiMinorAxis): self.semiMinorAxis = semiMinorAxis
    def get_isSphere(self): return self.isSphere
    def set_isSphere(self, isSphere): self.isSphere = isSphere
    def export(self, outfile, level, namespace_='', name_='SecondDefiningParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecondDefiningParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SecondDefiningParameter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SecondDefiningParameter', fromsubclass_=False):
        if self.inverseFlattening is not None:
            self.inverseFlattening.export(outfile, level, namespace_, name_='inverseFlattening', )
        if self.semiMinorAxis is not None:
            self.semiMinorAxis.export(outfile, level, namespace_, name_='semiMinorAxis', )
        if self.isSphere is not None:
            showIndent(outfile, level)
            outfile.write('<%sisSphere>%s</%sisSphere>\n' % (namespace_, self.gds_format_string(quote_xml(self.isSphere).encode(ExternalEncoding), input_name='isSphere'), namespace_))
    def hasContent_(self):
        if (
            self.inverseFlattening is not None or
            self.semiMinorAxis is not None or
            self.isSphere is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SecondDefiningParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inverseFlattening is not None:
            showIndent(outfile, level)
            outfile.write('inverseFlattening=model_.MeasureType(\n')
            self.inverseFlattening.exportLiteral(outfile, level, name_='inverseFlattening')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.semiMinorAxis is not None:
            showIndent(outfile, level)
            outfile.write('semiMinorAxis=model_.LengthType(\n')
            self.semiMinorAxis.exportLiteral(outfile, level, name_='semiMinorAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.isSphere is not None:
            showIndent(outfile, level)
            outfile.write('isSphere=%s,\n' % quote_python(self.isSphere).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inverseFlattening':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_inverseFlattening(obj_)
        elif nodeName_ == 'semiMinorAxis':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.set_semiMinorAxis(obj_)
        elif nodeName_ == 'isSphere':
            isSphere_ = child_.text
            isSphere_ = self.gds_validate_string(isSphere_, node, 'isSphere')
            self.isSphere = isSphere_
# end class SecondDefiningParameter


class EllipsoidPropertyType(GeneratedsSuper):
    """gml:EllipsoidPropertyType is a property type for association roles
    to an ellipsoid, either referencing or containing the definition
    of that ellipsoid."""
    subclass = None
    superclass = None
    def __init__(self, Ellipsoid=None):
        self.Ellipsoid = Ellipsoid
    def factory(*args_, **kwargs_):
        if EllipsoidPropertyType.subclass:
            return EllipsoidPropertyType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ellipsoid(self): return self.Ellipsoid
    def set_Ellipsoid(self, Ellipsoid): self.Ellipsoid = Ellipsoid
    def export(self, outfile, level, namespace_='', name_='EllipsoidPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EllipsoidPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EllipsoidPropertyType', fromsubclass_=False):
        if self.Ellipsoid is not None:
            self.Ellipsoid.export(outfile, level, namespace_, name_='Ellipsoid', )
    def hasContent_(self):
        if (
            self.Ellipsoid is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EllipsoidPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Ellipsoid is not None:
            showIndent(outfile, level)
            outfile.write('Ellipsoid=model_.Ellipsoid(\n')
            self.Ellipsoid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ellipsoid':
            obj_ = EllipsoidType.factory()
            obj_.build(child_)
            self.set_Ellipsoid(obj_)
# end class EllipsoidPropertyType


class PrimeMeridianType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, greenwichLongitude=None):
        super(PrimeMeridianType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        self.greenwichLongitude = greenwichLongitude
    def factory(*args_, **kwargs_):
        if PrimeMeridianType.subclass:
            return PrimeMeridianType.subclass(*args_, **kwargs_)
        else:
            return PrimeMeridianType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_greenwichLongitude(self): return self.greenwichLongitude
    def set_greenwichLongitude(self, greenwichLongitude): self.greenwichLongitude = greenwichLongitude
    def export(self, outfile, level, namespace_='', name_='PrimeMeridianType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimeMeridianType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrimeMeridianType'):
        super(PrimeMeridianType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PrimeMeridianType')
    def exportChildren(self, outfile, level, namespace_='', name_='PrimeMeridianType', fromsubclass_=False):
        super(PrimeMeridianType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.greenwichLongitude is not None:
            self.greenwichLongitude.export(outfile, level, namespace_, name_='greenwichLongitude', )
    def hasContent_(self):
        if (
            self.greenwichLongitude is not None or
            super(PrimeMeridianType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PrimeMeridianType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PrimeMeridianType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PrimeMeridianType, self).exportLiteralChildren(outfile, level, name_)
        if self.greenwichLongitude is not None:
            showIndent(outfile, level)
            outfile.write('greenwichLongitude=model_.greenwichLongitude(\n')
            self.greenwichLongitude.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PrimeMeridianType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'greenwichLongitude':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.set_greenwichLongitude(obj_)
        super(PrimeMeridianType, self).buildChildren(child_, node, nodeName_, True)
# end class PrimeMeridianType


class PrimeMeridianPropertyType(GeneratedsSuper):
    """gml:PrimeMeridianPropertyType is a property type for association
    roles to a prime meridian, either referencing or containing the
    definition of that meridian."""
    subclass = None
    superclass = None
    def __init__(self, PrimeMeridian=None):
        self.PrimeMeridian = PrimeMeridian
    def factory(*args_, **kwargs_):
        if PrimeMeridianPropertyType.subclass:
            return PrimeMeridianPropertyType.subclass(*args_, **kwargs_)
        else:
            return PrimeMeridianPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PrimeMeridian(self): return self.PrimeMeridian
    def set_PrimeMeridian(self, PrimeMeridian): self.PrimeMeridian = PrimeMeridian
    def export(self, outfile, level, namespace_='', name_='PrimeMeridianPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimeMeridianPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrimeMeridianPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrimeMeridianPropertyType', fromsubclass_=False):
        if self.PrimeMeridian is not None:
            self.PrimeMeridian.export(outfile, level, namespace_, name_='PrimeMeridian', )
    def hasContent_(self):
        if (
            self.PrimeMeridian is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PrimeMeridianPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PrimeMeridian is not None:
            showIndent(outfile, level)
            outfile.write('PrimeMeridian=model_.PrimeMeridian(\n')
            self.PrimeMeridian.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrimeMeridian':
            obj_ = PrimeMeridianType.factory()
            obj_.build(child_)
            self.set_PrimeMeridian(obj_)
# end class PrimeMeridianPropertyType


class EngineeringDatumType(AbstractDatumType):
    subclass = None
    superclass = AbstractDatumType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None):
        super(EngineeringDatumType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, anchorDefinition, realizationEpoch, )
        pass
    def factory(*args_, **kwargs_):
        if EngineeringDatumType.subclass:
            return EngineeringDatumType.subclass(*args_, **kwargs_)
        else:
            return EngineeringDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='EngineeringDatumType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EngineeringDatumType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EngineeringDatumType'):
        super(EngineeringDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EngineeringDatumType')
    def exportChildren(self, outfile, level, namespace_='', name_='EngineeringDatumType', fromsubclass_=False):
        super(EngineeringDatumType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(EngineeringDatumType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EngineeringDatumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EngineeringDatumType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EngineeringDatumType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EngineeringDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EngineeringDatumType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EngineeringDatumType


class EngineeringDatumPropertyType(GeneratedsSuper):
    """gml:EngineeringDatumPropertyType is a property type for association
    roles to an engineering datum, either referencing or containing
    the definition of that datum."""
    subclass = None
    superclass = None
    def __init__(self, EngineeringDatum=None):
        self.EngineeringDatum = EngineeringDatum
    def factory(*args_, **kwargs_):
        if EngineeringDatumPropertyType.subclass:
            return EngineeringDatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return EngineeringDatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EngineeringDatum(self): return self.EngineeringDatum
    def set_EngineeringDatum(self, EngineeringDatum): self.EngineeringDatum = EngineeringDatum
    def export(self, outfile, level, namespace_='', name_='EngineeringDatumPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EngineeringDatumPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EngineeringDatumPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EngineeringDatumPropertyType', fromsubclass_=False):
        if self.EngineeringDatum is not None:
            self.EngineeringDatum.export(outfile, level, namespace_, name_='EngineeringDatum', )
    def hasContent_(self):
        if (
            self.EngineeringDatum is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EngineeringDatumPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EngineeringDatum is not None:
            showIndent(outfile, level)
            outfile.write('EngineeringDatum=model_.EngineeringDatum(\n')
            self.EngineeringDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EngineeringDatum':
            obj_ = EngineeringDatumType.factory()
            obj_.build(child_)
            self.set_EngineeringDatum(obj_)
# end class EngineeringDatumPropertyType


class ImageDatumType(AbstractDatumType):
    subclass = None
    superclass = AbstractDatumType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None, pixelInCell=None):
        super(ImageDatumType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, anchorDefinition, realizationEpoch, )
        self.pixelInCell = pixelInCell
    def factory(*args_, **kwargs_):
        if ImageDatumType.subclass:
            return ImageDatumType.subclass(*args_, **kwargs_)
        else:
            return ImageDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pixelInCell(self): return self.pixelInCell
    def set_pixelInCell(self, pixelInCell): self.pixelInCell = pixelInCell
    def export(self, outfile, level, namespace_='', name_='ImageDatumType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageDatumType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImageDatumType'):
        super(ImageDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ImageDatumType')
    def exportChildren(self, outfile, level, namespace_='', name_='ImageDatumType', fromsubclass_=False):
        super(ImageDatumType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.pixelInCell is not None:
            self.pixelInCell.export(outfile, level, namespace_, name_='pixelInCell', )
    def hasContent_(self):
        if (
            self.pixelInCell is not None or
            super(ImageDatumType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImageDatumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ImageDatumType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ImageDatumType, self).exportLiteralChildren(outfile, level, name_)
        if self.pixelInCell is not None:
            showIndent(outfile, level)
            outfile.write('pixelInCell=model_.pixelInCell(\n')
            self.pixelInCell.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ImageDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pixelInCell':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_pixelInCell(obj_)
        super(ImageDatumType, self).buildChildren(child_, node, nodeName_, True)
# end class ImageDatumType


class ImageDatumPropertyType(GeneratedsSuper):
    """gml:ImageDatumPropertyType is a property type for association roles
    to an image datum, either referencing or containing the
    definition of that datum."""
    subclass = None
    superclass = None
    def __init__(self, ImageDatum=None):
        self.ImageDatum = ImageDatum
    def factory(*args_, **kwargs_):
        if ImageDatumPropertyType.subclass:
            return ImageDatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return ImageDatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ImageDatum(self): return self.ImageDatum
    def set_ImageDatum(self, ImageDatum): self.ImageDatum = ImageDatum
    def export(self, outfile, level, namespace_='', name_='ImageDatumPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageDatumPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImageDatumPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImageDatumPropertyType', fromsubclass_=False):
        if self.ImageDatum is not None:
            self.ImageDatum.export(outfile, level, namespace_, name_='ImageDatum', )
    def hasContent_(self):
        if (
            self.ImageDatum is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImageDatumPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ImageDatum is not None:
            showIndent(outfile, level)
            outfile.write('ImageDatum=model_.ImageDatum(\n')
            self.ImageDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ImageDatum':
            obj_ = ImageDatumType.factory()
            obj_.build(child_)
            self.set_ImageDatum(obj_)
# end class ImageDatumPropertyType


class VerticalDatumType(AbstractDatumType):
    subclass = None
    superclass = AbstractDatumType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, anchorDefinition=None, realizationEpoch=None):
        super(VerticalDatumType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, anchorDefinition, realizationEpoch, )
        pass
    def factory(*args_, **kwargs_):
        if VerticalDatumType.subclass:
            return VerticalDatumType.subclass(*args_, **kwargs_)
        else:
            return VerticalDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='VerticalDatumType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalDatumType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerticalDatumType'):
        super(VerticalDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalDatumType')
    def exportChildren(self, outfile, level, namespace_='', name_='VerticalDatumType', fromsubclass_=False):
        super(VerticalDatumType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(VerticalDatumType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VerticalDatumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VerticalDatumType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VerticalDatumType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VerticalDatumType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VerticalDatumType


class VerticalDatumPropertyType(GeneratedsSuper):
    """gml:VerticalDatumPropertyType is property type for association roles
    to a vertical datum, either referencing or containing the
    definition of that datum."""
    subclass = None
    superclass = None
    def __init__(self, VerticalDatum=None):
        self.VerticalDatum = VerticalDatum
    def factory(*args_, **kwargs_):
        if VerticalDatumPropertyType.subclass:
            return VerticalDatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return VerticalDatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VerticalDatum(self): return self.VerticalDatum
    def set_VerticalDatum(self, VerticalDatum): self.VerticalDatum = VerticalDatum
    def export(self, outfile, level, namespace_='', name_='VerticalDatumPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalDatumPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerticalDatumPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VerticalDatumPropertyType', fromsubclass_=False):
        if self.VerticalDatum is not None:
            self.VerticalDatum.export(outfile, level, namespace_, name_='VerticalDatum', )
    def hasContent_(self):
        if (
            self.VerticalDatum is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VerticalDatumPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VerticalDatum is not None:
            showIndent(outfile, level)
            outfile.write('VerticalDatum=model_.VerticalDatum(\n')
            self.VerticalDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VerticalDatum':
            obj_ = VerticalDatumType.factory()
            obj_.build(child_)
            self.set_VerticalDatum(obj_)
# end class VerticalDatumPropertyType


class TemporalDatumBaseType(GeneratedsSuper):
    """The TemporalDatumBaseType partially defines the origin of a temporal
    coordinate reference system. This type restricts the
    AbstractDatumType to remove the "anchorDefinition" and
    "realizationEpoch" elements."""
    subclass = None
    superclass = None
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, extensiontype_=None):
        self.id = _cast(None, id)
        if metaDataProperty is None:
            self.metaDataProperty = []
        else:
            self.metaDataProperty = metaDataProperty
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.remarks = remarks
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if TemporalDatumBaseType.subclass:
            return TemporalDatumBaseType.subclass(*args_, **kwargs_)
        else:
            return TemporalDatumBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaDataProperty(self): return self.metaDataProperty
    def set_metaDataProperty(self, metaDataProperty): self.metaDataProperty = metaDataProperty
    def add_metaDataProperty(self, value): self.metaDataProperty.append(value)
    def insert_metaDataProperty(self, index, value): self.metaDataProperty[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name(self, index, value): self.name[index] = value
    def get_remarks(self): return self.remarks
    def set_remarks(self, remarks): self.remarks = remarks
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope(self, index, value): self.scope[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='TemporalDatumBaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalDatumBaseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TemporalDatumBaseType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='TemporalDatumBaseType', fromsubclass_=False):
        for metaDataProperty_ in self.metaDataProperty:
            metaDataProperty_.export(outfile, level, namespace_, name_='metaDataProperty')
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_, name_='descriptionReference')
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', )
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name')
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('<%sremarks>%s</%sremarks>\n' % (namespace_, self.gds_format_string(quote_xml(self.remarks).encode(ExternalEncoding), input_name='remarks'), namespace_))
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_, name_='domainOfValidity')
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.gds_format_string(quote_xml(scope_).encode(ExternalEncoding), input_name='scope'), namespace_))
    def hasContent_(self):
        if (
            self.metaDataProperty or
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name or
            self.remarks is not None or
            self.domainOfValidity is not None or
            self.scope
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TemporalDatumBaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metaDataProperty=[\n')
        level += 1
        for metaDataProperty_ in self.metaDataProperty:
            showIndent(outfile, level)
            outfile.write('model_.metaDataProperty(\n')
            metaDataProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptionReference is not None:
            showIndent(outfile, level)
            outfile.write('descriptionReference=model_.descriptionReference(\n')
            self.descriptionReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.identifier(\n')
            self.identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.name(\n')
            name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('remarks=%s,\n' % quote_python(self.remarks).encode(ExternalEncoding))
        if self.domainOfValidity is not None:
            showIndent(outfile, level)
            outfile.write('domainOfValidity=model_.domainOfValidity(\n')
            self.domainOfValidity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('scope=[\n')
        level += 1
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaDataProperty':
            obj_ = MetaDataPropertyType.factory()
            obj_.build(child_)
            self.metaDataProperty.append(obj_)
        elif nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_descriptionReference(obj_)
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
        elif nodeName_ == 'remarks':
            remarks_ = child_.text
            remarks_ = self.gds_validate_string(remarks_, node, 'remarks')
            self.remarks = remarks_
        elif nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.set_domainOfValidity(obj_)
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
# end class TemporalDatumBaseType


class TemporalDatumPropertyType(GeneratedsSuper):
    """gml:TemporalDatumPropertyType is a property type for association
    roles to a temporal datum, either referencing or containing the
    definition of that datum."""
    subclass = None
    superclass = None
    def __init__(self, TemporalDatum=None):
        self.TemporalDatum = TemporalDatum
    def factory(*args_, **kwargs_):
        if TemporalDatumPropertyType.subclass:
            return TemporalDatumPropertyType.subclass(*args_, **kwargs_)
        else:
            return TemporalDatumPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TemporalDatum(self): return self.TemporalDatum
    def set_TemporalDatum(self, TemporalDatum): self.TemporalDatum = TemporalDatum
    def export(self, outfile, level, namespace_='', name_='TemporalDatumPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalDatumPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TemporalDatumPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TemporalDatumPropertyType', fromsubclass_=False):
        if self.TemporalDatum is not None:
            self.TemporalDatum.export(outfile, level, namespace_, name_='TemporalDatum', )
    def hasContent_(self):
        if (
            self.TemporalDatum is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TemporalDatumPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TemporalDatum is not None:
            showIndent(outfile, level)
            outfile.write('TemporalDatum=model_.TemporalDatum(\n')
            self.TemporalDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TemporalDatum':
            obj_ = TemporalDatumType.factory()
            obj_.build(child_)
            self.set_TemporalDatum(obj_)
# end class TemporalDatumPropertyType


class AbstractCoordinateOperationType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, operationVersion=None, coordinateOperationAccuracy=None, sourceCRS=None, targetCRS=None, extensiontype_=None):
        super(AbstractCoordinateOperationType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.operationVersion = operationVersion
        if coordinateOperationAccuracy is None:
            self.coordinateOperationAccuracy = []
        else:
            self.coordinateOperationAccuracy = coordinateOperationAccuracy
        self.sourceCRS = sourceCRS
        self.targetCRS = targetCRS
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractCoordinateOperationType.subclass:
            return AbstractCoordinateOperationType.subclass(*args_, **kwargs_)
        else:
            return AbstractCoordinateOperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope(self, index, value): self.scope[index] = value
    def get_operationVersion(self): return self.operationVersion
    def set_operationVersion(self, operationVersion): self.operationVersion = operationVersion
    def get_coordinateOperationAccuracy(self): return self.coordinateOperationAccuracy
    def set_coordinateOperationAccuracy(self, coordinateOperationAccuracy): self.coordinateOperationAccuracy = coordinateOperationAccuracy
    def add_coordinateOperationAccuracy(self, value): self.coordinateOperationAccuracy.append(value)
    def insert_coordinateOperationAccuracy(self, index, value): self.coordinateOperationAccuracy[index] = value
    def get_sourceCRS(self): return self.sourceCRS
    def set_sourceCRS(self, sourceCRS): self.sourceCRS = sourceCRS
    def get_targetCRS(self): return self.targetCRS
    def set_targetCRS(self, targetCRS): self.targetCRS = targetCRS
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractCoordinateOperationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateOperationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractCoordinateOperationType'):
        super(AbstractCoordinateOperationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateOperationType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCoordinateOperationType', fromsubclass_=False):
        super(AbstractCoordinateOperationType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_, name_='domainOfValidity')
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.gds_format_string(quote_xml(scope_).encode(ExternalEncoding), input_name='scope'), namespace_))
        if self.operationVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%soperationVersion>%s</%soperationVersion>\n' % (namespace_, self.gds_format_string(quote_xml(self.operationVersion).encode(ExternalEncoding), input_name='operationVersion'), namespace_))
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            coordinateOperationAccuracy_.export(outfile, level, namespace_, name_='coordinateOperationAccuracy')
        if self.sourceCRS is not None:
            self.sourceCRS.export(outfile, level, namespace_, name_='sourceCRS')
        if self.targetCRS is not None:
            self.targetCRS.export(outfile, level, namespace_, name_='targetCRS')
    def hasContent_(self):
        if (
            self.domainOfValidity is not None or
            self.scope or
            self.operationVersion is not None or
            self.coordinateOperationAccuracy or
            self.sourceCRS is not None or
            self.targetCRS is not None or
            super(AbstractCoordinateOperationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCoordinateOperationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractCoordinateOperationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractCoordinateOperationType, self).exportLiteralChildren(outfile, level, name_)
        if self.domainOfValidity is not None:
            showIndent(outfile, level)
            outfile.write('domainOfValidity=model_.domainOfValidity(\n')
            self.domainOfValidity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('scope=[\n')
        level += 1
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.operationVersion is not None:
            showIndent(outfile, level)
            outfile.write('operationVersion=%s,\n' % quote_python(self.operationVersion).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('coordinateOperationAccuracy=[\n')
        level += 1
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            showIndent(outfile, level)
            outfile.write('model_.coordinateOperationAccuracy(\n')
            coordinateOperationAccuracy_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.sourceCRS is not None:
            showIndent(outfile, level)
            outfile.write('sourceCRS=model_.sourceCRS(\n')
            self.sourceCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.targetCRS is not None:
            showIndent(outfile, level)
            outfile.write('targetCRS=model_.targetCRS(\n')
            self.targetCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractCoordinateOperationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.set_domainOfValidity(obj_)
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'operationVersion':
            operationVersion_ = child_.text
            operationVersion_ = self.gds_validate_string(operationVersion_, node, 'operationVersion')
            self.operationVersion = operationVersion_
        elif nodeName_ == 'coordinateOperationAccuracy':
            obj_ = coordinateOperationAccuracy.factory()
            obj_.build(child_)
            self.coordinateOperationAccuracy.append(obj_)
        elif nodeName_ == 'sourceCRS':
            obj_ = CRSPropertyType.factory()
            obj_.build(child_)
            self.set_sourceCRS(obj_)
        elif nodeName_ == 'targetCRS':
            obj_ = CRSPropertyType.factory()
            obj_.build(child_)
            self.set_targetCRS(obj_)
        super(AbstractCoordinateOperationType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractCoordinateOperationType


class coordinateOperationAccuracy(GeneratedsSuper):
    """gml:coordinateOperationAccuracy is an association role to a
    DQ_PositionalAccuracy object as encoded in ISO/TS 19139, either
    referencing or containing the definition of that positional
    accuracy. That object contains an estimate of the impact of this
    coordinate operation on point accuracy. That is, it gives
    position error estimates for the target coordinates of this
    coordinate operation, assuming no errors in the source
    coordinates."""
    subclass = None
    superclass = None
    def __init__(self, AbstractDQ_PositionalAccuracy=None):
        self.AbstractDQ_PositionalAccuracy = AbstractDQ_PositionalAccuracy
    def factory(*args_, **kwargs_):
        if coordinateOperationAccuracy.subclass:
            return coordinateOperationAccuracy.subclass(*args_, **kwargs_)
        else:
            return coordinateOperationAccuracy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractDQ_PositionalAccuracy(self): return self.AbstractDQ_PositionalAccuracy
    def set_AbstractDQ_PositionalAccuracy(self, AbstractDQ_PositionalAccuracy): self.AbstractDQ_PositionalAccuracy = AbstractDQ_PositionalAccuracy
    def export(self, outfile, level, namespace_='', name_='coordinateOperationAccuracy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coordinateOperationAccuracy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='coordinateOperationAccuracy'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='coordinateOperationAccuracy', fromsubclass_=False):
        if self.AbstractDQ_PositionalAccuracy is not None:
            self.AbstractDQ_PositionalAccuracy.export(outfile, level, namespace_, name_='AbstractDQ_PositionalAccuracy')
    def hasContent_(self):
        if (
            self.AbstractDQ_PositionalAccuracy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='coordinateOperationAccuracy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractDQ_PositionalAccuracy is not None:
            showIndent(outfile, level)
            outfile.write('AbstractDQ_PositionalAccuracy=model_.AbstractDQ_PositionalAccuracy(\n')
            self.AbstractDQ_PositionalAccuracy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractDQ_PositionalAccuracy':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractDQ_PositionalAccuracy> element')
            self.set_AbstractDQ_PositionalAccuracy(obj_)
# end class coordinateOperationAccuracy


class CoordinateOperationPropertyType(GeneratedsSuper):
    """gml:CoordinateOperationPropertyType is a property type for
    association roles to a coordinate operation, either referencing
    or containing the definition of that coordinate operation."""
    subclass = None
    superclass = None
    def __init__(self, AbstractCoordinateOperation=None):
        self.AbstractCoordinateOperation = AbstractCoordinateOperation
    def factory(*args_, **kwargs_):
        if CoordinateOperationPropertyType.subclass:
            return CoordinateOperationPropertyType.subclass(*args_, **kwargs_)
        else:
            return CoordinateOperationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractCoordinateOperation(self): return self.AbstractCoordinateOperation
    def set_AbstractCoordinateOperation(self, AbstractCoordinateOperation): self.AbstractCoordinateOperation = AbstractCoordinateOperation
    def export(self, outfile, level, namespace_='', name_='CoordinateOperationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateOperationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoordinateOperationPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoordinateOperationPropertyType', fromsubclass_=False):
        if self.AbstractCoordinateOperation is not None:
            self.AbstractCoordinateOperation.export(outfile, level, namespace_, name_='AbstractCoordinateOperation')
    def hasContent_(self):
        if (
            self.AbstractCoordinateOperation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoordinateOperationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractCoordinateOperation is not None:
            showIndent(outfile, level)
            outfile.write('AbstractCoordinateOperation=model_.AbstractCoordinateOperation(\n')
            self.AbstractCoordinateOperation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractCoordinateOperation':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractCoordinateOperation> element')
            self.set_AbstractCoordinateOperation(obj_)
# end class CoordinateOperationPropertyType


class SingleOperationPropertyType(GeneratedsSuper):
    """gml:SingleOperationPropertyType is a property type for association
    roles to a single operation, either referencing or containing
    the definition of that single operation."""
    subclass = None
    superclass = None
    def __init__(self, AbstractSingleOperation=None):
        self.AbstractSingleOperation = AbstractSingleOperation
    def factory(*args_, **kwargs_):
        if SingleOperationPropertyType.subclass:
            return SingleOperationPropertyType.subclass(*args_, **kwargs_)
        else:
            return SingleOperationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractSingleOperation(self): return self.AbstractSingleOperation
    def set_AbstractSingleOperation(self, AbstractSingleOperation): self.AbstractSingleOperation = AbstractSingleOperation
    def export(self, outfile, level, namespace_='', name_='SingleOperationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SingleOperationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SingleOperationPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SingleOperationPropertyType', fromsubclass_=False):
        if self.AbstractSingleOperation is not None:
            self.AbstractSingleOperation.export(outfile, level, namespace_, name_='AbstractSingleOperation')
    def hasContent_(self):
        if (
            self.AbstractSingleOperation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SingleOperationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractSingleOperation is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSingleOperation=model_.AbstractSingleOperation(\n')
            self.AbstractSingleOperation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractSingleOperation':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractSingleOperation> element')
            self.set_AbstractSingleOperation(obj_)
# end class SingleOperationPropertyType


class AbstractGeneralConversionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, coordinateOperationAccuracy=None, extensiontype_=None):
        self.id = _cast(None, id)
        if metaDataProperty is None:
            self.metaDataProperty = []
        else:
            self.metaDataProperty = metaDataProperty
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.remarks = remarks
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        if coordinateOperationAccuracy is None:
            self.coordinateOperationAccuracy = []
        else:
            self.coordinateOperationAccuracy = coordinateOperationAccuracy
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeneralConversionType.subclass:
            return AbstractGeneralConversionType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralConversionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaDataProperty(self): return self.metaDataProperty
    def set_metaDataProperty(self, metaDataProperty): self.metaDataProperty = metaDataProperty
    def add_metaDataProperty(self, value): self.metaDataProperty.append(value)
    def insert_metaDataProperty(self, index, value): self.metaDataProperty[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name(self, index, value): self.name[index] = value
    def get_remarks(self): return self.remarks
    def set_remarks(self, remarks): self.remarks = remarks
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope(self, index, value): self.scope[index] = value
    def get_coordinateOperationAccuracy(self): return self.coordinateOperationAccuracy
    def set_coordinateOperationAccuracy(self, coordinateOperationAccuracy): self.coordinateOperationAccuracy = coordinateOperationAccuracy
    def add_coordinateOperationAccuracy(self, value): self.coordinateOperationAccuracy.append(value)
    def insert_coordinateOperationAccuracy(self, index, value): self.coordinateOperationAccuracy[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeneralConversionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralConversionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeneralConversionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeneralConversionType', fromsubclass_=False):
        for metaDataProperty_ in self.metaDataProperty:
            metaDataProperty_.export(outfile, level, namespace_, name_='metaDataProperty')
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_, name_='descriptionReference')
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', )
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name')
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('<%sremarks>%s</%sremarks>\n' % (namespace_, self.gds_format_string(quote_xml(self.remarks).encode(ExternalEncoding), input_name='remarks'), namespace_))
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_, name_='domainOfValidity')
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.gds_format_string(quote_xml(scope_).encode(ExternalEncoding), input_name='scope'), namespace_))
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            coordinateOperationAccuracy_.export(outfile, level, namespace_, name_='coordinateOperationAccuracy')
    def hasContent_(self):
        if (
            self.metaDataProperty or
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name or
            self.remarks is not None or
            self.domainOfValidity is not None or
            self.scope or
            self.coordinateOperationAccuracy
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeneralConversionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metaDataProperty=[\n')
        level += 1
        for metaDataProperty_ in self.metaDataProperty:
            showIndent(outfile, level)
            outfile.write('model_.metaDataProperty(\n')
            metaDataProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptionReference is not None:
            showIndent(outfile, level)
            outfile.write('descriptionReference=model_.descriptionReference(\n')
            self.descriptionReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.identifier(\n')
            self.identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.name(\n')
            name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('remarks=%s,\n' % quote_python(self.remarks).encode(ExternalEncoding))
        if self.domainOfValidity is not None:
            showIndent(outfile, level)
            outfile.write('domainOfValidity=model_.domainOfValidity(\n')
            self.domainOfValidity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('scope=[\n')
        level += 1
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('coordinateOperationAccuracy=[\n')
        level += 1
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            showIndent(outfile, level)
            outfile.write('model_.coordinateOperationAccuracy(\n')
            coordinateOperationAccuracy_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaDataProperty':
            obj_ = MetaDataPropertyType.factory()
            obj_.build(child_)
            self.metaDataProperty.append(obj_)
        elif nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_descriptionReference(obj_)
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
        elif nodeName_ == 'remarks':
            remarks_ = child_.text
            remarks_ = self.gds_validate_string(remarks_, node, 'remarks')
            self.remarks = remarks_
        elif nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.set_domainOfValidity(obj_)
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'coordinateOperationAccuracy':
            obj_ = coordinateOperationAccuracy.factory()
            obj_.build(child_)
            self.coordinateOperationAccuracy.append(obj_)
# end class AbstractGeneralConversionType


class GeneralConversionPropertyType(GeneratedsSuper):
    """gml:GeneralConversionPropertyType is a property type for association
    roles to a general conversion, either referencing or containing
    the definition of that conversion."""
    subclass = None
    superclass = None
    def __init__(self, AbstractGeneralConversion=None):
        self.AbstractGeneralConversion = AbstractGeneralConversion
    def factory(*args_, **kwargs_):
        if GeneralConversionPropertyType.subclass:
            return GeneralConversionPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeneralConversionPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeneralConversion(self): return self.AbstractGeneralConversion
    def set_AbstractGeneralConversion(self, AbstractGeneralConversion): self.AbstractGeneralConversion = AbstractGeneralConversion
    def export(self, outfile, level, namespace_='', name_='GeneralConversionPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralConversionPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeneralConversionPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeneralConversionPropertyType', fromsubclass_=False):
        if self.AbstractGeneralConversion is not None:
            self.AbstractGeneralConversion.export(outfile, level, namespace_, name_='AbstractGeneralConversion')
    def hasContent_(self):
        if (
            self.AbstractGeneralConversion is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeneralConversionPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeneralConversion is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeneralConversion=model_.AbstractGeneralConversion(\n')
            self.AbstractGeneralConversion.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeneralConversion':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeneralConversion> element')
            self.set_AbstractGeneralConversion(obj_)
# end class GeneralConversionPropertyType


class AbstractGeneralTransformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, operationVersion=None, coordinateOperationAccuracy=None, sourceCRS=None, targetCRS=None, extensiontype_=None):
        self.id = _cast(None, id)
        if metaDataProperty is None:
            self.metaDataProperty = []
        else:
            self.metaDataProperty = metaDataProperty
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.remarks = remarks
        self.domainOfValidity = domainOfValidity
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.operationVersion = operationVersion
        if coordinateOperationAccuracy is None:
            self.coordinateOperationAccuracy = []
        else:
            self.coordinateOperationAccuracy = coordinateOperationAccuracy
        self.sourceCRS = sourceCRS
        self.targetCRS = targetCRS
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeneralTransformationType.subclass:
            return AbstractGeneralTransformationType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralTransformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaDataProperty(self): return self.metaDataProperty
    def set_metaDataProperty(self, metaDataProperty): self.metaDataProperty = metaDataProperty
    def add_metaDataProperty(self, value): self.metaDataProperty.append(value)
    def insert_metaDataProperty(self, index, value): self.metaDataProperty[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name(self, index, value): self.name[index] = value
    def get_remarks(self): return self.remarks
    def set_remarks(self, remarks): self.remarks = remarks
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope(self, index, value): self.scope[index] = value
    def get_operationVersion(self): return self.operationVersion
    def set_operationVersion(self, operationVersion): self.operationVersion = operationVersion
    def get_coordinateOperationAccuracy(self): return self.coordinateOperationAccuracy
    def set_coordinateOperationAccuracy(self, coordinateOperationAccuracy): self.coordinateOperationAccuracy = coordinateOperationAccuracy
    def add_coordinateOperationAccuracy(self, value): self.coordinateOperationAccuracy.append(value)
    def insert_coordinateOperationAccuracy(self, index, value): self.coordinateOperationAccuracy[index] = value
    def get_sourceCRS(self): return self.sourceCRS
    def set_sourceCRS(self, sourceCRS): self.sourceCRS = sourceCRS
    def get_targetCRS(self): return self.targetCRS
    def set_targetCRS(self, targetCRS): self.targetCRS = targetCRS
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeneralTransformationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralTransformationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeneralTransformationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeneralTransformationType', fromsubclass_=False):
        for metaDataProperty_ in self.metaDataProperty:
            metaDataProperty_.export(outfile, level, namespace_, name_='metaDataProperty')
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_, name_='descriptionReference')
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', )
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name')
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('<%sremarks>%s</%sremarks>\n' % (namespace_, self.gds_format_string(quote_xml(self.remarks).encode(ExternalEncoding), input_name='remarks'), namespace_))
        if self.domainOfValidity is not None:
            self.domainOfValidity.export(outfile, level, namespace_, name_='domainOfValidity')
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.gds_format_string(quote_xml(scope_).encode(ExternalEncoding), input_name='scope'), namespace_))
        if self.operationVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%soperationVersion>%s</%soperationVersion>\n' % (namespace_, self.gds_format_string(quote_xml(self.operationVersion).encode(ExternalEncoding), input_name='operationVersion'), namespace_))
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            coordinateOperationAccuracy_.export(outfile, level, namespace_, name_='coordinateOperationAccuracy')
        if self.sourceCRS is not None:
            self.sourceCRS.export(outfile, level, namespace_, name_='sourceCRS', )
        if self.targetCRS is not None:
            self.targetCRS.export(outfile, level, namespace_, name_='targetCRS', )
    def hasContent_(self):
        if (
            self.metaDataProperty or
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name or
            self.remarks is not None or
            self.domainOfValidity is not None or
            self.scope or
            self.operationVersion is not None or
            self.coordinateOperationAccuracy or
            self.sourceCRS is not None or
            self.targetCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeneralTransformationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metaDataProperty=[\n')
        level += 1
        for metaDataProperty_ in self.metaDataProperty:
            showIndent(outfile, level)
            outfile.write('model_.metaDataProperty(\n')
            metaDataProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptionReference is not None:
            showIndent(outfile, level)
            outfile.write('descriptionReference=model_.descriptionReference(\n')
            self.descriptionReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.identifier(\n')
            self.identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.name(\n')
            name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.remarks is not None:
            showIndent(outfile, level)
            outfile.write('remarks=%s,\n' % quote_python(self.remarks).encode(ExternalEncoding))
        if self.domainOfValidity is not None:
            showIndent(outfile, level)
            outfile.write('domainOfValidity=model_.domainOfValidity(\n')
            self.domainOfValidity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('scope=[\n')
        level += 1
        for scope_ in self.scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.operationVersion is not None:
            showIndent(outfile, level)
            outfile.write('operationVersion=%s,\n' % quote_python(self.operationVersion).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('coordinateOperationAccuracy=[\n')
        level += 1
        for coordinateOperationAccuracy_ in self.coordinateOperationAccuracy:
            showIndent(outfile, level)
            outfile.write('model_.coordinateOperationAccuracy(\n')
            coordinateOperationAccuracy_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.sourceCRS is not None:
            showIndent(outfile, level)
            outfile.write('sourceCRS=model_.sourceCRS(\n')
            self.sourceCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.targetCRS is not None:
            showIndent(outfile, level)
            outfile.write('targetCRS=model_.targetCRS(\n')
            self.targetCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaDataProperty':
            obj_ = MetaDataPropertyType.factory()
            obj_.build(child_)
            self.metaDataProperty.append(obj_)
        elif nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_descriptionReference(obj_)
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
        elif nodeName_ == 'remarks':
            remarks_ = child_.text
            remarks_ = self.gds_validate_string(remarks_, node, 'remarks')
            self.remarks = remarks_
        elif nodeName_ == 'domainOfValidity':
            obj_ = domainOfValidity.factory()
            obj_.build(child_)
            self.set_domainOfValidity(obj_)
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'operationVersion':
            operationVersion_ = child_.text
            operationVersion_ = self.gds_validate_string(operationVersion_, node, 'operationVersion')
            self.operationVersion = operationVersion_
        elif nodeName_ == 'coordinateOperationAccuracy':
            obj_ = coordinateOperationAccuracy.factory()
            obj_.build(child_)
            self.coordinateOperationAccuracy.append(obj_)
        elif nodeName_ == 'sourceCRS':
            obj_ = CRSPropertyType.factory()
            obj_.build(child_)
            self.set_sourceCRS(obj_)
        elif nodeName_ == 'targetCRS':
            obj_ = CRSPropertyType.factory()
            obj_.build(child_)
            self.set_targetCRS(obj_)
# end class AbstractGeneralTransformationType


class GeneralTransformationPropertyType(GeneratedsSuper):
    """gml:GeneralTransformationPropertyType is a property type for
    association roles to a general transformation, either
    referencing or containing the definition of that transformation."""
    subclass = None
    superclass = None
    def __init__(self, AbstractGeneralTransformation=None):
        self.AbstractGeneralTransformation = AbstractGeneralTransformation
    def factory(*args_, **kwargs_):
        if GeneralTransformationPropertyType.subclass:
            return GeneralTransformationPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeneralTransformationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeneralTransformation(self): return self.AbstractGeneralTransformation
    def set_AbstractGeneralTransformation(self, AbstractGeneralTransformation): self.AbstractGeneralTransformation = AbstractGeneralTransformation
    def export(self, outfile, level, namespace_='', name_='GeneralTransformationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralTransformationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeneralTransformationPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeneralTransformationPropertyType', fromsubclass_=False):
        if self.AbstractGeneralTransformation is not None:
            self.AbstractGeneralTransformation.export(outfile, level, namespace_, name_='AbstractGeneralTransformation')
    def hasContent_(self):
        if (
            self.AbstractGeneralTransformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeneralTransformationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeneralTransformation is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeneralTransformation=model_.AbstractGeneralTransformation(\n')
            self.AbstractGeneralTransformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeneralTransformation':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeneralTransformation> element')
            self.set_AbstractGeneralTransformation(obj_)
# end class GeneralTransformationPropertyType


class ConcatenatedOperationType(AbstractCoordinateOperationType):
    """gml:ConcatenatedOperation is an ordered sequence of two or more
    coordinate operations. This sequence of operations is
    constrained by the requirement that the source coordinate
    reference system of step (n+1) must be the same as the target
    coordinate reference system of step (n). The source coordinate
    reference system of the first step and the target coordinate
    reference system of the last step are the source and target
    coordinate reference system associated with the concatenated
    operation. Instead of a forward operation, an inverse operation
    may be used for one or more of the operation steps mentioned
    above, if the inverse operation is uniquely defined by the
    forward operation. The gml:coordOperation property elements are
    an ordered sequence of associations to the two or more
    operations used by this concatenated operation. The
    AggregationAttributeGroup should be used to specify that the
    coordOperation associations are ordered."""
    subclass = None
    superclass = AbstractCoordinateOperationType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, operationVersion=None, coordinateOperationAccuracy=None, sourceCRS=None, targetCRS=None, aggregationType=None, coordOperation=None):
        super(ConcatenatedOperationType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, operationVersion, coordinateOperationAccuracy, sourceCRS, targetCRS, )
        self.aggregationType = _cast(None, aggregationType)
        if coordOperation is None:
            self.coordOperation = []
        else:
            self.coordOperation = coordOperation
    def factory(*args_, **kwargs_):
        if ConcatenatedOperationType.subclass:
            return ConcatenatedOperationType.subclass(*args_, **kwargs_)
        else:
            return ConcatenatedOperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coordOperation(self): return self.coordOperation
    def set_coordOperation(self, coordOperation): self.coordOperation = coordOperation
    def add_coordOperation(self, value): self.coordOperation.append(value)
    def insert_coordOperation(self, index, value): self.coordOperation[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='ConcatenatedOperationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConcatenatedOperationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConcatenatedOperationType'):
        super(ConcatenatedOperationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConcatenatedOperationType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConcatenatedOperationType', fromsubclass_=False):
        super(ConcatenatedOperationType, self).exportChildren(outfile, level, namespace_, name_, True)
        for coordOperation_ in self.coordOperation:
            coordOperation_.export(outfile, level, namespace_, name_='coordOperation')
    def hasContent_(self):
        if (
            self.coordOperation or
            super(ConcatenatedOperationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConcatenatedOperationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(ConcatenatedOperationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConcatenatedOperationType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('coordOperation=[\n')
        level += 1
        for coordOperation_ in self.coordOperation:
            showIndent(outfile, level)
            outfile.write('model_.coordOperation(\n')
            coordOperation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(ConcatenatedOperationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'coordOperation':
            obj_ = CoordinateOperationPropertyType.factory()
            obj_.build(child_)
            self.coordOperation.append(obj_)
        super(ConcatenatedOperationType, self).buildChildren(child_, node, nodeName_, True)
# end class ConcatenatedOperationType


class ConcatenatedOperationPropertyType(GeneratedsSuper):
    """gml:ConcatenatedOperationPropertyType is a property type for
    association roles to a concatenated operation, either
    referencing or containing the definition of that concatenated
    operation."""
    subclass = None
    superclass = None
    def __init__(self, ConcatenatedOperation=None):
        self.ConcatenatedOperation = ConcatenatedOperation
    def factory(*args_, **kwargs_):
        if ConcatenatedOperationPropertyType.subclass:
            return ConcatenatedOperationPropertyType.subclass(*args_, **kwargs_)
        else:
            return ConcatenatedOperationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConcatenatedOperation(self): return self.ConcatenatedOperation
    def set_ConcatenatedOperation(self, ConcatenatedOperation): self.ConcatenatedOperation = ConcatenatedOperation
    def export(self, outfile, level, namespace_='', name_='ConcatenatedOperationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConcatenatedOperationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConcatenatedOperationPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConcatenatedOperationPropertyType', fromsubclass_=False):
        if self.ConcatenatedOperation is not None:
            self.ConcatenatedOperation.export(outfile, level, namespace_, name_='ConcatenatedOperation', )
    def hasContent_(self):
        if (
            self.ConcatenatedOperation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConcatenatedOperationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ConcatenatedOperation is not None:
            showIndent(outfile, level)
            outfile.write('ConcatenatedOperation=model_.ConcatenatedOperation(\n')
            self.ConcatenatedOperation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConcatenatedOperation':
            obj_ = ConcatenatedOperationType.factory()
            obj_.build(child_)
            self.set_ConcatenatedOperation(obj_)
# end class ConcatenatedOperationPropertyType


class PassThroughOperationType(AbstractCoordinateOperationType):
    subclass = None
    superclass = AbstractCoordinateOperationType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, operationVersion=None, coordinateOperationAccuracy=None, sourceCRS=None, targetCRS=None, aggregationType=None, modifiedCoordinate=None, coordOperation=None):
        super(PassThroughOperationType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, operationVersion, coordinateOperationAccuracy, sourceCRS, targetCRS, )
        self.aggregationType = _cast(None, aggregationType)
        if modifiedCoordinate is None:
            self.modifiedCoordinate = []
        else:
            self.modifiedCoordinate = modifiedCoordinate
        self.coordOperation = coordOperation
    def factory(*args_, **kwargs_):
        if PassThroughOperationType.subclass:
            return PassThroughOperationType.subclass(*args_, **kwargs_)
        else:
            return PassThroughOperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modifiedCoordinate(self): return self.modifiedCoordinate
    def set_modifiedCoordinate(self, modifiedCoordinate): self.modifiedCoordinate = modifiedCoordinate
    def add_modifiedCoordinate(self, value): self.modifiedCoordinate.append(value)
    def insert_modifiedCoordinate(self, index, value): self.modifiedCoordinate[index] = value
    def get_coordOperation(self): return self.coordOperation
    def set_coordOperation(self, coordOperation): self.coordOperation = coordOperation
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='PassThroughOperationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PassThroughOperationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PassThroughOperationType'):
        super(PassThroughOperationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PassThroughOperationType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PassThroughOperationType', fromsubclass_=False):
        super(PassThroughOperationType, self).exportChildren(outfile, level, namespace_, name_, True)
        for modifiedCoordinate_ in self.modifiedCoordinate:
            showIndent(outfile, level)
            outfile.write('<%smodifiedCoordinate>%s</%smodifiedCoordinate>\n' % (namespace_, self.gds_format_string(quote_xml(modifiedCoordinate_).encode(ExternalEncoding), input_name='modifiedCoordinate'), namespace_))
        if self.coordOperation is not None:
            self.coordOperation.export(outfile, level, namespace_, name_='coordOperation', )
    def hasContent_(self):
        if (
            self.modifiedCoordinate or
            self.coordOperation is not None or
            super(PassThroughOperationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PassThroughOperationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(PassThroughOperationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PassThroughOperationType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('modifiedCoordinate=[\n')
        level += 1
        for modifiedCoordinate_ in self.modifiedCoordinate:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(modifiedCoordinate_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.coordOperation is not None:
            showIndent(outfile, level)
            outfile.write('coordOperation=model_.coordOperation(\n')
            self.coordOperation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(PassThroughOperationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modifiedCoordinate':
            modifiedCoordinate_ = child_.text
            modifiedCoordinate_ = self.gds_validate_string(modifiedCoordinate_, node, 'modifiedCoordinate')
            self.modifiedCoordinate.append(modifiedCoordinate_)
        elif nodeName_ == 'coordOperation':
            obj_ = CoordinateOperationPropertyType.factory()
            obj_.build(child_)
            self.set_coordOperation(obj_)
        super(PassThroughOperationType, self).buildChildren(child_, node, nodeName_, True)
# end class PassThroughOperationType


class PassThroughOperationPropertyType(GeneratedsSuper):
    """gml:PassThroughOperationPropertyType is a property type for
    association roles to a pass through operation, either
    referencing or containing the definition of that pass through
    operation."""
    subclass = None
    superclass = None
    def __init__(self, PassThroughOperation=None):
        self.PassThroughOperation = PassThroughOperation
    def factory(*args_, **kwargs_):
        if PassThroughOperationPropertyType.subclass:
            return PassThroughOperationPropertyType.subclass(*args_, **kwargs_)
        else:
            return PassThroughOperationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PassThroughOperation(self): return self.PassThroughOperation
    def set_PassThroughOperation(self, PassThroughOperation): self.PassThroughOperation = PassThroughOperation
    def export(self, outfile, level, namespace_='', name_='PassThroughOperationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PassThroughOperationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PassThroughOperationPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PassThroughOperationPropertyType', fromsubclass_=False):
        if self.PassThroughOperation is not None:
            self.PassThroughOperation.export(outfile, level, namespace_, name_='PassThroughOperation', )
    def hasContent_(self):
        if (
            self.PassThroughOperation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PassThroughOperationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PassThroughOperation is not None:
            showIndent(outfile, level)
            outfile.write('PassThroughOperation=model_.PassThroughOperation(\n')
            self.PassThroughOperation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PassThroughOperation':
            obj_ = PassThroughOperationType.factory()
            obj_.build(child_)
            self.set_PassThroughOperation(obj_)
# end class PassThroughOperationPropertyType


class ConversionType(AbstractGeneralConversionType):
    subclass = None
    superclass = AbstractGeneralConversionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, coordinateOperationAccuracy=None, method=None, parameterValue=None):
        super(ConversionType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, coordinateOperationAccuracy, )
        self.method = method
        if parameterValue is None:
            self.parameterValue = []
        else:
            self.parameterValue = parameterValue
    def factory(*args_, **kwargs_):
        if ConversionType.subclass:
            return ConversionType.subclass(*args_, **kwargs_)
        else:
            return ConversionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_parameterValue(self): return self.parameterValue
    def set_parameterValue(self, parameterValue): self.parameterValue = parameterValue
    def add_parameterValue(self, value): self.parameterValue.append(value)
    def insert_parameterValue(self, index, value): self.parameterValue[index] = value
    def export(self, outfile, level, namespace_='', name_='ConversionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConversionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConversionType'):
        super(ConversionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConversionType')
    def exportChildren(self, outfile, level, namespace_='', name_='ConversionType', fromsubclass_=False):
        super(ConversionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.method is not None:
            self.method.export(outfile, level, namespace_, name_='method', )
        for parameterValue_ in self.parameterValue:
            parameterValue_.export(outfile, level, namespace_, name_='parameterValue')
    def hasContent_(self):
        if (
            self.method is not None or
            self.parameterValue or
            super(ConversionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConversionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConversionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConversionType, self).exportLiteralChildren(outfile, level, name_)
        if self.method is not None:
            showIndent(outfile, level)
            outfile.write('method=model_.method(\n')
            self.method.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('parameterValue=[\n')
        level += 1
        for parameterValue_ in self.parameterValue:
            showIndent(outfile, level)
            outfile.write('model_.parameterValue(\n')
            parameterValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ConversionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'method':
            obj_ = OperationMethodPropertyType.factory()
            obj_.build(child_)
            self.set_method(obj_)
        elif nodeName_ == 'parameterValue':
            obj_ = AbstractGeneralParameterValuePropertyType.factory()
            obj_.build(child_)
            self.parameterValue.append(obj_)
        super(ConversionType, self).buildChildren(child_, node, nodeName_, True)
# end class ConversionType


class ConversionPropertyType(GeneratedsSuper):
    """gml:ConversionPropertyType is a property type for association roles
    to a concrete general-purpose conversion, either referencing or
    containing the definition of that conversion."""
    subclass = None
    superclass = None
    def __init__(self, Conversion=None):
        self.Conversion = Conversion
    def factory(*args_, **kwargs_):
        if ConversionPropertyType.subclass:
            return ConversionPropertyType.subclass(*args_, **kwargs_)
        else:
            return ConversionPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Conversion(self): return self.Conversion
    def set_Conversion(self, Conversion): self.Conversion = Conversion
    def export(self, outfile, level, namespace_='', name_='ConversionPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConversionPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConversionPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConversionPropertyType', fromsubclass_=False):
        if self.Conversion is not None:
            self.Conversion.export(outfile, level, namespace_, name_='Conversion', )
    def hasContent_(self):
        if (
            self.Conversion is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConversionPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Conversion is not None:
            showIndent(outfile, level)
            outfile.write('Conversion=model_.Conversion(\n')
            self.Conversion.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Conversion':
            obj_ = ConversionType.factory()
            obj_.build(child_)
            self.set_Conversion(obj_)
# end class ConversionPropertyType


class TransformationType(AbstractGeneralTransformationType):
    subclass = None
    superclass = AbstractGeneralTransformationType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, operationVersion=None, coordinateOperationAccuracy=None, sourceCRS=None, targetCRS=None, method=None, parameterValue=None):
        super(TransformationType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, operationVersion, coordinateOperationAccuracy, sourceCRS, targetCRS, )
        self.method = method
        if parameterValue is None:
            self.parameterValue = []
        else:
            self.parameterValue = parameterValue
    def factory(*args_, **kwargs_):
        if TransformationType.subclass:
            return TransformationType.subclass(*args_, **kwargs_)
        else:
            return TransformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_parameterValue(self): return self.parameterValue
    def set_parameterValue(self, parameterValue): self.parameterValue = parameterValue
    def add_parameterValue(self, value): self.parameterValue.append(value)
    def insert_parameterValue(self, index, value): self.parameterValue[index] = value
    def export(self, outfile, level, namespace_='', name_='TransformationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformationType'):
        super(TransformationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TransformationType')
    def exportChildren(self, outfile, level, namespace_='', name_='TransformationType', fromsubclass_=False):
        super(TransformationType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.method is not None:
            self.method.export(outfile, level, namespace_, name_='method', )
        for parameterValue_ in self.parameterValue:
            parameterValue_.export(outfile, level, namespace_, name_='parameterValue')
    def hasContent_(self):
        if (
            self.method is not None or
            self.parameterValue or
            super(TransformationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TransformationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TransformationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TransformationType, self).exportLiteralChildren(outfile, level, name_)
        if self.method is not None:
            showIndent(outfile, level)
            outfile.write('method=model_.method(\n')
            self.method.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('parameterValue=[\n')
        level += 1
        for parameterValue_ in self.parameterValue:
            showIndent(outfile, level)
            outfile.write('model_.parameterValue(\n')
            parameterValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TransformationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'method':
            obj_ = OperationMethodPropertyType.factory()
            obj_.build(child_)
            self.set_method(obj_)
        elif nodeName_ == 'parameterValue':
            obj_ = AbstractGeneralParameterValuePropertyType.factory()
            obj_.build(child_)
            self.parameterValue.append(obj_)
        super(TransformationType, self).buildChildren(child_, node, nodeName_, True)
# end class TransformationType


class TransformationPropertyType(GeneratedsSuper):
    """gml:TransformationPropertyType is a property type for association
    roles to a transformation, either referencing or containing the
    definition of that transformation."""
    subclass = None
    superclass = None
    def __init__(self, Transformation=None):
        self.Transformation = Transformation
    def factory(*args_, **kwargs_):
        if TransformationPropertyType.subclass:
            return TransformationPropertyType.subclass(*args_, **kwargs_)
        else:
            return TransformationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transformation(self): return self.Transformation
    def set_Transformation(self, Transformation): self.Transformation = Transformation
    def export(self, outfile, level, namespace_='', name_='TransformationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformationPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransformationPropertyType', fromsubclass_=False):
        if self.Transformation is not None:
            self.Transformation.export(outfile, level, namespace_, name_='Transformation', )
    def hasContent_(self):
        if (
            self.Transformation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TransformationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Transformation is not None:
            showIndent(outfile, level)
            outfile.write('Transformation=model_.Transformation(\n')
            self.Transformation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transformation':
            obj_ = TransformationType.factory()
            obj_.build(child_)
            self.set_Transformation(obj_)
# end class TransformationPropertyType


class AbstractGeneralParameterValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeneralParameterValueType.subclass:
            return AbstractGeneralParameterValueType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeneralParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeneralParameterValueType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeneralParameterValueType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeneralParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractGeneralParameterValueType


class AbstractGeneralParameterValuePropertyType(GeneratedsSuper):
    """gml:AbstractGeneralParameterValuePropertyType is a property type for
    inline association roles to a parameter value or group of
    parameter values, always containing the values."""
    subclass = None
    superclass = None
    def __init__(self, AbstractGeneralParameterValue=None):
        self.AbstractGeneralParameterValue = AbstractGeneralParameterValue
    def factory(*args_, **kwargs_):
        if AbstractGeneralParameterValuePropertyType.subclass:
            return AbstractGeneralParameterValuePropertyType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralParameterValuePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeneralParameterValue(self): return self.AbstractGeneralParameterValue
    def set_AbstractGeneralParameterValue(self, AbstractGeneralParameterValue): self.AbstractGeneralParameterValue = AbstractGeneralParameterValue
    def export(self, outfile, level, namespace_='', name_='AbstractGeneralParameterValuePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralParameterValuePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeneralParameterValuePropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeneralParameterValuePropertyType', fromsubclass_=False):
        if self.AbstractGeneralParameterValue is not None:
            self.AbstractGeneralParameterValue.export(outfile, level, namespace_, name_='AbstractGeneralParameterValue')
    def hasContent_(self):
        if (
            self.AbstractGeneralParameterValue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeneralParameterValuePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeneralParameterValue is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeneralParameterValue=model_.AbstractGeneralParameterValue(\n')
            self.AbstractGeneralParameterValue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeneralParameterValue':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeneralParameterValue> element')
            self.set_AbstractGeneralParameterValue(obj_)
# end class AbstractGeneralParameterValuePropertyType


class ParameterValueType(AbstractGeneralParameterValueType):
    subclass = None
    superclass = AbstractGeneralParameterValueType
    def __init__(self, value=None, dmsAngleValue=None, stringValue=None, integerValue=None, booleanValue=None, valueList=None, integerValueList=None, valueFile=None, operationParameter=None):
        super(ParameterValueType, self).__init__()
        self.value = value
        self.dmsAngleValue = dmsAngleValue
        self.stringValue = stringValue
        self.integerValue = integerValue
        self.booleanValue = booleanValue
        self.valueList = valueList
        self.integerValueList = integerValueList
        self.valueFile = valueFile
        self.operationParameter = operationParameter
    def factory(*args_, **kwargs_):
        if ParameterValueType.subclass:
            return ParameterValueType.subclass(*args_, **kwargs_)
        else:
            return ParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_dmsAngleValue(self): return self.dmsAngleValue
    def set_dmsAngleValue(self, dmsAngleValue): self.dmsAngleValue = dmsAngleValue
    def get_stringValue(self): return self.stringValue
    def set_stringValue(self, stringValue): self.stringValue = stringValue
    def get_integerValue(self): return self.integerValue
    def set_integerValue(self, integerValue): self.integerValue = integerValue
    def get_booleanValue(self): return self.booleanValue
    def set_booleanValue(self, booleanValue): self.booleanValue = booleanValue
    def get_valueList(self): return self.valueList
    def set_valueList(self, valueList): self.valueList = valueList
    def get_integerValueList(self): return self.integerValueList
    def set_integerValueList(self, integerValueList): self.integerValueList = integerValueList
    def get_valueFile(self): return self.valueFile
    def set_valueFile(self, valueFile): self.valueFile = valueFile
    def get_operationParameter(self): return self.operationParameter
    def set_operationParameter(self, operationParameter): self.operationParameter = operationParameter
    def export(self, outfile, level, namespace_='', name_='ParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterValueType'):
        super(ParameterValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterValueType')
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterValueType', fromsubclass_=False):
        super(ParameterValueType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', )
        if self.dmsAngleValue is not None:
            self.dmsAngleValue.export(outfile, level, namespace_, name_='dmsAngleValue', )
        if self.stringValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sstringValue>%s</%sstringValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.stringValue).encode(ExternalEncoding), input_name='stringValue'), namespace_))
        if self.integerValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sintegerValue>%s</%sintegerValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.integerValue).encode(ExternalEncoding), input_name='integerValue'), namespace_))
        if self.booleanValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sbooleanValue>%s</%sbooleanValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.booleanValue).encode(ExternalEncoding), input_name='booleanValue'), namespace_))
        if self.valueList is not None:
            self.valueList.export(outfile, level, namespace_, name_='valueList', )
        if self.integerValueList is not None:
            self.integerValueList.export(outfile, level, namespace_, name_='integerValueList', )
        if self.valueFile is not None:
            showIndent(outfile, level)
            outfile.write('<%svalueFile>%s</%svalueFile>\n' % (namespace_, self.gds_format_string(quote_xml(self.valueFile).encode(ExternalEncoding), input_name='valueFile'), namespace_))
        if self.operationParameter is not None:
            self.operationParameter.export(outfile, level, namespace_, name_='operationParameter', )
    def hasContent_(self):
        if (
            self.value is not None or
            self.dmsAngleValue is not None or
            self.stringValue is not None or
            self.integerValue is not None or
            self.booleanValue is not None or
            self.valueList is not None or
            self.integerValueList is not None or
            self.valueFile is not None or
            self.operationParameter is not None or
            super(ParameterValueType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ParameterValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ParameterValueType, self).exportLiteralChildren(outfile, level, name_)
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.value(\n')
            self.value.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dmsAngleValue is not None:
            showIndent(outfile, level)
            outfile.write('dmsAngleValue=model_.dmsAngleValue(\n')
            self.dmsAngleValue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.stringValue is not None:
            showIndent(outfile, level)
            outfile.write('stringValue=%s,\n' % quote_python(self.stringValue).encode(ExternalEncoding))
        if self.integerValue is not None:
            showIndent(outfile, level)
            outfile.write('integerValue=%s,\n' % quote_python(self.integerValue).encode(ExternalEncoding))
        if self.booleanValue is not None:
            showIndent(outfile, level)
            outfile.write('booleanValue=%s,\n' % quote_python(self.booleanValue).encode(ExternalEncoding))
        if self.valueList is not None:
            showIndent(outfile, level)
            outfile.write('valueList=model_.valueList(\n')
            self.valueList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.integerValueList is not None:
            showIndent(outfile, level)
            outfile.write('integerValueList=model_.integerValueList(\n')
            self.integerValueList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.valueFile is not None:
            showIndent(outfile, level)
            outfile.write('valueFile=%s,\n' % quote_python(self.valueFile).encode(ExternalEncoding))
        if self.operationParameter is not None:
            showIndent(outfile, level)
            outfile.write('operationParameter=model_.operationParameter(\n')
            self.operationParameter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ParameterValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_value(obj_)
        elif nodeName_ == 'dmsAngleValue':
            obj_ = DMSAngleType.factory()
            obj_.build(child_)
            self.set_dmsAngleValue(obj_)
        elif nodeName_ == 'stringValue':
            stringValue_ = child_.text
            stringValue_ = self.gds_validate_string(stringValue_, node, 'stringValue')
            self.stringValue = stringValue_
        elif nodeName_ == 'integerValue':
            integerValue_ = child_.text
            integerValue_ = self.gds_validate_string(integerValue_, node, 'integerValue')
            self.integerValue = integerValue_
        elif nodeName_ == 'booleanValue':
            booleanValue_ = child_.text
            booleanValue_ = self.gds_validate_string(booleanValue_, node, 'booleanValue')
            self.booleanValue = booleanValue_
        elif nodeName_ == 'valueList':
            obj_ = MeasureListType.factory()
            obj_.build(child_)
            self.set_valueList(obj_)
        elif nodeName_ == 'integerValueList':
            obj_ = integer.factory()
            obj_.build(child_)
            self.set_integerValueList(obj_)
        elif nodeName_ == 'valueFile':
            valueFile_ = child_.text
            valueFile_ = self.gds_validate_string(valueFile_, node, 'valueFile')
            self.valueFile = valueFile_
        elif nodeName_ == 'operationParameter':
            obj_ = OperationParameterPropertyType.factory()
            obj_.build(child_)
            self.set_operationParameter(obj_)
        super(ParameterValueType, self).buildChildren(child_, node, nodeName_, True)
# end class ParameterValueType


class ParameterValueGroupType(AbstractGeneralParameterValueType):
    subclass = None
    superclass = AbstractGeneralParameterValueType
    def __init__(self, parameterValue=None, group=None):
        super(ParameterValueGroupType, self).__init__()
        if parameterValue is None:
            self.parameterValue = []
        else:
            self.parameterValue = parameterValue
        self.group = group
    def factory(*args_, **kwargs_):
        if ParameterValueGroupType.subclass:
            return ParameterValueGroupType.subclass(*args_, **kwargs_)
        else:
            return ParameterValueGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameterValue(self): return self.parameterValue
    def set_parameterValue(self, parameterValue): self.parameterValue = parameterValue
    def add_parameterValue(self, value): self.parameterValue.append(value)
    def insert_parameterValue(self, index, value): self.parameterValue[index] = value
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def export(self, outfile, level, namespace_='', name_='ParameterValueGroupType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterValueGroupType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterValueGroupType'):
        super(ParameterValueGroupType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterValueGroupType')
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterValueGroupType', fromsubclass_=False):
        super(ParameterValueGroupType, self).exportChildren(outfile, level, namespace_, name_, True)
        for parameterValue_ in self.parameterValue:
            parameterValue_.export(outfile, level, namespace_, name_='parameterValue')
        if self.group is not None:
            self.group.export(outfile, level, namespace_, name_='group', )
    def hasContent_(self):
        if (
            self.parameterValue or
            self.group is not None or
            super(ParameterValueGroupType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterValueGroupType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ParameterValueGroupType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ParameterValueGroupType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('parameterValue=[\n')
        level += 1
        for parameterValue_ in self.parameterValue:
            showIndent(outfile, level)
            outfile.write('model_.parameterValue(\n')
            parameterValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=model_.group(\n')
            self.group.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ParameterValueGroupType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameterValue':
            obj_ = AbstractGeneralParameterValuePropertyType.factory()
            obj_.build(child_)
            self.parameterValue.append(obj_)
        elif nodeName_ == 'group':
            obj_ = OperationParameterGroupPropertyType.factory()
            obj_.build(child_)
            self.set_group(obj_)
        super(ParameterValueGroupType, self).buildChildren(child_, node, nodeName_, True)
# end class ParameterValueGroupType


class OperationMethodType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, formulaCitation=None, formula=None, sourceDimensions=None, targetDimensions=None, parameter=None):
        super(OperationMethodType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        self.formulaCitation = formulaCitation
        self.formula = formula
        self.sourceDimensions = sourceDimensions
        self.targetDimensions = targetDimensions
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if OperationMethodType.subclass:
            return OperationMethodType.subclass(*args_, **kwargs_)
        else:
            return OperationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formulaCitation(self): return self.formulaCitation
    def set_formulaCitation(self, formulaCitation): self.formulaCitation = formulaCitation
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_sourceDimensions(self): return self.sourceDimensions
    def set_sourceDimensions(self, sourceDimensions): self.sourceDimensions = sourceDimensions
    def get_targetDimensions(self): return self.targetDimensions
    def set_targetDimensions(self, targetDimensions): self.targetDimensions = targetDimensions
    def get_parameter(self): return self.parameter
    def set_parameter(self, parameter): self.parameter = parameter
    def add_parameter(self, value): self.parameter.append(value)
    def insert_parameter(self, index, value): self.parameter[index] = value
    def export(self, outfile, level, namespace_='', name_='OperationMethodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationMethodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationMethodType'):
        super(OperationMethodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OperationMethodType')
    def exportChildren(self, outfile, level, namespace_='', name_='OperationMethodType', fromsubclass_=False):
        super(OperationMethodType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.formulaCitation is not None:
            self.formulaCitation.export(outfile, level, namespace_, name_='formulaCitation', )
        if self.formula is not None:
            self.formula.export(outfile, level, namespace_, name_='formula', )
        if self.sourceDimensions is not None:
            showIndent(outfile, level)
            outfile.write('<%ssourceDimensions>%s</%ssourceDimensions>\n' % (namespace_, self.gds_format_string(quote_xml(self.sourceDimensions).encode(ExternalEncoding), input_name='sourceDimensions'), namespace_))
        if self.targetDimensions is not None:
            showIndent(outfile, level)
            outfile.write('<%stargetDimensions>%s</%stargetDimensions>\n' % (namespace_, self.gds_format_string(quote_xml(self.targetDimensions).encode(ExternalEncoding), input_name='targetDimensions'), namespace_))
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
    def hasContent_(self):
        if (
            self.formulaCitation is not None or
            self.formula is not None or
            self.sourceDimensions is not None or
            self.targetDimensions is not None or
            self.parameter or
            super(OperationMethodType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationMethodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OperationMethodType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OperationMethodType, self).exportLiteralChildren(outfile, level, name_)
        if self.formulaCitation is not None:
            showIndent(outfile, level)
            outfile.write('formulaCitation=model_.formulaCitation(\n')
            self.formulaCitation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.formula is not None:
            showIndent(outfile, level)
            outfile.write('formula=model_.formula(\n')
            self.formula.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sourceDimensions is not None:
            showIndent(outfile, level)
            outfile.write('sourceDimensions=%s,\n' % quote_python(self.sourceDimensions).encode(ExternalEncoding))
        if self.targetDimensions is not None:
            showIndent(outfile, level)
            outfile.write('targetDimensions=%s,\n' % quote_python(self.targetDimensions).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.parameter(\n')
            parameter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OperationMethodType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'formulaCitation':
            obj_ = formulaCitation.factory()
            obj_.build(child_)
            self.set_formulaCitation(obj_)
        elif nodeName_ == 'formula':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_formula(obj_)
        elif nodeName_ == 'sourceDimensions':
            sourceDimensions_ = child_.text
            sourceDimensions_ = self.gds_validate_string(sourceDimensions_, node, 'sourceDimensions')
            self.sourceDimensions = sourceDimensions_
        elif nodeName_ == 'targetDimensions':
            targetDimensions_ = child_.text
            targetDimensions_ = self.gds_validate_string(targetDimensions_, node, 'targetDimensions')
            self.targetDimensions = targetDimensions_
        elif nodeName_ == 'parameter':
            obj_ = AbstractGeneralOperationParameterPropertyType.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
        super(OperationMethodType, self).buildChildren(child_, node, nodeName_, True)
# end class OperationMethodType


class formulaCitation(GeneratedsSuper):
    """gml:formulaCitation provides a reference to a publication giving the
    formula(s) or procedure used by an coordinate operation method."""
    subclass = None
    superclass = None
    def __init__(self, CI_Citation=None):
        self.CI_Citation = CI_Citation
    def factory(*args_, **kwargs_):
        if formulaCitation.subclass:
            return formulaCitation.subclass(*args_, **kwargs_)
        else:
            return formulaCitation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CI_Citation(self): return self.CI_Citation
    def set_CI_Citation(self, CI_Citation): self.CI_Citation = CI_Citation
    def export(self, outfile, level, namespace_='', name_='formulaCitation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='formulaCitation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='formulaCitation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='formulaCitation', fromsubclass_=False):
        if self.CI_Citation is not None:
            self.CI_Citation.export(outfile, level, namespace_, name_='CI_Citation', )
    def hasContent_(self):
        if (
            self.CI_Citation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='formulaCitation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CI_Citation is not None:
            showIndent(outfile, level)
            outfile.write('CI_Citation=model_.CI_Citation(\n')
            self.CI_Citation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CI_Citation':
            obj_ = CI_Citation_Type.factory()
            obj_.build(child_)
            self.set_CI_Citation(obj_)
# end class formulaCitation


class OperationMethodPropertyType(GeneratedsSuper):
    """gml:OperationMethodPropertyType is a property type for association
    roles to a concrete general-purpose operation method, either
    referencing or containing the definition of that method."""
    subclass = None
    superclass = None
    def __init__(self, OperationMethod=None):
        self.OperationMethod = OperationMethod
    def factory(*args_, **kwargs_):
        if OperationMethodPropertyType.subclass:
            return OperationMethodPropertyType.subclass(*args_, **kwargs_)
        else:
            return OperationMethodPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OperationMethod(self): return self.OperationMethod
    def set_OperationMethod(self, OperationMethod): self.OperationMethod = OperationMethod
    def export(self, outfile, level, namespace_='', name_='OperationMethodPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationMethodPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationMethodPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OperationMethodPropertyType', fromsubclass_=False):
        if self.OperationMethod is not None:
            self.OperationMethod.export(outfile, level, namespace_, name_='OperationMethod', )
    def hasContent_(self):
        if (
            self.OperationMethod is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationMethodPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OperationMethod is not None:
            showIndent(outfile, level)
            outfile.write('OperationMethod=model_.OperationMethod(\n')
            self.OperationMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OperationMethod':
            obj_ = OperationMethodType.factory()
            obj_.build(child_)
            self.set_OperationMethod(obj_)
# end class OperationMethodPropertyType


class AbstractGeneralOperationParameterType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, minimumOccurs=None, extensiontype_=None):
        super(AbstractGeneralOperationParameterType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.minimumOccurs = minimumOccurs
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeneralOperationParameterType.subclass:
            return AbstractGeneralOperationParameterType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralOperationParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimumOccurs(self): return self.minimumOccurs
    def set_minimumOccurs(self, minimumOccurs): self.minimumOccurs = minimumOccurs
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeneralOperationParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralOperationParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeneralOperationParameterType'):
        super(AbstractGeneralOperationParameterType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralOperationParameterType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeneralOperationParameterType', fromsubclass_=False):
        super(AbstractGeneralOperationParameterType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.minimumOccurs is not None:
            showIndent(outfile, level)
            outfile.write('<%sminimumOccurs>%s</%sminimumOccurs>\n' % (namespace_, self.gds_format_string(quote_xml(self.minimumOccurs).encode(ExternalEncoding), input_name='minimumOccurs'), namespace_))
    def hasContent_(self):
        if (
            self.minimumOccurs is not None or
            super(AbstractGeneralOperationParameterType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeneralOperationParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractGeneralOperationParameterType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractGeneralOperationParameterType, self).exportLiteralChildren(outfile, level, name_)
        if self.minimumOccurs is not None:
            showIndent(outfile, level)
            outfile.write('minimumOccurs=%s,\n' % quote_python(self.minimumOccurs).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractGeneralOperationParameterType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'minimumOccurs':
            minimumOccurs_ = child_.text
            minimumOccurs_ = self.gds_validate_string(minimumOccurs_, node, 'minimumOccurs')
            self.minimumOccurs = minimumOccurs_
        super(AbstractGeneralOperationParameterType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractGeneralOperationParameterType


class AbstractGeneralOperationParameterPropertyType(GeneratedsSuper):
    """gml:AbstractGeneralOperationParameterPropertyType is a property type
    for association roles to an operation parameter or group, either
    referencing or containing the definition of that parameter or
    group."""
    subclass = None
    superclass = None
    def __init__(self, AbstractGeneralOperationParameter=None):
        self.AbstractGeneralOperationParameter = AbstractGeneralOperationParameter
    def factory(*args_, **kwargs_):
        if AbstractGeneralOperationParameterPropertyType.subclass:
            return AbstractGeneralOperationParameterPropertyType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralOperationParameterPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeneralOperationParameter(self): return self.AbstractGeneralOperationParameter
    def set_AbstractGeneralOperationParameter(self, AbstractGeneralOperationParameter): self.AbstractGeneralOperationParameter = AbstractGeneralOperationParameter
    def export(self, outfile, level, namespace_='', name_='AbstractGeneralOperationParameterPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralOperationParameterPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeneralOperationParameterPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeneralOperationParameterPropertyType', fromsubclass_=False):
        if self.AbstractGeneralOperationParameter is not None:
            self.AbstractGeneralOperationParameter.export(outfile, level, namespace_, name_='AbstractGeneralOperationParameter')
    def hasContent_(self):
        if (
            self.AbstractGeneralOperationParameter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeneralOperationParameterPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeneralOperationParameter is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeneralOperationParameter=model_.AbstractGeneralOperationParameter(\n')
            self.AbstractGeneralOperationParameter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeneralOperationParameter':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeneralOperationParameter> element')
            self.set_AbstractGeneralOperationParameter(obj_)
# end class AbstractGeneralOperationParameterPropertyType


class OperationParameterType(AbstractGeneralOperationParameterType):
    subclass = None
    superclass = AbstractGeneralOperationParameterType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, minimumOccurs=None):
        super(OperationParameterType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, minimumOccurs, )
        pass
    def factory(*args_, **kwargs_):
        if OperationParameterType.subclass:
            return OperationParameterType.subclass(*args_, **kwargs_)
        else:
            return OperationParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='OperationParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationParameterType'):
        super(OperationParameterType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OperationParameterType')
    def exportChildren(self, outfile, level, namespace_='', name_='OperationParameterType', fromsubclass_=False):
        super(OperationParameterType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(OperationParameterType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OperationParameterType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OperationParameterType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OperationParameterType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OperationParameterType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OperationParameterType


class OperationParameterPropertyType(GeneratedsSuper):
    """gml:OperationParameterPropertyType is a property type for
    association roles to an operation parameter, either referencing
    or containing the definition of that parameter."""
    subclass = None
    superclass = None
    def __init__(self, OperationParameter=None):
        self.OperationParameter = OperationParameter
    def factory(*args_, **kwargs_):
        if OperationParameterPropertyType.subclass:
            return OperationParameterPropertyType.subclass(*args_, **kwargs_)
        else:
            return OperationParameterPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OperationParameter(self): return self.OperationParameter
    def set_OperationParameter(self, OperationParameter): self.OperationParameter = OperationParameter
    def export(self, outfile, level, namespace_='', name_='OperationParameterPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationParameterPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationParameterPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OperationParameterPropertyType', fromsubclass_=False):
        if self.OperationParameter is not None:
            self.OperationParameter.export(outfile, level, namespace_, name_='OperationParameter', )
    def hasContent_(self):
        if (
            self.OperationParameter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationParameterPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OperationParameter is not None:
            showIndent(outfile, level)
            outfile.write('OperationParameter=model_.OperationParameter(\n')
            self.OperationParameter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OperationParameter':
            obj_ = OperationParameterType.factory()
            obj_.build(child_)
            self.set_OperationParameter(obj_)
# end class OperationParameterPropertyType


class OperationParameterGroupType(AbstractGeneralOperationParameterType):
    subclass = None
    superclass = AbstractGeneralOperationParameterType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, minimumOccurs=None, maximumOccurs=None, parameter=None):
        super(OperationParameterGroupType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, minimumOccurs, )
        self.maximumOccurs = maximumOccurs
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if OperationParameterGroupType.subclass:
            return OperationParameterGroupType.subclass(*args_, **kwargs_)
        else:
            return OperationParameterGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maximumOccurs(self): return self.maximumOccurs
    def set_maximumOccurs(self, maximumOccurs): self.maximumOccurs = maximumOccurs
    def get_parameter(self): return self.parameter
    def set_parameter(self, parameter): self.parameter = parameter
    def add_parameter(self, value): self.parameter.append(value)
    def insert_parameter(self, index, value): self.parameter[index] = value
    def export(self, outfile, level, namespace_='', name_='OperationParameterGroupType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationParameterGroupType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationParameterGroupType'):
        super(OperationParameterGroupType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OperationParameterGroupType')
    def exportChildren(self, outfile, level, namespace_='', name_='OperationParameterGroupType', fromsubclass_=False):
        super(OperationParameterGroupType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.maximumOccurs is not None:
            showIndent(outfile, level)
            outfile.write('<%smaximumOccurs>%s</%smaximumOccurs>\n' % (namespace_, self.gds_format_string(quote_xml(self.maximumOccurs).encode(ExternalEncoding), input_name='maximumOccurs'), namespace_))
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_, name_='parameter')
    def hasContent_(self):
        if (
            self.maximumOccurs is not None or
            self.parameter or
            super(OperationParameterGroupType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationParameterGroupType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OperationParameterGroupType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OperationParameterGroupType, self).exportLiteralChildren(outfile, level, name_)
        if self.maximumOccurs is not None:
            showIndent(outfile, level)
            outfile.write('maximumOccurs=%s,\n' % quote_python(self.maximumOccurs).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('model_.parameter(\n')
            parameter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OperationParameterGroupType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'maximumOccurs':
            maximumOccurs_ = child_.text
            maximumOccurs_ = self.gds_validate_string(maximumOccurs_, node, 'maximumOccurs')
            self.maximumOccurs = maximumOccurs_
        elif nodeName_ == 'parameter':
            obj_ = AbstractGeneralOperationParameterPropertyType.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
        super(OperationParameterGroupType, self).buildChildren(child_, node, nodeName_, True)
# end class OperationParameterGroupType


class OperationParameterGroupPropertyType(GeneratedsSuper):
    """gml:OperationParameterPropertyType is a property type for
    association roles to an operation parameter group, either
    referencing or containing the definition of that parameter
    group."""
    subclass = None
    superclass = None
    def __init__(self, OperationParameterGroup=None):
        self.OperationParameterGroup = OperationParameterGroup
    def factory(*args_, **kwargs_):
        if OperationParameterGroupPropertyType.subclass:
            return OperationParameterGroupPropertyType.subclass(*args_, **kwargs_)
        else:
            return OperationParameterGroupPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OperationParameterGroup(self): return self.OperationParameterGroup
    def set_OperationParameterGroup(self, OperationParameterGroup): self.OperationParameterGroup = OperationParameterGroup
    def export(self, outfile, level, namespace_='', name_='OperationParameterGroupPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationParameterGroupPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationParameterGroupPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OperationParameterGroupPropertyType', fromsubclass_=False):
        if self.OperationParameterGroup is not None:
            self.OperationParameterGroup.export(outfile, level, namespace_, name_='OperationParameterGroup', )
    def hasContent_(self):
        if (
            self.OperationParameterGroup is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationParameterGroupPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OperationParameterGroup is not None:
            showIndent(outfile, level)
            outfile.write('OperationParameterGroup=model_.OperationParameterGroup(\n')
            self.OperationParameterGroup.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OperationParameterGroup':
            obj_ = OperationParameterGroupType.factory()
            obj_.build(child_)
            self.set_OperationParameterGroup(obj_)
# end class OperationParameterGroupPropertyType


class ObservationType(AbstractFeatureType):
    subclass = None
    superclass = AbstractFeatureType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, validTime=None, using=None, target=None, resultOf=None, extensiontype_=None):
        super(ObservationType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, extensiontype_, )
        self.validTime = validTime
        self.using = using
        self.target = target
        self.resultOf = resultOf
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObservationType.subclass:
            return ObservationType.subclass(*args_, **kwargs_)
        else:
            return ObservationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validTime(self): return self.validTime
    def set_validTime(self, validTime): self.validTime = validTime
    def get_using(self): return self.using
    def set_using(self, using): self.using = using
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_resultOf(self): return self.resultOf
    def set_resultOf(self, resultOf): self.resultOf = resultOf
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ObservationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservationType'):
        super(ObservationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ObservationType', fromsubclass_=False):
        super(ObservationType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.validTime is not None:
            self.validTime.export(outfile, level, namespace_, name_='validTime', )
        if self.using is not None:
            self.using.export(outfile, level, namespace_, name_='using')
        if self.target is not None:
            self.target.export(outfile, level, namespace_, name_='target')
        if self.resultOf is not None:
            self.resultOf.export(outfile, level, namespace_, name_='resultOf', )
    def hasContent_(self):
        if (
            self.validTime is not None or
            self.using is not None or
            self.target is not None or
            self.resultOf is not None or
            super(ObservationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObservationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ObservationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObservationType, self).exportLiteralChildren(outfile, level, name_)
        if self.validTime is not None:
            showIndent(outfile, level)
            outfile.write('validTime=model_.validTime(\n')
            self.validTime.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.using is not None:
            showIndent(outfile, level)
            outfile.write('using=model_.using(\n')
            self.using.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target=model_.target(\n')
            self.target.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resultOf is not None:
            showIndent(outfile, level)
            outfile.write('resultOf=model_.resultOf(\n')
            self.resultOf.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(ObservationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validTime':
            class_obj_ = self.get_class_obj_(child_, TimePrimitivePropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_validTime(obj_)
        elif nodeName_ == 'using':
            obj_ = ProcedurePropertyType.factory()
            obj_.build(child_)
            self.set_using(obj_)
        elif nodeName_ == 'target':
            obj_ = TargetPropertyType.factory()
            obj_.build(child_)
            self.set_target(obj_)
        elif nodeName_ == 'resultOf':
            obj_ = ResultType.factory()
            obj_.build(child_)
            self.set_resultOf(obj_)
        super(ObservationType, self).buildChildren(child_, node, nodeName_, True)
# end class ObservationType


class ProcedurePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractFeature=None):
        self.owns = _cast(None, owns)
        self.AbstractFeature = AbstractFeature
    def factory(*args_, **kwargs_):
        if ProcedurePropertyType.subclass:
            return ProcedurePropertyType.subclass(*args_, **kwargs_)
        else:
            return ProcedurePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractFeature(self): return self.AbstractFeature
    def set_AbstractFeature(self, AbstractFeature): self.AbstractFeature = AbstractFeature
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='ProcedurePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcedurePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProcedurePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProcedurePropertyType', fromsubclass_=False):
        if self.AbstractFeature is not None:
            self.AbstractFeature.export(outfile, level, namespace_, name_='AbstractFeature')
    def hasContent_(self):
        if (
            self.AbstractFeature is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProcedurePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractFeature is not None:
            showIndent(outfile, level)
            outfile.write('AbstractFeature=model_.AbstractFeature(\n')
            self.AbstractFeature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractFeature':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractFeature> element')
            self.set_AbstractFeature(obj_)
# end class ProcedurePropertyType


class TargetPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractFeature=None, AbstractGeometry=None):
        self.owns = _cast(None, owns)
        self.AbstractFeature = AbstractFeature
        self.AbstractGeometry = AbstractGeometry
    def factory(*args_, **kwargs_):
        if TargetPropertyType.subclass:
            return TargetPropertyType.subclass(*args_, **kwargs_)
        else:
            return TargetPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractFeature(self): return self.AbstractFeature
    def set_AbstractFeature(self, AbstractFeature): self.AbstractFeature = AbstractFeature
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TargetPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TargetPropertyType', fromsubclass_=False):
        if self.AbstractFeature is not None:
            self.AbstractFeature.export(outfile, level, namespace_, name_='AbstractFeature')
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
    def hasContent_(self):
        if (
            self.AbstractFeature is not None or
            self.AbstractGeometry is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TargetPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractFeature is not None:
            showIndent(outfile, level)
            outfile.write('AbstractFeature=model_.AbstractFeature(\n')
            self.AbstractFeature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractFeature':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractFeature> element')
            self.set_AbstractFeature(obj_)
        elif nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
# end class TargetPropertyType


class ResultType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', anytypeobjs_=None):
        self.owns = _cast(None, owns)
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ResultType.subclass:
            return ResultType.subclass(*args_, **kwargs_)
        else:
            return ResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='ResultType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResultType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResultType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResultType', fromsubclass_=False):
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResultType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'ResultType')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class ResultType


class DirectedObservationType(ObservationType):
    subclass = None
    superclass = ObservationType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, validTime=None, using=None, target=None, resultOf=None, direction=None, extensiontype_=None):
        super(DirectedObservationType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, validTime, using, target, resultOf, extensiontype_, )
        self.direction = direction
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DirectedObservationType.subclass:
            return DirectedObservationType.subclass(*args_, **kwargs_)
        else:
            return DirectedObservationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DirectedObservationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedObservationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectedObservationType'):
        super(DirectedObservationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedObservationType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DirectedObservationType', fromsubclass_=False):
        super(DirectedObservationType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.direction is not None:
            self.direction.export(outfile, level, namespace_, name_='direction', )
    def hasContent_(self):
        if (
            self.direction is not None or
            super(DirectedObservationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectedObservationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DirectedObservationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DirectedObservationType, self).exportLiteralChildren(outfile, level, name_)
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=model_.direction(\n')
            self.direction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(DirectedObservationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'direction':
            obj_ = DirectionPropertyType.factory()
            obj_.build(child_)
            self.set_direction(obj_)
        super(DirectedObservationType, self).buildChildren(child_, node, nodeName_, True)
# end class DirectedObservationType


class DirectedObservationAtDistanceType(DirectedObservationType):
    subclass = None
    superclass = DirectedObservationType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, validTime=None, using=None, target=None, resultOf=None, direction=None, distance=None):
        super(DirectedObservationAtDistanceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, validTime, using, target, resultOf, direction, )
        self.distance = distance
    def factory(*args_, **kwargs_):
        if DirectedObservationAtDistanceType.subclass:
            return DirectedObservationAtDistanceType.subclass(*args_, **kwargs_)
        else:
            return DirectedObservationAtDistanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distance(self): return self.distance
    def set_distance(self, distance): self.distance = distance
    def export(self, outfile, level, namespace_='', name_='DirectedObservationAtDistanceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedObservationAtDistanceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectedObservationAtDistanceType'):
        super(DirectedObservationAtDistanceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectedObservationAtDistanceType')
    def exportChildren(self, outfile, level, namespace_='', name_='DirectedObservationAtDistanceType', fromsubclass_=False):
        super(DirectedObservationAtDistanceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.distance is not None:
            self.distance.export(outfile, level, namespace_, name_='distance', )
    def hasContent_(self):
        if (
            self.distance is not None or
            super(DirectedObservationAtDistanceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectedObservationAtDistanceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DirectedObservationAtDistanceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DirectedObservationAtDistanceType, self).exportLiteralChildren(outfile, level, name_)
        if self.distance is not None:
            showIndent(outfile, level)
            outfile.write('distance=model_.MeasureType(\n')
            self.distance.exportLiteral(outfile, level, name_='distance')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DirectedObservationAtDistanceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'distance':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_distance(obj_)
        super(DirectedObservationAtDistanceType, self).buildChildren(child_, node, nodeName_, True)
# end class DirectedObservationAtDistanceType


class DirectionPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', DirectionVector=None, DirectionDescription=None, CompassPoint=None, DirectionKeyword=None, DirectionString=None):
        self.owns = _cast(None, owns)
        self.DirectionVector = DirectionVector
        self.DirectionDescription = DirectionDescription
        self.CompassPoint = CompassPoint
        self.DirectionKeyword = DirectionKeyword
        self.DirectionString = DirectionString
    def factory(*args_, **kwargs_):
        if DirectionPropertyType.subclass:
            return DirectionPropertyType.subclass(*args_, **kwargs_)
        else:
            return DirectionPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DirectionVector(self): return self.DirectionVector
    def set_DirectionVector(self, DirectionVector): self.DirectionVector = DirectionVector
    def get_DirectionDescription(self): return self.DirectionDescription
    def set_DirectionDescription(self, DirectionDescription): self.DirectionDescription = DirectionDescription
    def get_CompassPoint(self): return self.CompassPoint
    def set_CompassPoint(self, CompassPoint): self.CompassPoint = CompassPoint
    def validate_CompassPointEnumeration(self, value):
        # Validate type CompassPointEnumeration, a restriction on string.
        pass
    def get_DirectionKeyword(self): return self.DirectionKeyword
    def set_DirectionKeyword(self, DirectionKeyword): self.DirectionKeyword = DirectionKeyword
    def get_DirectionString(self): return self.DirectionString
    def set_DirectionString(self, DirectionString): self.DirectionString = DirectionString
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='DirectionPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectionPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DirectionPropertyType', fromsubclass_=False):
        if self.DirectionVector is not None:
            self.DirectionVector.export(outfile, level, namespace_, name_='DirectionVector')
        if self.DirectionDescription is not None:
            self.DirectionDescription.export(outfile, level, namespace_, name_='DirectionDescription')
        if self.CompassPoint is not None:
            self.CompassPoint.export(outfile, level, namespace_, name_='CompassPoint')
        if self.DirectionKeyword is not None:
            self.DirectionKeyword.export(outfile, level, namespace_, name_='DirectionKeyword')
        if self.DirectionString is not None:
            self.DirectionString.export(outfile, level, namespace_, name_='DirectionString')
    def hasContent_(self):
        if (
            self.DirectionVector is not None or
            self.DirectionDescription is not None or
            self.CompassPoint is not None or
            self.DirectionKeyword is not None or
            self.DirectionString is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectionPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DirectionVector is not None:
            showIndent(outfile, level)
            outfile.write('DirectionVector=model_.DirectionVectorType(\n')
            self.DirectionVector.exportLiteral(outfile, level, name_='DirectionVector')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DirectionDescription is not None:
            showIndent(outfile, level)
            outfile.write('DirectionDescription=model_.DirectionDescriptionType(\n')
            self.DirectionDescription.exportLiteral(outfile, level, name_='DirectionDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompassPoint is not None:
            showIndent(outfile, level)
            outfile.write('CompassPoint=model_.string(\n')
            self.CompassPoint.exportLiteral(outfile, level, name_='CompassPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DirectionKeyword is not None:
            showIndent(outfile, level)
            outfile.write('DirectionKeyword=model_.CodeType(\n')
            self.DirectionKeyword.exportLiteral(outfile, level, name_='DirectionKeyword')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DirectionString is not None:
            showIndent(outfile, level)
            outfile.write('DirectionString=model_.StringOrRefType(\n')
            self.DirectionString.exportLiteral(outfile, level, name_='DirectionString')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DirectionVector':
            obj_ = DirectionVectorType.factory()
            obj_.build(child_)
            self.set_DirectionVector(obj_)
        elif nodeName_ == 'DirectionDescription':
            obj_ = DirectionDescriptionType.factory()
            obj_.build(child_)
            self.set_DirectionDescription(obj_)
        elif nodeName_ == 'CompassPoint':
            obj_ = None
            self.set_CompassPoint(obj_)
            self.validate_CompassPointEnumeration(self.CompassPoint)    # validate type CompassPointEnumeration
        elif nodeName_ == 'DirectionKeyword':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DirectionKeyword(obj_)
        elif nodeName_ == 'DirectionString':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_DirectionString(obj_)
# end class DirectionPropertyType


class DirectionVectorType(GeneratedsSuper):
    """Direction vectors are specified by providing components of a vector."""
    subclass = None
    superclass = None
    def __init__(self, vector=None, horizontalAngle=None, verticalAngle=None):
        self.vector = vector
        self.horizontalAngle = horizontalAngle
        self.verticalAngle = verticalAngle
    def factory(*args_, **kwargs_):
        if DirectionVectorType.subclass:
            return DirectionVectorType.subclass(*args_, **kwargs_)
        else:
            return DirectionVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vector(self): return self.vector
    def set_vector(self, vector): self.vector = vector
    def get_horizontalAngle(self): return self.horizontalAngle
    def set_horizontalAngle(self, horizontalAngle): self.horizontalAngle = horizontalAngle
    def get_verticalAngle(self): return self.verticalAngle
    def set_verticalAngle(self, verticalAngle): self.verticalAngle = verticalAngle
    def export(self, outfile, level, namespace_='', name_='DirectionVectorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionVectorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectionVectorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DirectionVectorType', fromsubclass_=False):
        if self.vector is not None:
            self.vector.export(outfile, level, namespace_, name_='vector', )
        if self.horizontalAngle is not None:
            self.horizontalAngle.export(outfile, level, namespace_, name_='horizontalAngle', )
        if self.verticalAngle is not None:
            self.verticalAngle.export(outfile, level, namespace_, name_='verticalAngle', )
    def hasContent_(self):
        if (
            self.vector is not None or
            self.horizontalAngle is not None or
            self.verticalAngle is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectionVectorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.vector is not None:
            showIndent(outfile, level)
            outfile.write('vector=model_.vector(\n')
            self.vector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.horizontalAngle is not None:
            showIndent(outfile, level)
            outfile.write('horizontalAngle=model_.AngleType(\n')
            self.horizontalAngle.exportLiteral(outfile, level, name_='horizontalAngle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.verticalAngle is not None:
            showIndent(outfile, level)
            outfile.write('verticalAngle=model_.AngleType(\n')
            self.verticalAngle.exportLiteral(outfile, level, name_='verticalAngle')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vector':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.set_vector(obj_)
        elif nodeName_ == 'horizontalAngle':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.set_horizontalAngle(obj_)
        elif nodeName_ == 'verticalAngle':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.set_verticalAngle(obj_)
# end class DirectionVectorType


class DirectionDescriptionType(GeneratedsSuper):
    """direction descriptions are specified by a compass point code, a
    keyword, a textual description or a reference to a description.
    A gml:compassPoint is specified by a simple enumeration. In
    addition, thre elements to contain text-based descriptions of
    direction are provided. If the direction is specified using a
    term from a list, gml:keyword should be used, and the list
    indicated using the value of the codeSpace attribute. if the
    direction is decribed in prose, gml:direction or gml:reference
    should be used, allowing the value to be included inline or by
    reference."""
    subclass = None
    superclass = None
    def __init__(self, compassPoint=None, keyword=None, description=None, reference=None):
        self.compassPoint = compassPoint
        self.keyword = keyword
        self.description = description
        self.reference = reference
    def factory(*args_, **kwargs_):
        if DirectionDescriptionType.subclass:
            return DirectionDescriptionType.subclass(*args_, **kwargs_)
        else:
            return DirectionDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compassPoint(self): return self.compassPoint
    def set_compassPoint(self, compassPoint): self.compassPoint = compassPoint
    def validate_CompassPointEnumeration(self, value):
        # Validate type CompassPointEnumeration, a restriction on string.
        pass
    def get_keyword(self): return self.keyword
    def set_keyword(self, keyword): self.keyword = keyword
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def export(self, outfile, level, namespace_='', name_='DirectionDescriptionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionDescriptionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectionDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DirectionDescriptionType', fromsubclass_=False):
        if self.compassPoint is not None:
            self.compassPoint.export(outfile, level, namespace_, name_='compassPoint', )
        if self.keyword is not None:
            self.keyword.export(outfile, level, namespace_, name_='keyword', )
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.reference is not None:
            self.reference.export(outfile, level, namespace_, name_='reference', )
    def hasContent_(self):
        if (
            self.compassPoint is not None or
            self.keyword is not None or
            self.description is not None or
            self.reference is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectionDescriptionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.compassPoint is not None:
            showIndent(outfile, level)
            outfile.write('compassPoint=model_.string(\n')
            self.compassPoint.exportLiteral(outfile, level, name_='compassPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keyword is not None:
            showIndent(outfile, level)
            outfile.write('keyword=model_.CodeType(\n')
            self.keyword.exportLiteral(outfile, level, name_='keyword')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.reference is not None:
            showIndent(outfile, level)
            outfile.write('reference=model_.ReferenceType(\n')
            self.reference.exportLiteral(outfile, level, name_='reference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'compassPoint':
            obj_ = None
            self.set_compassPoint(obj_)
            self.validate_CompassPointEnumeration(self.compassPoint)    # validate type CompassPointEnumeration
        elif nodeName_ == 'keyword':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_keyword(obj_)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_reference(obj_)
# end class DirectionDescriptionType


class TimeReferenceSystemType(DefinitionType):
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, extensiontype_=None):
        super(TimeReferenceSystemType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.domainOfValidity = domainOfValidity
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if TimeReferenceSystemType.subclass:
            return TimeReferenceSystemType.subclass(*args_, **kwargs_)
        else:
            return TimeReferenceSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='TimeReferenceSystemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeReferenceSystemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeReferenceSystemType'):
        super(TimeReferenceSystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeReferenceSystemType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='TimeReferenceSystemType', fromsubclass_=False):
        super(TimeReferenceSystemType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.domainOfValidity is not None:
            showIndent(outfile, level)
            outfile.write('<%sdomainOfValidity>%s</%sdomainOfValidity>\n' % (namespace_, self.gds_format_string(quote_xml(self.domainOfValidity).encode(ExternalEncoding), input_name='domainOfValidity'), namespace_))
    def hasContent_(self):
        if (
            self.domainOfValidity is not None or
            super(TimeReferenceSystemType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeReferenceSystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeReferenceSystemType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeReferenceSystemType, self).exportLiteralChildren(outfile, level, name_)
        if self.domainOfValidity is not None:
            showIndent(outfile, level)
            outfile.write('domainOfValidity=%s,\n' % quote_python(self.domainOfValidity).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(TimeReferenceSystemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOfValidity':
            domainOfValidity_ = child_.text
            domainOfValidity_ = self.gds_validate_string(domainOfValidity_, node, 'domainOfValidity')
            self.domainOfValidity = domainOfValidity_
        super(TimeReferenceSystemType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeReferenceSystemType


class TimeCoordinateSystemType(TimeReferenceSystemType):
    subclass = None
    superclass = TimeReferenceSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, originPosition=None, origin=None, interval=None):
        super(TimeCoordinateSystemType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, )
        self.originPosition = originPosition
        self.origin = origin
        self.interval = interval
    def factory(*args_, **kwargs_):
        if TimeCoordinateSystemType.subclass:
            return TimeCoordinateSystemType.subclass(*args_, **kwargs_)
        else:
            return TimeCoordinateSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originPosition(self): return self.originPosition
    def set_originPosition(self, originPosition): self.originPosition = originPosition
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def export(self, outfile, level, namespace_='', name_='TimeCoordinateSystemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCoordinateSystemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCoordinateSystemType'):
        super(TimeCoordinateSystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCoordinateSystemType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCoordinateSystemType', fromsubclass_=False):
        super(TimeCoordinateSystemType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.originPosition is not None:
            self.originPosition.export(outfile, level, namespace_, name_='originPosition', )
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', )
        if self.interval is not None:
            self.interval.export(outfile, level, namespace_, name_='interval', )
    def hasContent_(self):
        if (
            self.originPosition is not None or
            self.origin is not None or
            self.interval is not None or
            super(TimeCoordinateSystemType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCoordinateSystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeCoordinateSystemType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeCoordinateSystemType, self).exportLiteralChildren(outfile, level, name_)
        if self.originPosition is not None:
            showIndent(outfile, level)
            outfile.write('originPosition=model_.TimePositionType(\n')
            self.originPosition.exportLiteral(outfile, level, name_='originPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.TimeInstantPropertyType(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.interval is not None:
            showIndent(outfile, level)
            outfile.write('interval=model_.TimeIntervalLengthType(\n')
            self.interval.exportLiteral(outfile, level, name_='interval')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeCoordinateSystemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originPosition':
            obj_ = TimePositionType.factory()
            obj_.build(child_)
            self.set_originPosition(obj_)
        elif nodeName_ == 'origin':
            obj_ = TimeInstantPropertyType.factory()
            obj_.build(child_)
            self.set_origin(obj_)
        elif nodeName_ == 'interval':
            obj_ = TimeIntervalLengthType.factory()
            obj_.build(child_)
            self.set_interval(obj_)
        super(TimeCoordinateSystemType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeCoordinateSystemType


class TimeCalendarType(TimeReferenceSystemType):
    subclass = None
    superclass = TimeReferenceSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, referenceFrame=None):
        super(TimeCalendarType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, )
        if referenceFrame is None:
            self.referenceFrame = []
        else:
            self.referenceFrame = referenceFrame
    def factory(*args_, **kwargs_):
        if TimeCalendarType.subclass:
            return TimeCalendarType.subclass(*args_, **kwargs_)
        else:
            return TimeCalendarType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceFrame(self): return self.referenceFrame
    def set_referenceFrame(self, referenceFrame): self.referenceFrame = referenceFrame
    def add_referenceFrame(self, value): self.referenceFrame.append(value)
    def insert_referenceFrame(self, index, value): self.referenceFrame[index] = value
    def export(self, outfile, level, namespace_='', name_='TimeCalendarType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCalendarType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCalendarType'):
        super(TimeCalendarType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCalendarType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCalendarType', fromsubclass_=False):
        super(TimeCalendarType, self).exportChildren(outfile, level, namespace_, name_, True)
        for referenceFrame_ in self.referenceFrame:
            referenceFrame_.export(outfile, level, namespace_, name_='referenceFrame')
    def hasContent_(self):
        if (
            self.referenceFrame or
            super(TimeCalendarType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCalendarType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeCalendarType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeCalendarType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('referenceFrame=[\n')
        level += 1
        for referenceFrame_ in self.referenceFrame:
            showIndent(outfile, level)
            outfile.write('model_.TimeCalendarEraPropertyType(\n')
            referenceFrame_.exportLiteral(outfile, level, name_='TimeCalendarEraPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeCalendarType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceFrame':
            obj_ = TimeCalendarEraPropertyType.factory()
            obj_.build(child_)
            self.referenceFrame.append(obj_)
        super(TimeCalendarType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeCalendarType


class TimeCalendarEraType(DefinitionType):
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, referenceEvent=None, referenceDate=None, julianReference=None, epochOfUse=None):
        super(TimeCalendarEraType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        self.referenceEvent = referenceEvent
        self.referenceDate = referenceDate
        self.julianReference = julianReference
        self.epochOfUse = epochOfUse
    def factory(*args_, **kwargs_):
        if TimeCalendarEraType.subclass:
            return TimeCalendarEraType.subclass(*args_, **kwargs_)
        else:
            return TimeCalendarEraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceEvent(self): return self.referenceEvent
    def set_referenceEvent(self, referenceEvent): self.referenceEvent = referenceEvent
    def get_referenceDate(self): return self.referenceDate
    def set_referenceDate(self, referenceDate): self.referenceDate = referenceDate
    def validate_CalDate(self, value):
        # Validate type CalDate, a restriction on None.
        pass
    def get_julianReference(self): return self.julianReference
    def set_julianReference(self, julianReference): self.julianReference = julianReference
    def get_epochOfUse(self): return self.epochOfUse
    def set_epochOfUse(self, epochOfUse): self.epochOfUse = epochOfUse
    def export(self, outfile, level, namespace_='', name_='TimeCalendarEraType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCalendarEraType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCalendarEraType'):
        super(TimeCalendarEraType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCalendarEraType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCalendarEraType', fromsubclass_=False):
        super(TimeCalendarEraType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.referenceEvent is not None:
            self.referenceEvent.export(outfile, level, namespace_, name_='referenceEvent', )
        if self.referenceDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sreferenceDate>%s</%sreferenceDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.referenceDate).encode(ExternalEncoding), input_name='referenceDate'), namespace_))
        if self.julianReference is not None:
            showIndent(outfile, level)
            outfile.write('<%sjulianReference>%s</%sjulianReference>\n' % (namespace_, self.gds_format_string(quote_xml(self.julianReference).encode(ExternalEncoding), input_name='julianReference'), namespace_))
        if self.epochOfUse is not None:
            self.epochOfUse.export(outfile, level, namespace_, name_='epochOfUse', )
    def hasContent_(self):
        if (
            self.referenceEvent is not None or
            self.referenceDate is not None or
            self.julianReference is not None or
            self.epochOfUse is not None or
            super(TimeCalendarEraType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCalendarEraType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeCalendarEraType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeCalendarEraType, self).exportLiteralChildren(outfile, level, name_)
        if self.referenceEvent is not None:
            showIndent(outfile, level)
            outfile.write('referenceEvent=model_.StringOrRefType(\n')
            self.referenceEvent.exportLiteral(outfile, level, name_='referenceEvent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.referenceDate is not None:
            showIndent(outfile, level)
            outfile.write('referenceDate=%s,\n' % quote_python(self.referenceDate).encode(ExternalEncoding))
        if self.julianReference is not None:
            showIndent(outfile, level)
            outfile.write('julianReference=%s,\n' % quote_python(self.julianReference).encode(ExternalEncoding))
        if self.epochOfUse is not None:
            showIndent(outfile, level)
            outfile.write('epochOfUse=model_.TimePeriodPropertyType(\n')
            self.epochOfUse.exportLiteral(outfile, level, name_='epochOfUse')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeCalendarEraType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceEvent':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_referenceEvent(obj_)
        elif nodeName_ == 'referenceDate':
            referenceDate_ = child_.text
            referenceDate_ = self.gds_validate_string(referenceDate_, node, 'referenceDate')
            self.referenceDate = referenceDate_
            self.validate_CalDate(self.referenceDate)    # validate type CalDate
        elif nodeName_ == 'julianReference':
            julianReference_ = child_.text
            julianReference_ = self.gds_validate_string(julianReference_, node, 'julianReference')
            self.julianReference = julianReference_
        elif nodeName_ == 'epochOfUse':
            obj_ = TimePeriodPropertyType.factory()
            obj_.build(child_)
            self.set_epochOfUse(obj_)
        super(TimeCalendarEraType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeCalendarEraType


class TimeCalendarPropertyType(GeneratedsSuper):
    """gml:TimeCalendarPropertyType provides for associating a
    gml:TimeCalendar with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeCalendar=None):
        self.owns = _cast(None, owns)
        self.TimeCalendar = TimeCalendar
    def factory(*args_, **kwargs_):
        if TimeCalendarPropertyType.subclass:
            return TimeCalendarPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeCalendarPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeCalendar(self): return self.TimeCalendar
    def set_TimeCalendar(self, TimeCalendar): self.TimeCalendar = TimeCalendar
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeCalendarPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCalendarPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCalendarPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCalendarPropertyType', fromsubclass_=False):
        if self.TimeCalendar is not None:
            self.TimeCalendar.export(outfile, level, namespace_, name_='TimeCalendar', )
    def hasContent_(self):
        if (
            self.TimeCalendar is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCalendarPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeCalendar is not None:
            showIndent(outfile, level)
            outfile.write('TimeCalendar=model_.TimeCalendar(\n')
            self.TimeCalendar.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeCalendar':
            obj_ = TimeCalendarType.factory()
            obj_.build(child_)
            self.set_TimeCalendar(obj_)
# end class TimeCalendarPropertyType


class TimeCalendarEraPropertyType(GeneratedsSuper):
    """gml:TimeCalendarEraPropertyType provides for associating a
    gml:TimeCalendarEra with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeCalendarEra=None):
        self.owns = _cast(None, owns)
        self.TimeCalendarEra = TimeCalendarEra
    def factory(*args_, **kwargs_):
        if TimeCalendarEraPropertyType.subclass:
            return TimeCalendarEraPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeCalendarEraPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeCalendarEra(self): return self.TimeCalendarEra
    def set_TimeCalendarEra(self, TimeCalendarEra): self.TimeCalendarEra = TimeCalendarEra
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeCalendarEraPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCalendarEraPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCalendarEraPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCalendarEraPropertyType', fromsubclass_=False):
        if self.TimeCalendarEra is not None:
            self.TimeCalendarEra.export(outfile, level, namespace_, name_='TimeCalendarEra', )
    def hasContent_(self):
        if (
            self.TimeCalendarEra is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCalendarEraPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeCalendarEra is not None:
            showIndent(outfile, level)
            outfile.write('TimeCalendarEra=model_.TimeCalendarEra(\n')
            self.TimeCalendarEra.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeCalendarEra':
            obj_ = TimeCalendarEraType.factory()
            obj_.build(child_)
            self.set_TimeCalendarEra(obj_)
# end class TimeCalendarEraPropertyType


class TimeClockType(TimeReferenceSystemType):
    subclass = None
    superclass = TimeReferenceSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, referenceEvent=None, referenceTime=None, utcReference=None, dateBasis=None):
        super(TimeClockType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, )
        self.referenceEvent = referenceEvent
        self.referenceTime = referenceTime
        self.utcReference = utcReference
        if dateBasis is None:
            self.dateBasis = []
        else:
            self.dateBasis = dateBasis
    def factory(*args_, **kwargs_):
        if TimeClockType.subclass:
            return TimeClockType.subclass(*args_, **kwargs_)
        else:
            return TimeClockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceEvent(self): return self.referenceEvent
    def set_referenceEvent(self, referenceEvent): self.referenceEvent = referenceEvent
    def get_referenceTime(self): return self.referenceTime
    def set_referenceTime(self, referenceTime): self.referenceTime = referenceTime
    def get_utcReference(self): return self.utcReference
    def set_utcReference(self, utcReference): self.utcReference = utcReference
    def get_dateBasis(self): return self.dateBasis
    def set_dateBasis(self, dateBasis): self.dateBasis = dateBasis
    def add_dateBasis(self, value): self.dateBasis.append(value)
    def insert_dateBasis(self, index, value): self.dateBasis[index] = value
    def export(self, outfile, level, namespace_='', name_='TimeClockType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeClockType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeClockType'):
        super(TimeClockType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeClockType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeClockType', fromsubclass_=False):
        super(TimeClockType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.referenceEvent is not None:
            self.referenceEvent.export(outfile, level, namespace_, name_='referenceEvent', )
        if self.referenceTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sreferenceTime>%s</%sreferenceTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.referenceTime).encode(ExternalEncoding), input_name='referenceTime'), namespace_))
        if self.utcReference is not None:
            showIndent(outfile, level)
            outfile.write('<%sutcReference>%s</%sutcReference>\n' % (namespace_, self.gds_format_string(quote_xml(self.utcReference).encode(ExternalEncoding), input_name='utcReference'), namespace_))
        for dateBasis_ in self.dateBasis:
            dateBasis_.export(outfile, level, namespace_, name_='dateBasis')
    def hasContent_(self):
        if (
            self.referenceEvent is not None or
            self.referenceTime is not None or
            self.utcReference is not None or
            self.dateBasis or
            super(TimeClockType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeClockType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeClockType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeClockType, self).exportLiteralChildren(outfile, level, name_)
        if self.referenceEvent is not None:
            showIndent(outfile, level)
            outfile.write('referenceEvent=model_.StringOrRefType(\n')
            self.referenceEvent.exportLiteral(outfile, level, name_='referenceEvent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.referenceTime is not None:
            showIndent(outfile, level)
            outfile.write('referenceTime=%s,\n' % quote_python(self.referenceTime).encode(ExternalEncoding))
        if self.utcReference is not None:
            showIndent(outfile, level)
            outfile.write('utcReference=%s,\n' % quote_python(self.utcReference).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('dateBasis=[\n')
        level += 1
        for dateBasis_ in self.dateBasis:
            showIndent(outfile, level)
            outfile.write('model_.TimeCalendarPropertyType(\n')
            dateBasis_.exportLiteral(outfile, level, name_='TimeCalendarPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeClockType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceEvent':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_referenceEvent(obj_)
        elif nodeName_ == 'referenceTime':
            referenceTime_ = child_.text
            referenceTime_ = self.gds_validate_string(referenceTime_, node, 'referenceTime')
            self.referenceTime = referenceTime_
        elif nodeName_ == 'utcReference':
            utcReference_ = child_.text
            utcReference_ = self.gds_validate_string(utcReference_, node, 'utcReference')
            self.utcReference = utcReference_
        elif nodeName_ == 'dateBasis':
            obj_ = TimeCalendarPropertyType.factory()
            obj_.build(child_)
            self.dateBasis.append(obj_)
        super(TimeClockType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeClockType


class TimeClockPropertyType(GeneratedsSuper):
    """gml:TimeClockPropertyType provides for associating a gml:TimeClock
    with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeClock=None):
        self.owns = _cast(None, owns)
        self.TimeClock = TimeClock
    def factory(*args_, **kwargs_):
        if TimeClockPropertyType.subclass:
            return TimeClockPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeClockPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeClock(self): return self.TimeClock
    def set_TimeClock(self, TimeClock): self.TimeClock = TimeClock
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeClockPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeClockPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeClockPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeClockPropertyType', fromsubclass_=False):
        if self.TimeClock is not None:
            self.TimeClock.export(outfile, level, namespace_, name_='TimeClock', )
    def hasContent_(self):
        if (
            self.TimeClock is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeClockPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeClock is not None:
            showIndent(outfile, level)
            outfile.write('TimeClock=model_.TimeClock(\n')
            self.TimeClock.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeClock':
            obj_ = TimeClockType.factory()
            obj_.build(child_)
            self.set_TimeClock(obj_)
# end class TimeClockPropertyType


class TimeOrdinalReferenceSystemType(TimeReferenceSystemType):
    subclass = None
    superclass = TimeReferenceSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, component=None):
        super(TimeOrdinalReferenceSystemType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, )
        if component is None:
            self.component = []
        else:
            self.component = component
    def factory(*args_, **kwargs_):
        if TimeOrdinalReferenceSystemType.subclass:
            return TimeOrdinalReferenceSystemType.subclass(*args_, **kwargs_)
        else:
            return TimeOrdinalReferenceSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_component(self): return self.component
    def set_component(self, component): self.component = component
    def add_component(self, value): self.component.append(value)
    def insert_component(self, index, value): self.component[index] = value
    def export(self, outfile, level, namespace_='', name_='TimeOrdinalReferenceSystemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOrdinalReferenceSystemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeOrdinalReferenceSystemType'):
        super(TimeOrdinalReferenceSystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOrdinalReferenceSystemType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeOrdinalReferenceSystemType', fromsubclass_=False):
        super(TimeOrdinalReferenceSystemType, self).exportChildren(outfile, level, namespace_, name_, True)
        for component_ in self.component:
            component_.export(outfile, level, namespace_, name_='component')
    def hasContent_(self):
        if (
            self.component or
            super(TimeOrdinalReferenceSystemType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeOrdinalReferenceSystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeOrdinalReferenceSystemType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeOrdinalReferenceSystemType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('component=[\n')
        level += 1
        for component_ in self.component:
            showIndent(outfile, level)
            outfile.write('model_.TimeOrdinalEraPropertyType(\n')
            component_.exportLiteral(outfile, level, name_='TimeOrdinalEraPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeOrdinalReferenceSystemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'component':
            obj_ = TimeOrdinalEraPropertyType.factory()
            obj_.build(child_)
            self.component.append(obj_)
        super(TimeOrdinalReferenceSystemType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeOrdinalReferenceSystemType


class TimeOrdinalEraType(DefinitionType):
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, relatedTime=None, start=None, end=None, extent=None, member=None, group=None):
        super(TimeOrdinalEraType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        if relatedTime is None:
            self.relatedTime = []
        else:
            self.relatedTime = relatedTime
        self.start = start
        self.end = end
        self.extent = extent
        if member is None:
            self.member = []
        else:
            self.member = member
        self.group = group
    def factory(*args_, **kwargs_):
        if TimeOrdinalEraType.subclass:
            return TimeOrdinalEraType.subclass(*args_, **kwargs_)
        else:
            return TimeOrdinalEraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedTime(self): return self.relatedTime
    def set_relatedTime(self, relatedTime): self.relatedTime = relatedTime
    def add_relatedTime(self, value): self.relatedTime.append(value)
    def insert_relatedTime(self, index, value): self.relatedTime[index] = value
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def export(self, outfile, level, namespace_='', name_='TimeOrdinalEraType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOrdinalEraType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeOrdinalEraType'):
        super(TimeOrdinalEraType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOrdinalEraType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeOrdinalEraType', fromsubclass_=False):
        super(TimeOrdinalEraType, self).exportChildren(outfile, level, namespace_, name_, True)
        for relatedTime_ in self.relatedTime:
            relatedTime_.export(outfile, level, namespace_, name_='relatedTime')
        if self.start is not None:
            self.start.export(outfile, level, namespace_, name_='start')
        if self.end is not None:
            self.end.export(outfile, level, namespace_, name_='end')
        if self.extent is not None:
            self.extent.export(outfile, level, namespace_, name_='extent')
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
        if self.group is not None:
            self.group.export(outfile, level, namespace_, name_='group')
    def hasContent_(self):
        if (
            self.relatedTime or
            self.start is not None or
            self.end is not None or
            self.extent is not None or
            self.member or
            self.group is not None or
            super(TimeOrdinalEraType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeOrdinalEraType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeOrdinalEraType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeOrdinalEraType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('relatedTime=[\n')
        level += 1
        for relatedTime_ in self.relatedTime:
            showIndent(outfile, level)
            outfile.write('model_.RelatedTimeType(\n')
            relatedTime_.exportLiteral(outfile, level, name_='RelatedTimeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.start is not None:
            showIndent(outfile, level)
            outfile.write('start=model_.TimeNodePropertyType(\n')
            self.start.exportLiteral(outfile, level, name_='start')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.TimeNodePropertyType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extent is not None:
            showIndent(outfile, level)
            outfile.write('extent=model_.TimePeriodPropertyType(\n')
            self.extent.exportLiteral(outfile, level, name_='extent')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.TimeOrdinalEraPropertyType(\n')
            member_.exportLiteral(outfile, level, name_='TimeOrdinalEraPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=model_.ReferenceType(\n')
            self.group.exportLiteral(outfile, level, name_='group')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeOrdinalEraType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedTime':
            obj_ = RelatedTimeType.factory()
            obj_.build(child_)
            self.relatedTime.append(obj_)
        elif nodeName_ == 'start':
            obj_ = TimeNodePropertyType.factory()
            obj_.build(child_)
            self.set_start(obj_)
        elif nodeName_ == 'end':
            obj_ = TimeNodePropertyType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'extent':
            obj_ = TimePeriodPropertyType.factory()
            obj_.build(child_)
            self.set_extent(obj_)
        elif nodeName_ == 'member':
            obj_ = TimeOrdinalEraPropertyType.factory()
            obj_.build(child_)
            self.member.append(obj_)
        elif nodeName_ == 'group':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_group(obj_)
        super(TimeOrdinalEraType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeOrdinalEraType


class TimeOrdinalEraPropertyType(GeneratedsSuper):
    """gml:TimeOrdinalEraPropertyType provides for associating a
    gml:TimeOrdinalEra with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeOrdinalEra=None):
        self.owns = _cast(None, owns)
        self.TimeOrdinalEra = TimeOrdinalEra
    def factory(*args_, **kwargs_):
        if TimeOrdinalEraPropertyType.subclass:
            return TimeOrdinalEraPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeOrdinalEraPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeOrdinalEra(self): return self.TimeOrdinalEra
    def set_TimeOrdinalEra(self, TimeOrdinalEra): self.TimeOrdinalEra = TimeOrdinalEra
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeOrdinalEraPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOrdinalEraPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeOrdinalEraPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeOrdinalEraPropertyType', fromsubclass_=False):
        if self.TimeOrdinalEra is not None:
            self.TimeOrdinalEra.export(outfile, level, namespace_, name_='TimeOrdinalEra', )
    def hasContent_(self):
        if (
            self.TimeOrdinalEra is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeOrdinalEraPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeOrdinalEra is not None:
            showIndent(outfile, level)
            outfile.write('TimeOrdinalEra=model_.TimeOrdinalEra(\n')
            self.TimeOrdinalEra.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeOrdinalEra':
            obj_ = TimeOrdinalEraType.factory()
            obj_.build(child_)
            self.set_TimeOrdinalEra(obj_)
# end class TimeOrdinalEraPropertyType


class AbstractTimeTopologyPrimitiveType(AbstractTimePrimitiveType):
    subclass = None
    superclass = AbstractTimePrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None, complex=None, extensiontype_=None):
        super(AbstractTimeTopologyPrimitiveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, relatedTime, extensiontype_, )
        self.complex = complex
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTimeTopologyPrimitiveType.subclass:
            return AbstractTimeTopologyPrimitiveType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimeTopologyPrimitiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_complex(self): return self.complex
    def set_complex(self, complex): self.complex = complex
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTimeTopologyPrimitiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeTopologyPrimitiveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTimeTopologyPrimitiveType'):
        super(AbstractTimeTopologyPrimitiveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeTopologyPrimitiveType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTimeTopologyPrimitiveType', fromsubclass_=False):
        super(AbstractTimeTopologyPrimitiveType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.complex is not None:
            self.complex.export(outfile, level, namespace_, name_='complex')
    def hasContent_(self):
        if (
            self.complex is not None or
            super(AbstractTimeTopologyPrimitiveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTimeTopologyPrimitiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractTimeTopologyPrimitiveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTimeTopologyPrimitiveType, self).exportLiteralChildren(outfile, level, name_)
        if self.complex is not None:
            showIndent(outfile, level)
            outfile.write('complex=model_.ReferenceType(\n')
            self.complex.exportLiteral(outfile, level, name_='complex')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTimeTopologyPrimitiveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'complex':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_complex(obj_)
        super(AbstractTimeTopologyPrimitiveType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractTimeTopologyPrimitiveType


class TimeTopologyPrimitivePropertyType(GeneratedsSuper):
    """gml:TimeTopologyPrimitivePropertyType provides for associating a
    gml:AbstractTimeTopologyPrimitive with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractTimeTopologyPrimitive=None):
        self.owns = _cast(None, owns)
        self.AbstractTimeTopologyPrimitive = AbstractTimeTopologyPrimitive
    def factory(*args_, **kwargs_):
        if TimeTopologyPrimitivePropertyType.subclass:
            return TimeTopologyPrimitivePropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeTopologyPrimitivePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractTimeTopologyPrimitive(self): return self.AbstractTimeTopologyPrimitive
    def set_AbstractTimeTopologyPrimitive(self, AbstractTimeTopologyPrimitive): self.AbstractTimeTopologyPrimitive = AbstractTimeTopologyPrimitive
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeTopologyPrimitivePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTopologyPrimitivePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeTopologyPrimitivePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeTopologyPrimitivePropertyType', fromsubclass_=False):
        if self.AbstractTimeTopologyPrimitive is not None:
            self.AbstractTimeTopologyPrimitive.export(outfile, level, namespace_, name_='AbstractTimeTopologyPrimitive')
    def hasContent_(self):
        if (
            self.AbstractTimeTopologyPrimitive is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeTopologyPrimitivePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractTimeTopologyPrimitive is not None:
            showIndent(outfile, level)
            outfile.write('AbstractTimeTopologyPrimitive=model_.AbstractTimeTopologyPrimitive(\n')
            self.AbstractTimeTopologyPrimitive.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractTimeTopologyPrimitive':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractTimeTopologyPrimitive> element')
            self.set_AbstractTimeTopologyPrimitive(obj_)
# end class TimeTopologyPrimitivePropertyType


class TimeTopologyComplexType(AbstractTimeComplexType):
    subclass = None
    superclass = AbstractTimeComplexType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, primitive=None):
        super(TimeTopologyComplexType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        if primitive is None:
            self.primitive = []
        else:
            self.primitive = primitive
    def factory(*args_, **kwargs_):
        if TimeTopologyComplexType.subclass:
            return TimeTopologyComplexType.subclass(*args_, **kwargs_)
        else:
            return TimeTopologyComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primitive(self): return self.primitive
    def set_primitive(self, primitive): self.primitive = primitive
    def add_primitive(self, value): self.primitive.append(value)
    def insert_primitive(self, index, value): self.primitive[index] = value
    def export(self, outfile, level, namespace_='', name_='TimeTopologyComplexType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTopologyComplexType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeTopologyComplexType'):
        super(TimeTopologyComplexType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTopologyComplexType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeTopologyComplexType', fromsubclass_=False):
        super(TimeTopologyComplexType, self).exportChildren(outfile, level, namespace_, name_, True)
        for primitive_ in self.primitive:
            primitive_.export(outfile, level, namespace_, name_='primitive')
    def hasContent_(self):
        if (
            self.primitive or
            super(TimeTopologyComplexType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeTopologyComplexType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeTopologyComplexType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeTopologyComplexType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('primitive=[\n')
        level += 1
        for primitive_ in self.primitive:
            showIndent(outfile, level)
            outfile.write('model_.TimeTopologyPrimitivePropertyType(\n')
            primitive_.exportLiteral(outfile, level, name_='TimeTopologyPrimitivePropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeTopologyComplexType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primitive':
            obj_ = TimeTopologyPrimitivePropertyType.factory()
            obj_.build(child_)
            self.primitive.append(obj_)
        super(TimeTopologyComplexType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeTopologyComplexType


class TimeTopologyComplexPropertyType(GeneratedsSuper):
    """gml:TimeTopologyComplexPropertyType provides for associating a
    gml:TimeTopologyComplex with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeTopologyComplex=None):
        self.owns = _cast(None, owns)
        self.TimeTopologyComplex = TimeTopologyComplex
    def factory(*args_, **kwargs_):
        if TimeTopologyComplexPropertyType.subclass:
            return TimeTopologyComplexPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeTopologyComplexPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeTopologyComplex(self): return self.TimeTopologyComplex
    def set_TimeTopologyComplex(self, TimeTopologyComplex): self.TimeTopologyComplex = TimeTopologyComplex
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeTopologyComplexPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTopologyComplexPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeTopologyComplexPropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeTopologyComplexPropertyType', fromsubclass_=False):
        if self.TimeTopologyComplex is not None:
            self.TimeTopologyComplex.export(outfile, level, namespace_, name_='TimeTopologyComplex', )
    def hasContent_(self):
        if (
            self.TimeTopologyComplex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeTopologyComplexPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeTopologyComplex is not None:
            showIndent(outfile, level)
            outfile.write('TimeTopologyComplex=model_.TimeTopologyComplex(\n')
            self.TimeTopologyComplex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeTopologyComplex':
            obj_ = TimeTopologyComplexType.factory()
            obj_.build(child_)
            self.set_TimeTopologyComplex(obj_)
# end class TimeTopologyComplexPropertyType


class TimeNodeType(AbstractTimeTopologyPrimitiveType):
    subclass = None
    superclass = AbstractTimeTopologyPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None, complex=None, previousEdge=None, nextEdge=None, position=None):
        super(TimeNodeType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, relatedTime, complex, )
        if previousEdge is None:
            self.previousEdge = []
        else:
            self.previousEdge = previousEdge
        if nextEdge is None:
            self.nextEdge = []
        else:
            self.nextEdge = nextEdge
        self.position = position
    def factory(*args_, **kwargs_):
        if TimeNodeType.subclass:
            return TimeNodeType.subclass(*args_, **kwargs_)
        else:
            return TimeNodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_previousEdge(self): return self.previousEdge
    def set_previousEdge(self, previousEdge): self.previousEdge = previousEdge
    def add_previousEdge(self, value): self.previousEdge.append(value)
    def insert_previousEdge(self, index, value): self.previousEdge[index] = value
    def get_nextEdge(self): return self.nextEdge
    def set_nextEdge(self, nextEdge): self.nextEdge = nextEdge
    def add_nextEdge(self, value): self.nextEdge.append(value)
    def insert_nextEdge(self, index, value): self.nextEdge[index] = value
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def export(self, outfile, level, namespace_='', name_='TimeNodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeNodeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeNodeType'):
        super(TimeNodeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeNodeType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeNodeType', fromsubclass_=False):
        super(TimeNodeType, self).exportChildren(outfile, level, namespace_, name_, True)
        for previousEdge_ in self.previousEdge:
            previousEdge_.export(outfile, level, namespace_, name_='previousEdge')
        for nextEdge_ in self.nextEdge:
            nextEdge_.export(outfile, level, namespace_, name_='nextEdge')
        if self.position is not None:
            self.position.export(outfile, level, namespace_, name_='position')
    def hasContent_(self):
        if (
            self.previousEdge or
            self.nextEdge or
            self.position is not None or
            super(TimeNodeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeNodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeNodeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeNodeType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('previousEdge=[\n')
        level += 1
        for previousEdge_ in self.previousEdge:
            showIndent(outfile, level)
            outfile.write('model_.TimeEdgePropertyType(\n')
            previousEdge_.exportLiteral(outfile, level, name_='TimeEdgePropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('nextEdge=[\n')
        level += 1
        for nextEdge_ in self.nextEdge:
            showIndent(outfile, level)
            outfile.write('model_.TimeEdgePropertyType(\n')
            nextEdge_.exportLiteral(outfile, level, name_='TimeEdgePropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.position is not None:
            showIndent(outfile, level)
            outfile.write('position=model_.TimeInstantPropertyType(\n')
            self.position.exportLiteral(outfile, level, name_='position')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeNodeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'previousEdge':
            obj_ = TimeEdgePropertyType.factory()
            obj_.build(child_)
            self.previousEdge.append(obj_)
        elif nodeName_ == 'nextEdge':
            obj_ = TimeEdgePropertyType.factory()
            obj_.build(child_)
            self.nextEdge.append(obj_)
        elif nodeName_ == 'position':
            obj_ = TimeInstantPropertyType.factory()
            obj_.build(child_)
            self.set_position(obj_)
        super(TimeNodeType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeNodeType


class TimeNodePropertyType(GeneratedsSuper):
    """gml:TimeNodePropertyType provides for associating a gml:TimeNode
    with an object"""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeNode=None):
        self.owns = _cast(None, owns)
        self.TimeNode = TimeNode
    def factory(*args_, **kwargs_):
        if TimeNodePropertyType.subclass:
            return TimeNodePropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeNodePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeNode(self): return self.TimeNode
    def set_TimeNode(self, TimeNode): self.TimeNode = TimeNode
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeNodePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeNodePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeNodePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeNodePropertyType', fromsubclass_=False):
        if self.TimeNode is not None:
            self.TimeNode.export(outfile, level, namespace_, name_='TimeNode', )
    def hasContent_(self):
        if (
            self.TimeNode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeNodePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeNode is not None:
            showIndent(outfile, level)
            outfile.write('TimeNode=model_.TimeNode(\n')
            self.TimeNode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeNode':
            obj_ = TimeNodeType.factory()
            obj_.build(child_)
            self.set_TimeNode(obj_)
# end class TimeNodePropertyType


class TimeEdgeType(AbstractTimeTopologyPrimitiveType):
    subclass = None
    superclass = AbstractTimeTopologyPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, relatedTime=None, complex=None, start=None, end=None, extent=None):
        super(TimeEdgeType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, relatedTime, complex, )
        self.start = start
        self.end = end
        self.extent = extent
    def factory(*args_, **kwargs_):
        if TimeEdgeType.subclass:
            return TimeEdgeType.subclass(*args_, **kwargs_)
        else:
            return TimeEdgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    def export(self, outfile, level, namespace_='', name_='TimeEdgeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeEdgeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeEdgeType'):
        super(TimeEdgeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeEdgeType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeEdgeType', fromsubclass_=False):
        super(TimeEdgeType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.start is not None:
            self.start.export(outfile, level, namespace_, name_='start', )
        if self.end is not None:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.extent is not None:
            self.extent.export(outfile, level, namespace_, name_='extent')
    def hasContent_(self):
        if (
            self.start is not None or
            self.end is not None or
            self.extent is not None or
            super(TimeEdgeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeEdgeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeEdgeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeEdgeType, self).exportLiteralChildren(outfile, level, name_)
        if self.start is not None:
            showIndent(outfile, level)
            outfile.write('start=model_.TimeNodePropertyType(\n')
            self.start.exportLiteral(outfile, level, name_='start')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.TimeNodePropertyType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extent is not None:
            showIndent(outfile, level)
            outfile.write('extent=model_.TimePeriodPropertyType(\n')
            self.extent.exportLiteral(outfile, level, name_='extent')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeEdgeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'start':
            obj_ = TimeNodePropertyType.factory()
            obj_.build(child_)
            self.set_start(obj_)
        elif nodeName_ == 'end':
            obj_ = TimeNodePropertyType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'extent':
            obj_ = TimePeriodPropertyType.factory()
            obj_.build(child_)
            self.set_extent(obj_)
        super(TimeEdgeType, self).buildChildren(child_, node, nodeName_, True)
# end class TimeEdgeType


class TimeEdgePropertyType(GeneratedsSuper):
    """gml:TimeEdgePropertyType provides for associating a gml:TimeEdge
    with an object."""
    subclass = None
    superclass = None
    def __init__(self, owns='false', TimeEdge=None):
        self.owns = _cast(None, owns)
        self.TimeEdge = TimeEdge
    def factory(*args_, **kwargs_):
        if TimeEdgePropertyType.subclass:
            return TimeEdgePropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeEdgePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeEdge(self): return self.TimeEdge
    def set_TimeEdge(self, TimeEdge): self.TimeEdge = TimeEdge
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='TimeEdgePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeEdgePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeEdgePropertyType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeEdgePropertyType', fromsubclass_=False):
        if self.TimeEdge is not None:
            self.TimeEdge.export(outfile, level, namespace_, name_='TimeEdge', )
    def hasContent_(self):
        if (
            self.TimeEdge is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeEdgePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeEdge is not None:
            showIndent(outfile, level)
            outfile.write('TimeEdge=model_.TimeEdge(\n')
            self.TimeEdge.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeEdge':
            obj_ = TimeEdgeType.factory()
            obj_.build(child_)
            self.set_TimeEdge(obj_)
# end class TimeEdgePropertyType


class OperationPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbstractOperation=None):
        self.AbstractOperation = AbstractOperation
    def factory(*args_, **kwargs_):
        if OperationPropertyType.subclass:
            return OperationPropertyType.subclass(*args_, **kwargs_)
        else:
            return OperationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractOperation(self): return self.AbstractOperation
    def set_AbstractOperation(self, AbstractOperation): self.AbstractOperation = AbstractOperation
    def export(self, outfile, level, namespace_='', name_='OperationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OperationPropertyType', fromsubclass_=False):
        if self.AbstractOperation is not None:
            self.AbstractOperation.export(outfile, level, namespace_, name_='AbstractOperation')
    def hasContent_(self):
        if (
            self.AbstractOperation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractOperation is not None:
            showIndent(outfile, level)
            outfile.write('AbstractOperation=model_.AbstractOperation(\n')
            self.AbstractOperation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractOperation':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractOperation> element')
            self.set_AbstractOperation(obj_)
# end class OperationPropertyType


class TemporalCSPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TemporalCS=None):
        self.TemporalCS = TemporalCS
    def factory(*args_, **kwargs_):
        if TemporalCSPropertyType.subclass:
            return TemporalCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return TemporalCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TemporalCS(self): return self.TemporalCS
    def set_TemporalCS(self, TemporalCS): self.TemporalCS = TemporalCS
    def export(self, outfile, level, namespace_='', name_='TemporalCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TemporalCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TemporalCSPropertyType', fromsubclass_=False):
        if self.TemporalCS is not None:
            self.TemporalCS.export(outfile, level, namespace_, name_='TemporalCS', )
    def hasContent_(self):
        if (
            self.TemporalCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TemporalCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TemporalCS is not None:
            showIndent(outfile, level)
            outfile.write('TemporalCS=model_.TemporalCS(\n')
            self.TemporalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TemporalCS':
            obj_ = TemporalCSType.factory()
            obj_.build(child_)
            self.set_TemporalCS(obj_)
# end class TemporalCSPropertyType


class ObliqueCartesianCSPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ObliqueCartesianCS=None):
        self.ObliqueCartesianCS = ObliqueCartesianCS
    def factory(*args_, **kwargs_):
        if ObliqueCartesianCSPropertyType.subclass:
            return ObliqueCartesianCSPropertyType.subclass(*args_, **kwargs_)
        else:
            return ObliqueCartesianCSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObliqueCartesianCS(self): return self.ObliqueCartesianCS
    def set_ObliqueCartesianCS(self, ObliqueCartesianCS): self.ObliqueCartesianCS = ObliqueCartesianCS
    def export(self, outfile, level, namespace_='', name_='ObliqueCartesianCSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObliqueCartesianCSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObliqueCartesianCSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObliqueCartesianCSPropertyType', fromsubclass_=False):
        if self.ObliqueCartesianCS is not None:
            self.ObliqueCartesianCS.export(outfile, level, namespace_, name_='ObliqueCartesianCS', )
    def hasContent_(self):
        if (
            self.ObliqueCartesianCS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObliqueCartesianCSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ObliqueCartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('ObliqueCartesianCS=model_.ObliqueCartesianCS(\n')
            self.ObliqueCartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObliqueCartesianCS':
            obj_ = ObliqueCartesianCSType.factory()
            obj_.build(child_)
            self.set_ObliqueCartesianCS(obj_)
# end class ObliqueCartesianCSPropertyType


class GeographicCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, usesEllipsoidalCS=None, usesGeodeticDatum=None):
        super(GeographicCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.usesEllipsoidalCS = usesEllipsoidalCS
        self.usesGeodeticDatum = usesGeodeticDatum
    def factory(*args_, **kwargs_):
        if GeographicCRSType.subclass:
            return GeographicCRSType.subclass(*args_, **kwargs_)
        else:
            return GeographicCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usesEllipsoidalCS(self): return self.usesEllipsoidalCS
    def set_usesEllipsoidalCS(self, usesEllipsoidalCS): self.usesEllipsoidalCS = usesEllipsoidalCS
    def get_usesGeodeticDatum(self): return self.usesGeodeticDatum
    def set_usesGeodeticDatum(self, usesGeodeticDatum): self.usesGeodeticDatum = usesGeodeticDatum
    def export(self, outfile, level, namespace_='', name_='GeographicCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeographicCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeographicCRSType'):
        super(GeographicCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeographicCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='GeographicCRSType', fromsubclass_=False):
        super(GeographicCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.usesEllipsoidalCS is not None:
            self.usesEllipsoidalCS.export(outfile, level, namespace_, name_='usesEllipsoidalCS', )
        if self.usesGeodeticDatum is not None:
            self.usesGeodeticDatum.export(outfile, level, namespace_, name_='usesGeodeticDatum', )
    def hasContent_(self):
        if (
            self.usesEllipsoidalCS is not None or
            self.usesGeodeticDatum is not None or
            super(GeographicCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeographicCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeographicCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GeographicCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.usesEllipsoidalCS is not None:
            showIndent(outfile, level)
            outfile.write('usesEllipsoidalCS=model_.usesEllipsoidalCS(\n')
            self.usesEllipsoidalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usesGeodeticDatum is not None:
            showIndent(outfile, level)
            outfile.write('usesGeodeticDatum=model_.usesGeodeticDatum(\n')
            self.usesGeodeticDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GeographicCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'usesEllipsoidalCS':
            obj_ = EllipsoidalCSPropertyType.factory()
            obj_.build(child_)
            self.set_usesEllipsoidalCS(obj_)
        elif nodeName_ == 'usesGeodeticDatum':
            obj_ = GeodeticDatumPropertyType.factory()
            obj_.build(child_)
            self.set_usesGeodeticDatum(obj_)
        super(GeographicCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class GeographicCRSType


class GeographicCRSPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GeographicCRS=None):
        self.GeographicCRS = GeographicCRS
    def factory(*args_, **kwargs_):
        if GeographicCRSPropertyType.subclass:
            return GeographicCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeographicCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeographicCRS(self): return self.GeographicCRS
    def set_GeographicCRS(self, GeographicCRS): self.GeographicCRS = GeographicCRS
    def export(self, outfile, level, namespace_='', name_='GeographicCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeographicCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeographicCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeographicCRSPropertyType', fromsubclass_=False):
        if self.GeographicCRS is not None:
            self.GeographicCRS.export(outfile, level, namespace_, name_='GeographicCRS', )
    def hasContent_(self):
        if (
            self.GeographicCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeographicCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GeographicCRS is not None:
            showIndent(outfile, level)
            outfile.write('GeographicCRS=model_.GeographicCRS(\n')
            self.GeographicCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeographicCRS':
            obj_ = GeographicCRSType.factory()
            obj_.build(child_)
            self.set_GeographicCRS(obj_)
# end class GeographicCRSPropertyType


class GeocentricCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, usesCartesianCS=None, usesSphericalCS=None, usesGeodeticDatum=None):
        super(GeocentricCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.usesCartesianCS = usesCartesianCS
        self.usesSphericalCS = usesSphericalCS
        self.usesGeodeticDatum = usesGeodeticDatum
    def factory(*args_, **kwargs_):
        if GeocentricCRSType.subclass:
            return GeocentricCRSType.subclass(*args_, **kwargs_)
        else:
            return GeocentricCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usesCartesianCS(self): return self.usesCartesianCS
    def set_usesCartesianCS(self, usesCartesianCS): self.usesCartesianCS = usesCartesianCS
    def get_usesSphericalCS(self): return self.usesSphericalCS
    def set_usesSphericalCS(self, usesSphericalCS): self.usesSphericalCS = usesSphericalCS
    def get_usesGeodeticDatum(self): return self.usesGeodeticDatum
    def set_usesGeodeticDatum(self, usesGeodeticDatum): self.usesGeodeticDatum = usesGeodeticDatum
    def export(self, outfile, level, namespace_='', name_='GeocentricCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeocentricCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeocentricCRSType'):
        super(GeocentricCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeocentricCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='GeocentricCRSType', fromsubclass_=False):
        super(GeocentricCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.usesCartesianCS is not None:
            self.usesCartesianCS.export(outfile, level, namespace_, name_='usesCartesianCS', )
        if self.usesSphericalCS is not None:
            self.usesSphericalCS.export(outfile, level, namespace_, name_='usesSphericalCS', )
        if self.usesGeodeticDatum is not None:
            self.usesGeodeticDatum.export(outfile, level, namespace_, name_='usesGeodeticDatum', )
    def hasContent_(self):
        if (
            self.usesCartesianCS is not None or
            self.usesSphericalCS is not None or
            self.usesGeodeticDatum is not None or
            super(GeocentricCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeocentricCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeocentricCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GeocentricCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.usesCartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('usesCartesianCS=model_.usesCartesianCS(\n')
            self.usesCartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usesSphericalCS is not None:
            showIndent(outfile, level)
            outfile.write('usesSphericalCS=model_.usesSphericalCS(\n')
            self.usesSphericalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usesGeodeticDatum is not None:
            showIndent(outfile, level)
            outfile.write('usesGeodeticDatum=model_.usesGeodeticDatum(\n')
            self.usesGeodeticDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GeocentricCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'usesCartesianCS':
            obj_ = CartesianCSPropertyType.factory()
            obj_.build(child_)
            self.set_usesCartesianCS(obj_)
        elif nodeName_ == 'usesSphericalCS':
            obj_ = SphericalCSPropertyType.factory()
            obj_.build(child_)
            self.set_usesSphericalCS(obj_)
        elif nodeName_ == 'usesGeodeticDatum':
            obj_ = GeodeticDatumPropertyType.factory()
            obj_.build(child_)
            self.set_usesGeodeticDatum(obj_)
        super(GeocentricCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class GeocentricCRSType


class GeocentricCRSPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GeocentricCRS=None):
        self.GeocentricCRS = GeocentricCRS
    def factory(*args_, **kwargs_):
        if GeocentricCRSPropertyType.subclass:
            return GeocentricCRSPropertyType.subclass(*args_, **kwargs_)
        else:
            return GeocentricCRSPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeocentricCRS(self): return self.GeocentricCRS
    def set_GeocentricCRS(self, GeocentricCRS): self.GeocentricCRS = GeocentricCRS
    def export(self, outfile, level, namespace_='', name_='GeocentricCRSPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeocentricCRSPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeocentricCRSPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeocentricCRSPropertyType', fromsubclass_=False):
        if self.GeocentricCRS is not None:
            self.GeocentricCRS.export(outfile, level, namespace_, name_='GeocentricCRS', )
    def hasContent_(self):
        if (
            self.GeocentricCRS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeocentricCRSPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GeocentricCRS is not None:
            showIndent(outfile, level)
            outfile.write('GeocentricCRS=model_.GeocentricCRS(\n')
            self.GeocentricCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeocentricCRS':
            obj_ = GeocentricCRSType.factory()
            obj_.build(child_)
            self.set_GeocentricCRS(obj_)
# end class GeocentricCRSPropertyType


class DMSAngleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, degrees=None, decimalMinutes=None, minutes=None, seconds=None):
        self.degrees = degrees
        self.decimalMinutes = decimalMinutes
        self.minutes = minutes
        self.seconds = seconds
    def factory(*args_, **kwargs_):
        if DMSAngleType.subclass:
            return DMSAngleType.subclass(*args_, **kwargs_)
        else:
            return DMSAngleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_degrees(self): return self.degrees
    def set_degrees(self, degrees): self.degrees = degrees
    def get_decimalMinutes(self): return self.decimalMinutes
    def set_decimalMinutes(self, decimalMinutes): self.decimalMinutes = decimalMinutes
    def get_minutes(self): return self.minutes
    def set_minutes(self, minutes): self.minutes = minutes
    def get_seconds(self): return self.seconds
    def set_seconds(self, seconds): self.seconds = seconds
    def export(self, outfile, level, namespace_='', name_='DMSAngleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DMSAngleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DMSAngleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DMSAngleType', fromsubclass_=False):
        if self.degrees is not None:
            self.degrees.export(outfile, level, namespace_, name_='degrees', )
        if self.decimalMinutes is not None:
            self.decimalMinutes.export(outfile, level, namespace_, name_='decimalMinutes')
        if self.minutes is not None:
            self.minutes.export(outfile, level, namespace_, name_='minutes')
        if self.seconds is not None:
            self.seconds.export(outfile, level, namespace_, name_='seconds')
    def hasContent_(self):
        if (
            self.degrees is not None or
            self.decimalMinutes is not None or
            self.minutes is not None or
            self.seconds is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DMSAngleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.degrees is not None:
            showIndent(outfile, level)
            outfile.write('degrees=model_.degrees(\n')
            self.degrees.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.decimalMinutes is not None:
            showIndent(outfile, level)
            outfile.write('decimalMinutes=model_.decimalMinutes(\n')
            self.decimalMinutes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.minutes is not None:
            showIndent(outfile, level)
            outfile.write('minutes=model_.minutes(\n')
            self.minutes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seconds is not None:
            showIndent(outfile, level)
            outfile.write('seconds=model_.seconds(\n')
            self.seconds.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'degrees':
            obj_ = DegreesType.factory()
            obj_.build(child_)
            self.set_degrees(obj_)
        elif nodeName_ == 'decimalMinutes':
            obj_ = decimal.factory()
            obj_.build(child_)
            self.set_decimalMinutes(obj_)
        elif nodeName_ == 'minutes':
            obj_ = nonNegativeInteger.factory()
            obj_.build(child_)
            self.set_minutes(obj_)
        elif nodeName_ == 'seconds':
            obj_ = decimal.factory()
            obj_.build(child_)
            self.set_seconds(obj_)
# end class DMSAngleType


class DegreesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, direction=None, valueOf_=None):
        self.direction = _cast(None, direction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DegreesType.subclass:
            return DegreesType.subclass(*args_, **kwargs_)
        else:
            return DegreesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='DegreesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DegreesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DegreesType'):
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            outfile.write(' direction=%s' % (quote_attrib(self.direction), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DegreesType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DegreesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            showIndent(outfile, level)
            outfile.write('direction = %s,\n' % (self.direction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            self.direction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DegreesType


class AngleChoiceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, angle=None, dmsAngle=None):
        self.angle = angle
        self.dmsAngle = dmsAngle
    def factory(*args_, **kwargs_):
        if AngleChoiceType.subclass:
            return AngleChoiceType.subclass(*args_, **kwargs_)
        else:
            return AngleChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_angle(self): return self.angle
    def set_angle(self, angle): self.angle = angle
    def get_dmsAngle(self): return self.dmsAngle
    def set_dmsAngle(self, dmsAngle): self.dmsAngle = dmsAngle
    def export(self, outfile, level, namespace_='', name_='AngleChoiceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AngleChoiceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AngleChoiceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AngleChoiceType', fromsubclass_=False):
        if self.angle is not None:
            self.angle.export(outfile, level, namespace_, name_='angle', )
        if self.dmsAngle is not None:
            self.dmsAngle.export(outfile, level, namespace_, name_='dmsAngle', )
    def hasContent_(self):
        if (
            self.angle is not None or
            self.dmsAngle is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AngleChoiceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.angle is not None:
            showIndent(outfile, level)
            outfile.write('angle=model_.angle(\n')
            self.angle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dmsAngle is not None:
            showIndent(outfile, level)
            outfile.write('dmsAngle=model_.dmsAngle(\n')
            self.dmsAngle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'angle':
            obj_ = AngleType.factory()
            obj_.build(child_)
            self.set_angle(obj_)
        elif nodeName_ == 'dmsAngle':
            obj_ = DMSAngleType.factory()
            obj_.build(child_)
            self.set_dmsAngle(obj_)
# end class AngleChoiceType


class ArrayAssociationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, owns='false', AbstractObject=None):
        self.owns = _cast(None, owns)
        if AbstractObject is None:
            self.AbstractObject = []
        else:
            self.AbstractObject = AbstractObject
    def factory(*args_, **kwargs_):
        if ArrayAssociationType.subclass:
            return ArrayAssociationType.subclass(*args_, **kwargs_)
        else:
            return ArrayAssociationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractObject(self): return self.AbstractObject
    def set_AbstractObject(self, AbstractObject): self.AbstractObject = AbstractObject
    def add_AbstractObject(self, value): self.AbstractObject.append(value)
    def insert_AbstractObject(self, index, value): self.AbstractObject[index] = value
    def get_owns(self): return self.owns
    def set_owns(self, owns): self.owns = owns
    def export(self, outfile, level, namespace_='', name_='ArrayAssociationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayAssociationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArrayAssociationType'):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            outfile.write(' owns=%s' % (quote_attrib(self.owns), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArrayAssociationType', fromsubclass_=False):
        for AbstractObject_ in self.get_AbstractObject():
            AbstractObject_.export(outfile, level, namespace_, name_='AbstractObject')
    def hasContent_(self):
        if (
            self.AbstractObject
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArrayAssociationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            showIndent(outfile, level)
            outfile.write('owns = %s,\n' % (self.owns,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AbstractObject=[\n')
        level += 1
        for AbstractObject_ in self.AbstractObject:
            showIndent(outfile, level)
            outfile.write('model_.AbstractObject(\n')
            AbstractObject_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.append('owns')
            self.owns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractObject':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractObject> element')
            self.AbstractObject.append(obj_)
# end class ArrayAssociationType


class StringOrRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if StringOrRefType.subclass:
            return StringOrRefType.subclass(*args_, **kwargs_)
        else:
            return StringOrRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='StringOrRefType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringOrRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StringOrRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StringOrRefType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StringOrRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StringOrRefType


class BagType(AbstractGMLType):
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, member=None, members=None):
        super(BagType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        if member is None:
            self.member = []
        else:
            self.member = member
        self.members = members
    def factory(*args_, **kwargs_):
        if BagType.subclass:
            return BagType.subclass(*args_, **kwargs_)
        else:
            return BagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_members(self): return self.members
    def set_members(self, members): self.members = members
    def export(self, outfile, level, namespace_='', name_='BagType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BagType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BagType'):
        super(BagType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BagType')
    def exportChildren(self, outfile, level, namespace_='', name_='BagType', fromsubclass_=False):
        super(BagType, self).exportChildren(outfile, level, namespace_, name_, True)
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
        if self.members is not None:
            self.members.export(outfile, level, namespace_, name_='members')
    def hasContent_(self):
        if (
            self.member or
            self.members is not None or
            super(BagType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BagType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BagType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BagType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.member(\n')
            member_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.members is not None:
            showIndent(outfile, level)
            outfile.write('members=model_.members(\n')
            self.members.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BagType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'member':
            obj_ = AssociationRoleType.factory()
            obj_.build(child_)
            self.member.append(obj_)
        elif nodeName_ == 'members':
            obj_ = ArrayAssociationType.factory()
            obj_.build(child_)
            self.set_members(obj_)
        super(BagType, self).buildChildren(child_, node, nodeName_, True)
# end class BagType


class ArrayType(AbstractGMLType):
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, members=None):
        super(ArrayType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.members = members
    def factory(*args_, **kwargs_):
        if ArrayType.subclass:
            return ArrayType.subclass(*args_, **kwargs_)
        else:
            return ArrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_members(self): return self.members
    def set_members(self, members): self.members = members
    def export(self, outfile, level, namespace_='', name_='ArrayType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArrayType'):
        super(ArrayType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayType')
    def exportChildren(self, outfile, level, namespace_='', name_='ArrayType', fromsubclass_=False):
        super(ArrayType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.members is not None:
            self.members.export(outfile, level, namespace_, name_='members')
    def hasContent_(self):
        if (
            self.members is not None or
            super(ArrayType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArrayType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ArrayType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ArrayType, self).exportLiteralChildren(outfile, level, name_)
        if self.members is not None:
            showIndent(outfile, level)
            outfile.write('members=model_.members(\n')
            self.members.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ArrayType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'members':
            obj_ = ArrayAssociationType.factory()
            obj_.build(child_)
            self.set_members(obj_)
        super(ArrayType, self).buildChildren(child_, node, nodeName_, True)
# end class ArrayType


class MetaDataPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, about=None, AbstractMetaData=None):
        self.about = _cast(None, about)
        self.AbstractMetaData = AbstractMetaData
    def factory(*args_, **kwargs_):
        if MetaDataPropertyType.subclass:
            return MetaDataPropertyType.subclass(*args_, **kwargs_)
        else:
            return MetaDataPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractMetaData(self): return self.AbstractMetaData
    def set_AbstractMetaData(self, AbstractMetaData): self.AbstractMetaData = AbstractMetaData
    def get_about(self): return self.about
    def set_about(self, about): self.about = about
    def export(self, outfile, level, namespace_='', name_='MetaDataPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetaDataPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetaDataPropertyType'):
        if self.about is not None and 'about' not in already_processed:
            already_processed.append('about')
            outfile.write(' about=%s' % (quote_attrib(self.about), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MetaDataPropertyType', fromsubclass_=False):
        if self.AbstractMetaData is not None:
            self.AbstractMetaData.export(outfile, level, namespace_, name_='AbstractMetaData')
    def hasContent_(self):
        if (
            self.AbstractMetaData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MetaDataPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.about is not None and 'about' not in already_processed:
            already_processed.append('about')
            showIndent(outfile, level)
            outfile.write('about = %s,\n' % (self.about,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractMetaData is not None:
            showIndent(outfile, level)
            outfile.write('AbstractMetaData=model_.AbstractMetaData(\n')
            self.AbstractMetaData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('about', node)
        if value is not None and 'about' not in already_processed:
            already_processed.append('about')
            self.about = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractMetaData':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractMetaData> element')
            self.set_AbstractMetaData(obj_)
# end class MetaDataPropertyType


class AbstractMetaDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractMetaDataType.subclass:
            return AbstractMetaDataType.subclass(*args_, **kwargs_)
        else:
            return AbstractMetaDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractMetaDataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMetaDataType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractMetaDataType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractMetaDataType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractMetaDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class AbstractMetaDataType


class GenericMetaDataType(AbstractMetaDataType):
    subclass = None
    superclass = AbstractMetaDataType
    def __init__(self, id=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        super(GenericMetaDataType, self).__init__(id, valueOf_, mixedclass_, content_, )
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if GenericMetaDataType.subclass:
            return GenericMetaDataType.subclass(*args_, **kwargs_)
        else:
            return GenericMetaDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='GenericMetaDataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericMetaDataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericMetaDataType'):
        super(GenericMetaDataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GenericMetaDataType')
    def exportChildren(self, outfile, level, namespace_='', name_='GenericMetaDataType', fromsubclass_=False):
        super(GenericMetaDataType, self).exportChildren(outfile, level, namespace_, name_, True)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_ or
            super(GenericMetaDataType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GenericMetaDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GenericMetaDataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GenericMetaDataType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericMetaDataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(GenericMetaDataType, self).buildChildren(child_, node, nodeName_, True)
# end class GenericMetaDataType


class LocationPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbstractGeometry=None, LocationKeyWord=None, LocationString=None, Null=None, extensiontype_=None):
        self.AbstractGeometry = AbstractGeometry
        self.LocationKeyWord = LocationKeyWord
        self.LocationString = LocationString
        self.Null = Null
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if LocationPropertyType.subclass:
            return LocationPropertyType.subclass(*args_, **kwargs_)
        else:
            return LocationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractGeometry(self): return self.AbstractGeometry
    def set_AbstractGeometry(self, AbstractGeometry): self.AbstractGeometry = AbstractGeometry
    def get_LocationKeyWord(self): return self.LocationKeyWord
    def set_LocationKeyWord(self, LocationKeyWord): self.LocationKeyWord = LocationKeyWord
    def get_LocationString(self): return self.LocationString
    def set_LocationString(self, LocationString): self.LocationString = LocationString
    def get_Null(self): return self.Null
    def set_Null(self, Null): self.Null = Null
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='LocationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationPropertyType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationPropertyType', fromsubclass_=False):
        if self.AbstractGeometry is not None:
            self.AbstractGeometry.export(outfile, level, namespace_, name_='AbstractGeometry')
        if self.LocationKeyWord is not None:
            self.LocationKeyWord.export(outfile, level, namespace_, name_='LocationKeyWord', )
        if self.LocationString is not None:
            self.LocationString.export(outfile, level, namespace_, name_='LocationString', )
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('<%sNull>%s</%sNull>\n' % (namespace_, self.gds_format_string(quote_xml(self.Null).encode(ExternalEncoding), input_name='Null'), namespace_))
    def hasContent_(self):
        if (
            self.AbstractGeometry is not None or
            self.LocationKeyWord is not None or
            self.LocationString is not None or
            self.Null is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AbstractGeometry=model_.AbstractGeometry(\n')
            self.AbstractGeometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocationKeyWord is not None:
            showIndent(outfile, level)
            outfile.write('LocationKeyWord=model_.LocationKeyWord(\n')
            self.LocationKeyWord.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocationString is not None:
            showIndent(outfile, level)
            outfile.write('LocationString=model_.LocationString(\n')
            self.LocationString.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Null is not None:
            showIndent(outfile, level)
            outfile.write('Null=%s,\n' % quote_python(self.Null).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractGeometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractGeometry> element')
            self.set_AbstractGeometry(obj_)
        elif nodeName_ == 'LocationKeyWord':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_LocationKeyWord(obj_)
        elif nodeName_ == 'LocationString':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_LocationString(obj_)
        elif nodeName_ == 'Null':
            Null_ = child_.text
            Null_ = self.gds_validate_string(Null_, node, 'Null')
            self.Null = Null_
# end class LocationPropertyType


class PriorityLocationPropertyType(LocationPropertyType):
    subclass = None
    superclass = LocationPropertyType
    def __init__(self, AbstractGeometry=None, LocationKeyWord=None, LocationString=None, Null=None, priority=None):
        super(PriorityLocationPropertyType, self).__init__(AbstractGeometry, LocationKeyWord, LocationString, Null, )
        self.priority = _cast(None, priority)
        pass
    def factory(*args_, **kwargs_):
        if PriorityLocationPropertyType.subclass:
            return PriorityLocationPropertyType.subclass(*args_, **kwargs_)
        else:
            return PriorityLocationPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def export(self, outfile, level, namespace_='', name_='PriorityLocationPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriorityLocationPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriorityLocationPropertyType'):
        super(PriorityLocationPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PriorityLocationPropertyType')
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.append('priority')
            outfile.write(' priority=%s' % (quote_attrib(self.priority), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PriorityLocationPropertyType', fromsubclass_=False):
        super(PriorityLocationPropertyType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(PriorityLocationPropertyType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PriorityLocationPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.append('priority')
            showIndent(outfile, level)
            outfile.write('priority = %s,\n' % (self.priority,))
        super(PriorityLocationPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PriorityLocationPropertyType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.append('priority')
            self.priority = value
        super(PriorityLocationPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PriorityLocationPropertyType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PriorityLocationPropertyType


class FeatureArrayPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbstractFeature=None):
        self.AbstractFeature = AbstractFeature
    def factory(*args_, **kwargs_):
        if FeatureArrayPropertyType.subclass:
            return FeatureArrayPropertyType.subclass(*args_, **kwargs_)
        else:
            return FeatureArrayPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbstractFeature(self): return self.AbstractFeature
    def set_AbstractFeature(self, AbstractFeature): self.AbstractFeature = AbstractFeature
    def export(self, outfile, level, namespace_='', name_='FeatureArrayPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureArrayPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeatureArrayPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FeatureArrayPropertyType', fromsubclass_=False):
        if self.AbstractFeature is not None:
            self.AbstractFeature.export(outfile, level, namespace_, name_='AbstractFeature')
    def hasContent_(self):
        if (
            self.AbstractFeature is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FeatureArrayPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbstractFeature is not None:
            showIndent(outfile, level)
            outfile.write('AbstractFeature=model_.AbstractFeature(\n')
            self.AbstractFeature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbstractFeature':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <AbstractFeature> element')
            self.set_AbstractFeature(obj_)
# end class FeatureArrayPropertyType


class BoundedFeatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None):
        if metaDataProperty is None:
            self.metaDataProperty = []
        else:
            self.metaDataProperty = metaDataProperty
        self.description = description
        self.descriptionReference = descriptionReference
        self.identifier = identifier
        if name is None:
            self.name = []
        else:
            self.name = name
        self.boundedBy = boundedBy
        self.location = location
    def factory(*args_, **kwargs_):
        if BoundedFeatureType.subclass:
            return BoundedFeatureType.subclass(*args_, **kwargs_)
        else:
            return BoundedFeatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaDataProperty(self): return self.metaDataProperty
    def set_metaDataProperty(self, metaDataProperty): self.metaDataProperty = metaDataProperty
    def add_metaDataProperty(self, value): self.metaDataProperty.append(value)
    def insert_metaDataProperty(self, index, value): self.metaDataProperty[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_descriptionReference(self): return self.descriptionReference
    def set_descriptionReference(self, descriptionReference): self.descriptionReference = descriptionReference
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name(self, index, value): self.name[index] = value
    def get_boundedBy(self): return self.boundedBy
    def set_boundedBy(self, boundedBy): self.boundedBy = boundedBy
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def export(self, outfile, level, namespace_='', name_='BoundedFeatureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoundedFeatureType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundedFeatureType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BoundedFeatureType', fromsubclass_=False):
        for metaDataProperty_ in self.metaDataProperty:
            metaDataProperty_.export(outfile, level, namespace_, name_='metaDataProperty')
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.descriptionReference is not None:
            self.descriptionReference.export(outfile, level, namespace_, name_='descriptionReference')
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier')
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name')
        if self.boundedBy is not None:
            self.boundedBy.export(outfile, level, namespace_, name_='boundedBy', )
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location')
    def hasContent_(self):
        if (
            self.metaDataProperty or
            self.description is not None or
            self.descriptionReference is not None or
            self.identifier is not None or
            self.name or
            self.boundedBy is not None or
            self.location is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BoundedFeatureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metaDataProperty=[\n')
        level += 1
        for metaDataProperty_ in self.metaDataProperty:
            showIndent(outfile, level)
            outfile.write('model_.metaDataProperty(\n')
            metaDataProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptionReference is not None:
            showIndent(outfile, level)
            outfile.write('descriptionReference=model_.descriptionReference(\n')
            self.descriptionReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.identifier(\n')
            self.identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.name(\n')
            name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.boundedBy is not None:
            showIndent(outfile, level)
            outfile.write('boundedBy=model_.boundedBy(\n')
            self.boundedBy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.location(\n')
            self.location.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaDataProperty':
            obj_ = MetaDataPropertyType.factory()
            obj_.build(child_)
            self.metaDataProperty.append(obj_)
        elif nodeName_ == 'description':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'descriptionReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_descriptionReference(obj_)
        elif nodeName_ == 'identifier':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.name.append(obj_)
        elif nodeName_ == 'boundedBy':
            obj_ = BoundingShapeType.factory()
            obj_.build(child_)
            self.set_boundedBy(obj_)
        elif nodeName_ == 'location':
            class_obj_ = self.get_class_obj_(child_, LocationPropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_location(obj_)
# end class BoundedFeatureType


class AbstractFeatureCollectionType(AbstractFeatureType):
    subclass = None
    superclass = AbstractFeatureType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, featureMember=None, featureMembers=None, extensiontype_=None):
        super(AbstractFeatureCollectionType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, extensiontype_, )
        if featureMember is None:
            self.featureMember = []
        else:
            self.featureMember = featureMember
        self.featureMembers = featureMembers
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractFeatureCollectionType.subclass:
            return AbstractFeatureCollectionType.subclass(*args_, **kwargs_)
        else:
            return AbstractFeatureCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_featureMember(self): return self.featureMember
    def set_featureMember(self, featureMember): self.featureMember = featureMember
    def add_featureMember(self, value): self.featureMember.append(value)
    def insert_featureMember(self, index, value): self.featureMember[index] = value
    def get_featureMembers(self): return self.featureMembers
    def set_featureMembers(self, featureMembers): self.featureMembers = featureMembers
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractFeatureCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFeatureCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractFeatureCollectionType'):
        super(AbstractFeatureCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFeatureCollectionType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractFeatureCollectionType', fromsubclass_=False):
        super(AbstractFeatureCollectionType, self).exportChildren(outfile, level, namespace_, name_, True)
        for featureMember_ in self.featureMember:
            featureMember_.export(outfile, level, namespace_, name_='featureMember')
        if self.featureMembers is not None:
            self.featureMembers.export(outfile, level, namespace_, name_='featureMembers')
    def hasContent_(self):
        if (
            self.featureMember or
            self.featureMembers is not None or
            super(AbstractFeatureCollectionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractFeatureCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractFeatureCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractFeatureCollectionType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('featureMember=[\n')
        level += 1
        for featureMember_ in self.featureMember:
            showIndent(outfile, level)
            outfile.write('model_.featureMember(\n')
            featureMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.featureMembers is not None:
            showIndent(outfile, level)
            outfile.write('featureMembers=model_.featureMembers(\n')
            self.featureMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractFeatureCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'featureMember':
            obj_ = FeaturePropertyType.factory()
            obj_.build(child_)
            self.featureMember.append(obj_)
        elif nodeName_ == 'featureMembers':
            obj_ = FeatureArrayPropertyType.factory()
            obj_.build(child_)
            self.set_featureMembers(obj_)
        super(AbstractFeatureCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractFeatureCollectionType


class FeatureCollectionType(AbstractFeatureCollectionType):
    subclass = None
    superclass = AbstractFeatureCollectionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, featureMember=None, featureMembers=None):
        super(FeatureCollectionType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, featureMember, featureMembers, )
        pass
    def factory(*args_, **kwargs_):
        if FeatureCollectionType.subclass:
            return FeatureCollectionType.subclass(*args_, **kwargs_)
        else:
            return FeatureCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='FeatureCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeatureCollectionType'):
        super(FeatureCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureCollectionType')
    def exportChildren(self, outfile, level, namespace_='', name_='FeatureCollectionType', fromsubclass_=False):
        super(FeatureCollectionType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(FeatureCollectionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FeatureCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FeatureCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FeatureCollectionType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(FeatureCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FeatureCollectionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FeatureCollectionType


class IndirectEntryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DefinitionProxy=None):
        self.DefinitionProxy = DefinitionProxy
    def factory(*args_, **kwargs_):
        if IndirectEntryType.subclass:
            return IndirectEntryType.subclass(*args_, **kwargs_)
        else:
            return IndirectEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefinitionProxy(self): return self.DefinitionProxy
    def set_DefinitionProxy(self, DefinitionProxy): self.DefinitionProxy = DefinitionProxy
    def export(self, outfile, level, namespace_='', name_='IndirectEntryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndirectEntryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndirectEntryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndirectEntryType', fromsubclass_=False):
        if self.DefinitionProxy is not None:
            self.DefinitionProxy.export(outfile, level, namespace_, name_='DefinitionProxy', )
    def hasContent_(self):
        if (
            self.DefinitionProxy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndirectEntryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DefinitionProxy is not None:
            showIndent(outfile, level)
            outfile.write('DefinitionProxy=model_.DefinitionProxy(\n')
            self.DefinitionProxy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefinitionProxy':
            obj_ = DefinitionProxyType.factory()
            obj_.build(child_)
            self.set_DefinitionProxy(obj_)
# end class IndirectEntryType


class DefinitionProxyType(DefinitionType):
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, definitionRef=None):
        super(DefinitionProxyType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        self.definitionRef = definitionRef
    def factory(*args_, **kwargs_):
        if DefinitionProxyType.subclass:
            return DefinitionProxyType.subclass(*args_, **kwargs_)
        else:
            return DefinitionProxyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definitionRef(self): return self.definitionRef
    def set_definitionRef(self, definitionRef): self.definitionRef = definitionRef
    def export(self, outfile, level, namespace_='', name_='DefinitionProxyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionProxyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefinitionProxyType'):
        super(DefinitionProxyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionProxyType')
    def exportChildren(self, outfile, level, namespace_='', name_='DefinitionProxyType', fromsubclass_=False):
        super(DefinitionProxyType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.definitionRef is not None:
            self.definitionRef.export(outfile, level, namespace_, name_='definitionRef', )
    def hasContent_(self):
        if (
            self.definitionRef is not None or
            super(DefinitionProxyType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefinitionProxyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DefinitionProxyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DefinitionProxyType, self).exportLiteralChildren(outfile, level, name_)
        if self.definitionRef is not None:
            showIndent(outfile, level)
            outfile.write('definitionRef=model_.definitionRef(\n')
            self.definitionRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DefinitionProxyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definitionRef':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_definitionRef(obj_)
        super(DefinitionProxyType, self).buildChildren(child_, node, nodeName_, True)
# end class DefinitionProxyType


class StatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Comment=None, RuntimeDuration=None):
        self.Code = Code
        self.Comment = Comment
        self.RuntimeDuration = RuntimeDuration
    def factory(*args_, **kwargs_):
        if StatusType.subclass:
            return StatusType.subclass(*args_, **kwargs_)
        else:
            return StatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def validate_StopsStatusCodeEnumeration(self, value):
        # Validate type StopsStatusCodeEnumeration, a restriction on protocol:StatusCodeEnumeration.
        pass
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_RuntimeDuration(self): return self.RuntimeDuration
    def set_RuntimeDuration(self, RuntimeDuration): self.RuntimeDuration = RuntimeDuration
    def export(self, outfile, level, namespace_='', name_='StatusType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatusType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StatusType', fromsubclass_=False):
        if self.Code is not None:
            showIndent(outfile, level)
            outfile.write('<%sCode>%s</%sCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.Code).encode(ExternalEncoding), input_name='Code'), namespace_))
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('<%sComment>%s</%sComment>\n' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_))
        if self.RuntimeDuration is not None:
            showIndent(outfile, level)
            outfile.write('<%sRuntimeDuration>%s</%sRuntimeDuration>\n' % (namespace_, self.gds_format_string(quote_xml(self.RuntimeDuration).encode(ExternalEncoding), input_name='RuntimeDuration'), namespace_))
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Comment is not None or
            self.RuntimeDuration is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StatusType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Code is not None:
            showIndent(outfile, level)
            outfile.write('Code=%s,\n' % quote_python(self.Code).encode(ExternalEncoding))
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
        if self.RuntimeDuration is not None:
            showIndent(outfile, level)
            outfile.write('RuntimeDuration=%s,\n' % quote_python(self.RuntimeDuration).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
            self.validate_StopsStatusCodeEnumeration(self.Code)    # validate type StopsStatusCodeEnumeration
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
        elif nodeName_ == 'RuntimeDuration':
            RuntimeDuration_ = child_.text
            RuntimeDuration_ = self.gds_validate_string(RuntimeDuration_, node, 'RuntimeDuration')
            self.RuntimeDuration = RuntimeDuration_
# end class StatusType


class DefaultLocaleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DefaultLanguage=None, TimeZoneOffset=None):
        self.DefaultLanguage = DefaultLanguage
        self.TimeZoneOffset = TimeZoneOffset
    def factory(*args_, **kwargs_):
        if DefaultLocaleType.subclass:
            return DefaultLocaleType.subclass(*args_, **kwargs_)
        else:
            return DefaultLocaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultLanguage(self): return self.DefaultLanguage
    def set_DefaultLanguage(self, DefaultLanguage): self.DefaultLanguage = DefaultLanguage
    def get_TimeZoneOffset(self): return self.TimeZoneOffset
    def set_TimeZoneOffset(self, TimeZoneOffset): self.TimeZoneOffset = TimeZoneOffset
    def export(self, outfile, level, namespace_='', name_='DefaultLocaleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultLocaleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultLocaleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultLocaleType', fromsubclass_=False):
        if self.DefaultLanguage is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefaultLanguage>%s</%sDefaultLanguage>\n' % (namespace_, self.gds_format_string(quote_xml(self.DefaultLanguage).encode(ExternalEncoding), input_name='DefaultLanguage'), namespace_))
        if self.TimeZoneOffset is not None:
            showIndent(outfile, level)
            outfile.write('<%sTimeZoneOffset>%s</%sTimeZoneOffset>\n' % (namespace_, self.gds_format_float(self.TimeZoneOffset, input_name='TimeZoneOffset'), namespace_))
    def hasContent_(self):
        if (
            self.DefaultLanguage is not None or
            self.TimeZoneOffset is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefaultLocaleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DefaultLanguage is not None:
            showIndent(outfile, level)
            outfile.write('DefaultLanguage=%s,\n' % quote_python(self.DefaultLanguage).encode(ExternalEncoding))
        if self.TimeZoneOffset is not None:
            showIndent(outfile, level)
            outfile.write('TimeZoneOffset=%f,\n' % self.TimeZoneOffset)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultLanguage':
            DefaultLanguage_ = child_.text
            DefaultLanguage_ = self.gds_validate_string(DefaultLanguage_, node, 'DefaultLanguage')
            self.DefaultLanguage = DefaultLanguage_
        elif nodeName_ == 'TimeZoneOffset':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TimeZoneOffset')
            self.TimeZoneOffset = fval_
# end class DefaultLocaleType


class geographicOverviewFormatsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GeographicOverviewFormat=None):
        if GeographicOverviewFormat is None:
            self.GeographicOverviewFormat = []
        else:
            self.GeographicOverviewFormat = GeographicOverviewFormat
    def factory(*args_, **kwargs_):
        if geographicOverviewFormatsType.subclass:
            return geographicOverviewFormatsType.subclass(*args_, **kwargs_)
        else:
            return geographicOverviewFormatsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeographicOverviewFormat(self): return self.GeographicOverviewFormat
    def set_GeographicOverviewFormat(self, GeographicOverviewFormat): self.GeographicOverviewFormat = GeographicOverviewFormat
    def add_GeographicOverviewFormat(self, value): self.GeographicOverviewFormat.append(value)
    def insert_GeographicOverviewFormat(self, index, value): self.GeographicOverviewFormat[index] = value
    def export(self, outfile, level, namespace_='', name_='geographicOverviewFormatsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='geographicOverviewFormatsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='geographicOverviewFormatsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='geographicOverviewFormatsType', fromsubclass_=False):
        for GeographicOverviewFormat_ in self.GeographicOverviewFormat:
            GeographicOverviewFormat_.export(outfile, level, namespace_, name_='GeographicOverviewFormat')
    def hasContent_(self):
        if (
            self.GeographicOverviewFormat
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='geographicOverviewFormatsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('GeographicOverviewFormat=[\n')
        level += 1
        for GeographicOverviewFormat_ in self.GeographicOverviewFormat:
            showIndent(outfile, level)
            outfile.write('model_.GeographicOverviewFormatType(\n')
            GeographicOverviewFormat_.exportLiteral(outfile, level, name_='GeographicOverviewFormatType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeographicOverviewFormat':
            obj_ = GeographicOverviewFormatType.factory()
            obj_.build(child_)
            self.GeographicOverviewFormat.append(obj_)
# end class geographicOverviewFormatsType


class GeographicOverviewFormatType(GeneratedsSuper):
    """Indique s'il s'agit du format par défaut dans l'ensemble de la
    réponse du service"""
    subclass = None
    superclass = None
    def __init__(self, default=None, GeographicResourceFormatRef=None, GeographicResourceFormat=None):
        self.default = _cast(bool, default)
        self.GeographicResourceFormatRef = GeographicResourceFormatRef
        self.GeographicResourceFormat = GeographicResourceFormat
    def factory(*args_, **kwargs_):
        if GeographicOverviewFormatType.subclass:
            return GeographicOverviewFormatType.subclass(*args_, **kwargs_)
        else:
            return GeographicOverviewFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeographicResourceFormatRef(self): return self.GeographicResourceFormatRef
    def set_GeographicResourceFormatRef(self, GeographicResourceFormatRef): self.GeographicResourceFormatRef = GeographicResourceFormatRef
    def get_GeographicResourceFormat(self): return self.GeographicResourceFormat
    def set_GeographicResourceFormat(self, GeographicResourceFormat): self.GeographicResourceFormat = GeographicResourceFormat
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def export(self, outfile, level, namespace_='', name_='GeographicOverviewFormatType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeographicOverviewFormatType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeographicOverviewFormatType'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.default)), input_name='default'))
    def exportChildren(self, outfile, level, namespace_='', name_='GeographicOverviewFormatType', fromsubclass_=False):
        if self.GeographicResourceFormatRef is not None:
            showIndent(outfile, level)
            outfile.write('<%sGeographicResourceFormatRef>%s</%sGeographicResourceFormatRef>\n' % (namespace_, self.gds_format_integer(self.GeographicResourceFormatRef, input_name='GeographicResourceFormatRef'), namespace_))
        if self.GeographicResourceFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sGeographicResourceFormat>%s</%sGeographicResourceFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.GeographicResourceFormat).encode(ExternalEncoding), input_name='GeographicResourceFormat'), namespace_))
    def hasContent_(self):
        if (
            self.GeographicResourceFormatRef is not None or
            self.GeographicResourceFormat is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeographicOverviewFormatType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = %s,\n' % (self.default,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GeographicResourceFormatRef is not None:
            showIndent(outfile, level)
            outfile.write('GeographicResourceFormatRef=%d,\n' % self.GeographicResourceFormatRef)
        if self.GeographicResourceFormat is not None:
            showIndent(outfile, level)
            outfile.write('GeographicResourceFormat=%s,\n' % quote_python(self.GeographicResourceFormat).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            if value in ('true', '1'):
                self.default = True
            elif value in ('false', '0'):
                self.default = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeographicResourceFormatRef':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GeographicResourceFormatRef')
            self.GeographicResourceFormatRef = ival_
        elif nodeName_ == 'GeographicResourceFormat':
            GeographicResourceFormat_ = child_.text
            GeographicResourceFormat_ = self.gds_validate_string(GeographicResourceFormat_, node, 'GeographicResourceFormat')
            self.GeographicResourceFormat = GeographicResourceFormat_
# end class GeographicOverviewFormatType


class dataObjectsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frameValidityConditions=None, CompositeFrame=None):
        self.frameValidityConditions = frameValidityConditions
        self.CompositeFrame = CompositeFrame
    def factory(*args_, **kwargs_):
        if dataObjectsType.subclass:
            return dataObjectsType.subclass(*args_, **kwargs_)
        else:
            return dataObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frameValidityConditions(self): return self.frameValidityConditions
    def set_frameValidityConditions(self, frameValidityConditions): self.frameValidityConditions = frameValidityConditions
    def get_CompositeFrame(self): return self.CompositeFrame
    def set_CompositeFrame(self, CompositeFrame): self.CompositeFrame = CompositeFrame
    def export(self, outfile, level, namespace_='', name_='dataObjectsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataObjectsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dataObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dataObjectsType', fromsubclass_=False):
        if self.frameValidityConditions is not None:
            self.frameValidityConditions.export(outfile, level, namespace_, name_='frameValidityConditions')
        if self.CompositeFrame is not None:
            self.CompositeFrame.export(outfile, level, namespace_, name_='CompositeFrame', )
    def hasContent_(self):
        if (
            self.frameValidityConditions is not None or
            self.CompositeFrame is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataObjectsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.frameValidityConditions is not None:
            showIndent(outfile, level)
            outfile.write('frameValidityConditions=model_.frameValidityConditionsType(\n')
            self.frameValidityConditions.exportLiteral(outfile, level, name_='frameValidityConditions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompositeFrame is not None:
            showIndent(outfile, level)
            outfile.write('CompositeFrame=model_.CompositeFrameType(\n')
            self.CompositeFrame.exportLiteral(outfile, level, name_='CompositeFrame')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frameValidityConditions':
            obj_ = frameValidityConditionsType.factory()
            obj_.build(child_)
            self.set_frameValidityConditions(obj_)
        elif nodeName_ == 'CompositeFrame':
            obj_ = CompositeFrameType.factory()
            obj_.build(child_)
            self.set_CompositeFrame(obj_)
# end class dataObjectsType


class frameValidityConditionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SimpleValidityCondition=None):
        self.SimpleValidityCondition = SimpleValidityCondition
    def factory(*args_, **kwargs_):
        if frameValidityConditionsType.subclass:
            return frameValidityConditionsType.subclass(*args_, **kwargs_)
        else:
            return frameValidityConditionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SimpleValidityCondition(self): return self.SimpleValidityCondition
    def set_SimpleValidityCondition(self, SimpleValidityCondition): self.SimpleValidityCondition = SimpleValidityCondition
    def export(self, outfile, level, namespace_='', name_='frameValidityConditionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='frameValidityConditionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='frameValidityConditionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='frameValidityConditionsType', fromsubclass_=False):
        if self.SimpleValidityCondition is not None:
            self.SimpleValidityCondition.export(outfile, level, namespace_, name_='SimpleValidityCondition', )
    def hasContent_(self):
        if (
            self.SimpleValidityCondition is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='frameValidityConditionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SimpleValidityCondition is not None:
            showIndent(outfile, level)
            outfile.write('SimpleValidityCondition=model_.SimpleValidityConditionType(\n')
            self.SimpleValidityCondition.exportLiteral(outfile, level, name_='SimpleValidityCondition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SimpleValidityCondition':
            obj_ = SimpleValidityConditionType.factory()
            obj_.build(child_)
            self.set_SimpleValidityCondition(obj_)
# end class frameValidityConditionsType


class SimpleValidityConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FromDate=None, ToDate=None):
        self.FromDate = FromDate
        self.ToDate = ToDate
    def factory(*args_, **kwargs_):
        if SimpleValidityConditionType.subclass:
            return SimpleValidityConditionType.subclass(*args_, **kwargs_)
        else:
            return SimpleValidityConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FromDate(self): return self.FromDate
    def set_FromDate(self, FromDate): self.FromDate = FromDate
    def get_ToDate(self): return self.ToDate
    def set_ToDate(self, ToDate): self.ToDate = ToDate
    def export(self, outfile, level, namespace_='', name_='SimpleValidityConditionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleValidityConditionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleValidityConditionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleValidityConditionType', fromsubclass_=False):
        if self.FromDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sFromDate>%s</%sFromDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.FromDate).encode(ExternalEncoding), input_name='FromDate'), namespace_))
        if self.ToDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sToDate>%s</%sToDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.ToDate).encode(ExternalEncoding), input_name='ToDate'), namespace_))
    def hasContent_(self):
        if (
            self.FromDate is not None or
            self.ToDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SimpleValidityConditionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FromDate is not None:
            showIndent(outfile, level)
            outfile.write('FromDate=%s,\n' % quote_python(self.FromDate).encode(ExternalEncoding))
        if self.ToDate is not None:
            showIndent(outfile, level)
            outfile.write('ToDate=%s,\n' % quote_python(self.ToDate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FromDate':
            FromDate_ = child_.text
            FromDate_ = self.gds_validate_string(FromDate_, node, 'FromDate')
            self.FromDate = FromDate_
        elif nodeName_ == 'ToDate':
            ToDate_ = child_.text
            ToDate_ = self.gds_validate_string(ToDate_, node, 'ToDate')
            self.ToDate = ToDate_
# end class SimpleValidityConditionType


class CompositeFrameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frames=None):
        self.frames = frames
    def factory(*args_, **kwargs_):
        if CompositeFrameType.subclass:
            return CompositeFrameType.subclass(*args_, **kwargs_)
        else:
            return CompositeFrameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frames(self): return self.frames
    def set_frames(self, frames): self.frames = frames
    def export(self, outfile, level, namespace_='', name_='CompositeFrameType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeFrameType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompositeFrameType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CompositeFrameType', fromsubclass_=False):
        if self.frames is not None:
            self.frames.export(outfile, level, namespace_, name_='frames', )
    def hasContent_(self):
        if (
            self.frames is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CompositeFrameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.frames is not None:
            showIndent(outfile, level)
            outfile.write('frames=model_.framesType(\n')
            self.frames.exportLiteral(outfile, level, name_='frames')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frames':
            obj_ = framesType.factory()
            obj_.build(child_)
            self.set_frames(obj_)
# end class CompositeFrameType


class framesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SiteFrame=None):
        self.SiteFrame = SiteFrame
    def factory(*args_, **kwargs_):
        if framesType.subclass:
            return framesType.subclass(*args_, **kwargs_)
        else:
            return framesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SiteFrame(self): return self.SiteFrame
    def set_SiteFrame(self, SiteFrame): self.SiteFrame = SiteFrame
    def export(self, outfile, level, namespace_='', name_='framesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='framesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='framesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='framesType', fromsubclass_=False):
        if self.SiteFrame is not None:
            self.SiteFrame.export(outfile, level, namespace_, name_='SiteFrame', )
    def hasContent_(self):
        if (
            self.SiteFrame is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='framesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SiteFrame is not None:
            showIndent(outfile, level)
            outfile.write('SiteFrame=model_.SiteFrameType(\n')
            self.SiteFrame.exportLiteral(outfile, level, name_='SiteFrame')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SiteFrame':
            obj_ = SiteFrameType.factory()
            obj_.build(child_)
            self.set_SiteFrame(obj_)
# end class framesType


class SiteFrameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, stopPlaces=None):
        self.stopPlaces = stopPlaces
    def factory(*args_, **kwargs_):
        if SiteFrameType.subclass:
            return SiteFrameType.subclass(*args_, **kwargs_)
        else:
            return SiteFrameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stopPlaces(self): return self.stopPlaces
    def set_stopPlaces(self, stopPlaces): self.stopPlaces = stopPlaces
    def export(self, outfile, level, namespace_='', name_='SiteFrameType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SiteFrameType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SiteFrameType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SiteFrameType', fromsubclass_=False):
        if self.stopPlaces is not None:
            self.stopPlaces.export(outfile, level, namespace_, name_='stopPlaces', )
    def hasContent_(self):
        if (
            self.stopPlaces is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SiteFrameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.stopPlaces is not None:
            showIndent(outfile, level)
            outfile.write('stopPlaces=model_.stopPlacesType(\n')
            self.stopPlaces.exportLiteral(outfile, level, name_='stopPlaces')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stopPlaces':
            obj_ = stopPlacesType.factory()
            obj_.build(child_)
            self.set_stopPlaces(obj_)
# end class SiteFrameType


class stopPlacesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StopPlace=None):
        if StopPlace is None:
            self.StopPlace = []
        else:
            self.StopPlace = StopPlace
    def factory(*args_, **kwargs_):
        if stopPlacesType.subclass:
            return stopPlacesType.subclass(*args_, **kwargs_)
        else:
            return stopPlacesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StopPlace(self): return self.StopPlace
    def set_StopPlace(self, StopPlace): self.StopPlace = StopPlace
    def add_StopPlace(self, value): self.StopPlace.append(value)
    def insert_StopPlace(self, index, value): self.StopPlace[index] = value
    def export(self, outfile, level, namespace_='', name_='stopPlacesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stopPlacesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stopPlacesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='stopPlacesType', fromsubclass_=False):
        for StopPlace_ in self.StopPlace:
            StopPlace_.export(outfile, level, namespace_, name_='StopPlace')
    def hasContent_(self):
        if (
            self.StopPlace
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stopPlacesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StopPlace=[\n')
        level += 1
        for StopPlace_ in self.StopPlace:
            showIndent(outfile, level)
            outfile.write('model_.StopPlaceType(\n')
            StopPlace_.exportLiteral(outfile, level, name_='StopPlaceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StopPlace':
            obj_ = StopPlaceType.factory()
            obj_.build(child_)
            self.StopPlace.append(obj_)
# end class stopPlacesType


class StopPlaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, ParentZoneRef=None, placeTypes=None, quays=None):
        self.id = _cast(None, id)
        self.ParentZoneRef = ParentZoneRef
        self.placeTypes = placeTypes
        self.quays = quays
    def factory(*args_, **kwargs_):
        if StopPlaceType.subclass:
            return StopPlaceType.subclass(*args_, **kwargs_)
        else:
            return StopPlaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParentZoneRef(self): return self.ParentZoneRef
    def set_ParentZoneRef(self, ParentZoneRef): self.ParentZoneRef = ParentZoneRef
    def get_placeTypes(self): return self.placeTypes
    def set_placeTypes(self, placeTypes): self.placeTypes = placeTypes
    def get_quays(self): return self.quays
    def set_quays(self, quays): self.quays = quays
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='StopPlaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StopPlaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StopPlaceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StopPlaceType', fromsubclass_=False):
        if self.ParentZoneRef is not None:
            showIndent(outfile, level)
            outfile.write('<%sParentZoneRef>%s</%sParentZoneRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.ParentZoneRef).encode(ExternalEncoding), input_name='ParentZoneRef'), namespace_))
        if self.placeTypes is not None:
            self.placeTypes.export(outfile, level, namespace_, name_='placeTypes')
        if self.quays is not None:
            self.quays.export(outfile, level, namespace_, name_='quays')
    def hasContent_(self):
        if (
            self.ParentZoneRef is not None or
            self.placeTypes is not None or
            self.quays is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StopPlaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ParentZoneRef is not None:
            showIndent(outfile, level)
            outfile.write('ParentZoneRef=%s,\n' % quote_python(self.ParentZoneRef).encode(ExternalEncoding))
        if self.placeTypes is not None:
            showIndent(outfile, level)
            outfile.write('placeTypes=model_.placeTypesType(\n')
            self.placeTypes.exportLiteral(outfile, level, name_='placeTypes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.quays is not None:
            showIndent(outfile, level)
            outfile.write('quays=model_.quaysType(\n')
            self.quays.exportLiteral(outfile, level, name_='quays')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParentZoneRef':
            ParentZoneRef_ = child_.text
            ParentZoneRef_ = self.gds_validate_string(ParentZoneRef_, node, 'ParentZoneRef')
            self.ParentZoneRef = ParentZoneRef_
        elif nodeName_ == 'placeTypes':
            obj_ = placeTypesType.factory()
            obj_.build(child_)
            self.set_placeTypes(obj_)
        elif nodeName_ == 'quays':
            obj_ = quaysType.factory()
            obj_.build(child_)
            self.set_quays(obj_)
# end class StopPlaceType


class placeTypesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TypeOfPlaceRef=None):
        self.TypeOfPlaceRef = TypeOfPlaceRef
    def factory(*args_, **kwargs_):
        if placeTypesType.subclass:
            return placeTypesType.subclass(*args_, **kwargs_)
        else:
            return placeTypesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TypeOfPlaceRef(self): return self.TypeOfPlaceRef
    def set_TypeOfPlaceRef(self, TypeOfPlaceRef): self.TypeOfPlaceRef = TypeOfPlaceRef
    def export(self, outfile, level, namespace_='', name_='placeTypesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='placeTypesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='placeTypesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='placeTypesType', fromsubclass_=False):
        if self.TypeOfPlaceRef is not None:
            showIndent(outfile, level)
            outfile.write('<%sTypeOfPlaceRef>%s</%sTypeOfPlaceRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.TypeOfPlaceRef).encode(ExternalEncoding), input_name='TypeOfPlaceRef'), namespace_))
    def hasContent_(self):
        if (
            self.TypeOfPlaceRef is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='placeTypesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TypeOfPlaceRef is not None:
            showIndent(outfile, level)
            outfile.write('TypeOfPlaceRef=%s,\n' % quote_python(self.TypeOfPlaceRef).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TypeOfPlaceRef':
            TypeOfPlaceRef_ = child_.text
            TypeOfPlaceRef_ = self.gds_validate_string(TypeOfPlaceRef_, node, 'TypeOfPlaceRef')
            self.TypeOfPlaceRef = TypeOfPlaceRef_
# end class placeTypesType


class quaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Quay=None):
        if Quay is None:
            self.Quay = []
        else:
            self.Quay = Quay
    def factory(*args_, **kwargs_):
        if quaysType.subclass:
            return quaysType.subclass(*args_, **kwargs_)
        else:
            return quaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Quay(self): return self.Quay
    def set_Quay(self, Quay): self.Quay = Quay
    def add_Quay(self, value): self.Quay.append(value)
    def insert_Quay(self, index, value): self.Quay[index] = value
    def export(self, outfile, level, namespace_='', name_='quaysType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='quaysType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='quaysType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='quaysType', fromsubclass_=False):
        for Quay_ in self.Quay:
            Quay_.export(outfile, level, namespace_, name_='Quay')
    def hasContent_(self):
        if (
            self.Quay
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='quaysType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Quay=[\n')
        level += 1
        for Quay_ in self.Quay:
            showIndent(outfile, level)
            outfile.write('model_.QuayType(\n')
            Quay_.exportLiteral(outfile, level, name_='QuayType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Quay':
            obj_ = QuayType.factory()
            obj_.build(child_)
            self.Quay.append(obj_)
# end class quaysType


class CentroidType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None):
        self.Location = Location
    def factory(*args_, **kwargs_):
        if CentroidType.subclass:
            return CentroidType.subclass(*args_, **kwargs_)
        else:
            return CentroidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def export(self, outfile, level, namespace_='', name_='CentroidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CentroidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CentroidType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CentroidType', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location', )
    def hasContent_(self):
        if (
            self.Location is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CentroidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationStructure(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationStructure.factory()
            obj_.build(child_)
            self.set_Location(obj_)
# end class CentroidType


class PostalAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, id=None, created=None, CountryRef=None, AddressLine1=None, PostCode=None):
        self.version = _cast(None, version)
        self.id = _cast(None, id)
        self.created = _cast(None, created)
        self.CountryRef = CountryRef
        self.AddressLine1 = AddressLine1
        self.PostCode = PostCode
    def factory(*args_, **kwargs_):
        if PostalAddressType.subclass:
            return PostalAddressType.subclass(*args_, **kwargs_)
        else:
            return PostalAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryRef(self): return self.CountryRef
    def set_CountryRef(self, CountryRef): self.CountryRef = CountryRef
    def get_AddressLine1(self): return self.AddressLine1
    def set_AddressLine1(self, AddressLine1): self.AddressLine1 = AddressLine1
    def get_PostCode(self): return self.PostCode
    def set_PostCode(self, PostCode): self.PostCode = PostCode
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def export(self, outfile, level, namespace_='', name_='PostalAddressType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostalAddressType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostalAddressType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.created is not None and 'created' not in already_processed:
            already_processed.append('created')
            outfile.write(' created=%s' % (self.gds_format_string(quote_attrib(self.created).encode(ExternalEncoding), input_name='created'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PostalAddressType', fromsubclass_=False):
        if self.CountryRef is not None:
            self.CountryRef.export(outfile, level, namespace_, name_='CountryRef')
        if self.AddressLine1 is not None:
            showIndent(outfile, level)
            outfile.write('<%sAddressLine1>%s</%sAddressLine1>\n' % (namespace_, self.gds_format_string(quote_xml(self.AddressLine1).encode(ExternalEncoding), input_name='AddressLine1'), namespace_))
        if self.PostCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sPostCode>%s</%sPostCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.PostCode).encode(ExternalEncoding), input_name='PostCode'), namespace_))
    def hasContent_(self):
        if (
            self.CountryRef is not None or
            self.AddressLine1 is not None or
            self.PostCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PostalAddressType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.created is not None and 'created' not in already_processed:
            already_processed.append('created')
            showIndent(outfile, level)
            outfile.write('created = "%s",\n' % (self.created,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CountryRef is not None:
            showIndent(outfile, level)
            outfile.write('CountryRef=model_.CountryRefType(\n')
            self.CountryRef.exportLiteral(outfile, level, name_='CountryRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AddressLine1 is not None:
            showIndent(outfile, level)
            outfile.write('AddressLine1=%s,\n' % quote_python(self.AddressLine1).encode(ExternalEncoding))
        if self.PostCode is not None:
            showIndent(outfile, level)
            outfile.write('PostCode=%s,\n' % quote_python(self.PostCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('created', node)
        if value is not None and 'created' not in already_processed:
            already_processed.append('created')
            self.created = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CountryRef':
            obj_ = CountryRefType.factory()
            obj_.build(child_)
            self.set_CountryRef(obj_)
        elif nodeName_ == 'AddressLine1':
            AddressLine1_ = child_.text
            AddressLine1_ = self.gds_validate_string(AddressLine1_, node, 'AddressLine1')
            self.AddressLine1 = AddressLine1_
        elif nodeName_ == 'PostCode':
            PostCode_ = child_.text
            PostCode_ = self.gds_validate_string(PostCode_, node, 'PostCode')
            self.PostCode = PostCode_
# end class PostalAddressType


class CountryRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if CountryRefType.subclass:
            return CountryRefType.subclass(*args_, **kwargs_)
        else:
            return CountryRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def export(self, outfile, level, namespace_='', name_='CountryRefType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryRefType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryRefType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CountryRefType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CountryRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CountryRefType


class refLocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AffinePlacement=None):
        self.AffinePlacement = AffinePlacement
    def factory(*args_, **kwargs_):
        if refLocationType.subclass:
            return refLocationType.subclass(*args_, **kwargs_)
        else:
            return refLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AffinePlacement(self): return self.AffinePlacement
    def set_AffinePlacement(self, AffinePlacement): self.AffinePlacement = AffinePlacement
    def export(self, outfile, level, namespace_='', name_='refLocationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refLocationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refLocationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='refLocationType', fromsubclass_=False):
        if self.AffinePlacement is not None:
            self.AffinePlacement.export(outfile, level, namespace_, name_='AffinePlacement', )
    def hasContent_(self):
        if (
            self.AffinePlacement is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='refLocationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AffinePlacement is not None:
            showIndent(outfile, level)
            outfile.write('AffinePlacement=model_.AffinePlacement(\n')
            self.AffinePlacement.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AffinePlacement':
            obj_ = AffinePlacementType.factory()
            obj_.build(child_)
            self.set_AffinePlacement(obj_)
# end class refLocationType


class rowsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Row=None):
        if Row is None:
            self.Row = []
        else:
            self.Row = Row
    def factory(*args_, **kwargs_):
        if rowsType.subclass:
            return rowsType.subclass(*args_, **kwargs_)
        else:
            return rowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Row(self): return self.Row
    def set_Row(self, Row): self.Row = Row
    def add_Row(self, value): self.Row.append(value)
    def insert_Row(self, index, value): self.Row[index] = value
    def export(self, outfile, level, namespace_='', name_='rowsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rowsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rowsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='rowsType', fromsubclass_=False):
        for Row_ in self.Row:
            Row_.export(outfile, level, namespace_, name_='Row')
    def hasContent_(self):
        if (
            self.Row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rowsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Row=[\n')
        level += 1
        for Row_ in self.Row:
            showIndent(outfile, level)
            outfile.write('model_.RowType(\n')
            Row_.exportLiteral(outfile, level, name_='RowType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Row':
            obj_ = RowType.factory()
            obj_.build(child_)
            self.Row.append(obj_)
# end class rowsType


class RowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, posList=None, pos=None, pointProperty=None):
        self.posList = posList
        self.pos = pos
        self.pointProperty = pointProperty
    def factory(*args_, **kwargs_):
        if RowType.subclass:
            return RowType.subclass(*args_, **kwargs_)
        else:
            return RowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def export(self, outfile, level, namespace_='', name_='RowType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RowType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RowType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RowType', fromsubclass_=False):
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.pos is not None:
            self.pos.export(outfile, level, namespace_, name_='pos', )
        if self.pointProperty is not None:
            self.pointProperty.export(outfile, level, namespace_, name_='pointProperty', )
    def hasContent_(self):
        if (
            self.posList is not None or
            self.pos is not None or
            self.pointProperty is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RowType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=model_.pos(\n')
            self.pos.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointProperty is not None:
            showIndent(outfile, level)
            outfile.write('pointProperty=model_.pointProperty(\n')
            self.pointProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_pos(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_pointProperty(obj_)
# end class RowType


class rowsType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Row=None):
        if Row is None:
            self.Row = []
        else:
            self.Row = Row
    def factory(*args_, **kwargs_):
        if rowsType1.subclass:
            return rowsType1.subclass(*args_, **kwargs_)
        else:
            return rowsType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Row(self): return self.Row
    def set_Row(self, Row): self.Row = Row
    def add_Row(self, value): self.Row.append(value)
    def insert_Row(self, index, value): self.Row[index] = value
    def export(self, outfile, level, namespace_='', name_='rowsType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rowsType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rowsType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='rowsType1', fromsubclass_=False):
        for Row_ in self.Row:
            Row_.export(outfile, level, namespace_, name_='Row')
    def hasContent_(self):
        if (
            self.Row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rowsType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Row=[\n')
        level += 1
        for Row_ in self.Row:
            showIndent(outfile, level)
            outfile.write('model_.RowType1(\n')
            Row_.exportLiteral(outfile, level, name_='RowType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Row':
            obj_ = RowType1.factory()
            obj_.build(child_)
            self.Row.append(obj_)
# end class rowsType1


class RowType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, posList=None, pos=None, pointProperty=None):
        self.posList = posList
        self.pos = pos
        self.pointProperty = pointProperty
    def factory(*args_, **kwargs_):
        if RowType1.subclass:
            return RowType1.subclass(*args_, **kwargs_)
        else:
            return RowType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def export(self, outfile, level, namespace_='', name_='RowType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RowType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RowType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RowType1', fromsubclass_=False):
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.pos is not None:
            self.pos.export(outfile, level, namespace_, name_='pos', )
        if self.pointProperty is not None:
            self.pointProperty.export(outfile, level, namespace_, name_='pointProperty', )
    def hasContent_(self):
        if (
            self.posList is not None or
            self.pos is not None or
            self.pointProperty is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RowType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=model_.pos(\n')
            self.pos.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointProperty is not None:
            showIndent(outfile, level)
            outfile.write('pointProperty=model_.pointProperty(\n')
            self.pointProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_pos(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_pointProperty(obj_)
# end class RowType1


class controlPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, posList=None, pos=None, pointProperty=None):
        self.posList = posList
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
    def factory(*args_, **kwargs_):
        if controlPointType.subclass:
            return controlPointType.subclass(*args_, **kwargs_)
        else:
            return controlPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def export(self, outfile, level, namespace_='', name_='controlPointType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='controlPointType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='controlPointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='controlPointType', fromsubclass_=False):
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
    def hasContent_(self):
        if (
            self.posList is not None or
            self.pos or
            self.pointProperty
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='controlPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
# end class controlPointType


class TemporalDatumType(TemporalDatumBaseType):
    subclass = None
    superclass = TemporalDatumBaseType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, origin=None):
        super(TemporalDatumType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.origin = origin
    def factory(*args_, **kwargs_):
        if TemporalDatumType.subclass:
            return TemporalDatumType.subclass(*args_, **kwargs_)
        else:
            return TemporalDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def export(self, outfile, level, namespace_='', name_='TemporalDatumType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalDatumType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TemporalDatumType'):
        super(TemporalDatumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalDatumType')
    def exportChildren(self, outfile, level, namespace_='', name_='TemporalDatumType', fromsubclass_=False):
        super(TemporalDatumType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('<%sorigin>%s</%sorigin>\n' % (namespace_, self.gds_format_string(quote_xml(self.origin).encode(ExternalEncoding), input_name='origin'), namespace_))
    def hasContent_(self):
        if (
            self.origin is not None or
            super(TemporalDatumType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TemporalDatumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TemporalDatumType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TemporalDatumType, self).exportLiteralChildren(outfile, level, name_)
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=%s,\n' % quote_python(self.origin).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TemporalDatumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            origin_ = child_.text
            origin_ = self.gds_validate_string(origin_, node, 'origin')
            self.origin = origin_
        super(TemporalDatumType, self).buildChildren(child_, node, nodeName_, True)
# end class TemporalDatumType


class AbstractDQ_Completeness_Type(AbstractDQ_Element_Type):
    subclass = None
    superclass = AbstractDQ_Element_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None, extensiontype_=None):
        super(AbstractDQ_Completeness_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDQ_Completeness_Type.subclass:
            return AbstractDQ_Completeness_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_Completeness_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDQ_Completeness_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Completeness_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDQ_Completeness_Type'):
        super(AbstractDQ_Completeness_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_Completeness_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDQ_Completeness_Type', fromsubclass_=False):
        super(AbstractDQ_Completeness_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractDQ_Completeness_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDQ_Completeness_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDQ_Completeness_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDQ_Completeness_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_Completeness_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_Completeness_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_Completeness_Type


class AbstractDQ_LogicalConsistency_Type(AbstractDQ_Element_Type):
    subclass = None
    superclass = AbstractDQ_Element_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None, extensiontype_=None):
        super(AbstractDQ_LogicalConsistency_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDQ_LogicalConsistency_Type.subclass:
            return AbstractDQ_LogicalConsistency_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_LogicalConsistency_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDQ_LogicalConsistency_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_LogicalConsistency_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDQ_LogicalConsistency_Type'):
        super(AbstractDQ_LogicalConsistency_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_LogicalConsistency_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDQ_LogicalConsistency_Type', fromsubclass_=False):
        super(AbstractDQ_LogicalConsistency_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractDQ_LogicalConsistency_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDQ_LogicalConsistency_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDQ_LogicalConsistency_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDQ_LogicalConsistency_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_LogicalConsistency_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_LogicalConsistency_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_LogicalConsistency_Type


class AbstractDQ_PositionalAccuracy_Type(AbstractDQ_Element_Type):
    subclass = None
    superclass = AbstractDQ_Element_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None, extensiontype_=None):
        super(AbstractDQ_PositionalAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDQ_PositionalAccuracy_Type.subclass:
            return AbstractDQ_PositionalAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_PositionalAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDQ_PositionalAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_PositionalAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDQ_PositionalAccuracy_Type'):
        super(AbstractDQ_PositionalAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_PositionalAccuracy_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDQ_PositionalAccuracy_Type', fromsubclass_=False):
        super(AbstractDQ_PositionalAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractDQ_PositionalAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDQ_PositionalAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDQ_PositionalAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDQ_PositionalAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_PositionalAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_PositionalAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_PositionalAccuracy_Type


class AbstractDQ_ThematicAccuracy_Type(AbstractDQ_Element_Type):
    subclass = None
    superclass = AbstractDQ_Element_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None, extensiontype_=None):
        super(AbstractDQ_ThematicAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDQ_ThematicAccuracy_Type.subclass:
            return AbstractDQ_ThematicAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_ThematicAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDQ_ThematicAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_ThematicAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDQ_ThematicAccuracy_Type'):
        super(AbstractDQ_ThematicAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_ThematicAccuracy_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDQ_ThematicAccuracy_Type', fromsubclass_=False):
        super(AbstractDQ_ThematicAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractDQ_ThematicAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDQ_ThematicAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDQ_ThematicAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDQ_ThematicAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_ThematicAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_ThematicAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_ThematicAccuracy_Type


class AbstractDQ_TemporalAccuracy_Type(AbstractDQ_Element_Type):
    subclass = None
    superclass = AbstractDQ_Element_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None, extensiontype_=None):
        super(AbstractDQ_TemporalAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDQ_TemporalAccuracy_Type.subclass:
            return AbstractDQ_TemporalAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDQ_TemporalAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDQ_TemporalAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_TemporalAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDQ_TemporalAccuracy_Type'):
        super(AbstractDQ_TemporalAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDQ_TemporalAccuracy_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDQ_TemporalAccuracy_Type', fromsubclass_=False):
        super(AbstractDQ_TemporalAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractDQ_TemporalAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDQ_TemporalAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDQ_TemporalAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDQ_TemporalAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDQ_TemporalAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractDQ_TemporalAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractDQ_TemporalAccuracy_Type


class DQ_CompletenessCommission_Type(AbstractDQ_Completeness_Type):
    subclass = None
    superclass = AbstractDQ_Completeness_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_CompletenessCommission_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_CompletenessCommission_Type.subclass:
            return DQ_CompletenessCommission_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_CompletenessCommission_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_CompletenessCommission_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_CompletenessCommission_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_CompletenessCommission_Type'):
        super(DQ_CompletenessCommission_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_CompletenessCommission_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_CompletenessCommission_Type', fromsubclass_=False):
        super(DQ_CompletenessCommission_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_CompletenessCommission_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_CompletenessCommission_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_CompletenessCommission_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_CompletenessCommission_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_CompletenessCommission_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_CompletenessCommission_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_CompletenessCommission_Type


class DQ_CompletenessOmission_Type(AbstractDQ_Completeness_Type):
    subclass = None
    superclass = AbstractDQ_Completeness_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_CompletenessOmission_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_CompletenessOmission_Type.subclass:
            return DQ_CompletenessOmission_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_CompletenessOmission_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_CompletenessOmission_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_CompletenessOmission_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_CompletenessOmission_Type'):
        super(DQ_CompletenessOmission_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_CompletenessOmission_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_CompletenessOmission_Type', fromsubclass_=False):
        super(DQ_CompletenessOmission_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_CompletenessOmission_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_CompletenessOmission_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_CompletenessOmission_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_CompletenessOmission_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_CompletenessOmission_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_CompletenessOmission_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_CompletenessOmission_Type


class DQ_ConceptualConsistency_Type(AbstractDQ_LogicalConsistency_Type):
    subclass = None
    superclass = AbstractDQ_LogicalConsistency_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_ConceptualConsistency_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_ConceptualConsistency_Type.subclass:
            return DQ_ConceptualConsistency_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_ConceptualConsistency_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_ConceptualConsistency_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ConceptualConsistency_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_ConceptualConsistency_Type'):
        super(DQ_ConceptualConsistency_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ConceptualConsistency_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_ConceptualConsistency_Type', fromsubclass_=False):
        super(DQ_ConceptualConsistency_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_ConceptualConsistency_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_ConceptualConsistency_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_ConceptualConsistency_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_ConceptualConsistency_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_ConceptualConsistency_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_ConceptualConsistency_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_ConceptualConsistency_Type


class DQ_DomainConsistency_Type(AbstractDQ_LogicalConsistency_Type):
    subclass = None
    superclass = AbstractDQ_LogicalConsistency_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_DomainConsistency_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_DomainConsistency_Type.subclass:
            return DQ_DomainConsistency_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_DomainConsistency_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_DomainConsistency_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_DomainConsistency_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_DomainConsistency_Type'):
        super(DQ_DomainConsistency_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_DomainConsistency_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_DomainConsistency_Type', fromsubclass_=False):
        super(DQ_DomainConsistency_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_DomainConsistency_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_DomainConsistency_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_DomainConsistency_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_DomainConsistency_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_DomainConsistency_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_DomainConsistency_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_DomainConsistency_Type


class DQ_FormatConsistency_Type(AbstractDQ_LogicalConsistency_Type):
    subclass = None
    superclass = AbstractDQ_LogicalConsistency_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_FormatConsistency_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_FormatConsistency_Type.subclass:
            return DQ_FormatConsistency_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_FormatConsistency_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_FormatConsistency_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_FormatConsistency_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_FormatConsistency_Type'):
        super(DQ_FormatConsistency_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_FormatConsistency_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_FormatConsistency_Type', fromsubclass_=False):
        super(DQ_FormatConsistency_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_FormatConsistency_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_FormatConsistency_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_FormatConsistency_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_FormatConsistency_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_FormatConsistency_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_FormatConsistency_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_FormatConsistency_Type


class DQ_TopologicalConsistency_Type(AbstractDQ_LogicalConsistency_Type):
    subclass = None
    superclass = AbstractDQ_LogicalConsistency_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_TopologicalConsistency_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_TopologicalConsistency_Type.subclass:
            return DQ_TopologicalConsistency_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_TopologicalConsistency_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_TopologicalConsistency_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TopologicalConsistency_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_TopologicalConsistency_Type'):
        super(DQ_TopologicalConsistency_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TopologicalConsistency_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_TopologicalConsistency_Type', fromsubclass_=False):
        super(DQ_TopologicalConsistency_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_TopologicalConsistency_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_TopologicalConsistency_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_TopologicalConsistency_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_TopologicalConsistency_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_TopologicalConsistency_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_TopologicalConsistency_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_TopologicalConsistency_Type


class DQ_AbsoluteExternalPositionalAccuracy_Type(AbstractDQ_PositionalAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_PositionalAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_AbsoluteExternalPositionalAccuracy_Type.subclass:
            return DQ_AbsoluteExternalPositionalAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_AbsoluteExternalPositionalAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_AbsoluteExternalPositionalAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_AbsoluteExternalPositionalAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_AbsoluteExternalPositionalAccuracy_Type'):
        super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_AbsoluteExternalPositionalAccuracy_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_AbsoluteExternalPositionalAccuracy_Type', fromsubclass_=False):
        super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_AbsoluteExternalPositionalAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_AbsoluteExternalPositionalAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_AbsoluteExternalPositionalAccuracy_Type


class DQ_GriddedDataPositionalAccuracy_Type(AbstractDQ_PositionalAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_PositionalAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_GriddedDataPositionalAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_GriddedDataPositionalAccuracy_Type.subclass:
            return DQ_GriddedDataPositionalAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_GriddedDataPositionalAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_GriddedDataPositionalAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_GriddedDataPositionalAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_GriddedDataPositionalAccuracy_Type'):
        super(DQ_GriddedDataPositionalAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_GriddedDataPositionalAccuracy_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_GriddedDataPositionalAccuracy_Type', fromsubclass_=False):
        super(DQ_GriddedDataPositionalAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_GriddedDataPositionalAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_GriddedDataPositionalAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_GriddedDataPositionalAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_GriddedDataPositionalAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_GriddedDataPositionalAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_GriddedDataPositionalAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_GriddedDataPositionalAccuracy_Type


class DQ_RelativeInternalPositionalAccuracy_Type(AbstractDQ_PositionalAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_PositionalAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_RelativeInternalPositionalAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_RelativeInternalPositionalAccuracy_Type.subclass:
            return DQ_RelativeInternalPositionalAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_RelativeInternalPositionalAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_RelativeInternalPositionalAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_RelativeInternalPositionalAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_RelativeInternalPositionalAccuracy_Type'):
        super(DQ_RelativeInternalPositionalAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_RelativeInternalPositionalAccuracy_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_RelativeInternalPositionalAccuracy_Type', fromsubclass_=False):
        super(DQ_RelativeInternalPositionalAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_RelativeInternalPositionalAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_RelativeInternalPositionalAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_RelativeInternalPositionalAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_RelativeInternalPositionalAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_RelativeInternalPositionalAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_RelativeInternalPositionalAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_RelativeInternalPositionalAccuracy_Type


class DQ_ThematicClassificationCorrectness_Type(AbstractDQ_ThematicAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_ThematicAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_ThematicClassificationCorrectness_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_ThematicClassificationCorrectness_Type.subclass:
            return DQ_ThematicClassificationCorrectness_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_ThematicClassificationCorrectness_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_ThematicClassificationCorrectness_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ThematicClassificationCorrectness_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_ThematicClassificationCorrectness_Type'):
        super(DQ_ThematicClassificationCorrectness_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ThematicClassificationCorrectness_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_ThematicClassificationCorrectness_Type', fromsubclass_=False):
        super(DQ_ThematicClassificationCorrectness_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_ThematicClassificationCorrectness_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_ThematicClassificationCorrectness_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_ThematicClassificationCorrectness_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_ThematicClassificationCorrectness_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_ThematicClassificationCorrectness_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_ThematicClassificationCorrectness_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_ThematicClassificationCorrectness_Type


class DQ_NonQuantitativeAttributeAccuracy_Type(AbstractDQ_ThematicAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_ThematicAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_NonQuantitativeAttributeAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_NonQuantitativeAttributeAccuracy_Type.subclass:
            return DQ_NonQuantitativeAttributeAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_NonQuantitativeAttributeAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_NonQuantitativeAttributeAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_NonQuantitativeAttributeAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_NonQuantitativeAttributeAccuracy_Type'):
        super(DQ_NonQuantitativeAttributeAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_NonQuantitativeAttributeAccuracy_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_NonQuantitativeAttributeAccuracy_Type', fromsubclass_=False):
        super(DQ_NonQuantitativeAttributeAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_NonQuantitativeAttributeAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_NonQuantitativeAttributeAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_NonQuantitativeAttributeAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_NonQuantitativeAttributeAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_NonQuantitativeAttributeAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_NonQuantitativeAttributeAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_NonQuantitativeAttributeAccuracy_Type


class DQ_QuantitativeAttributeAccuracy_Type(AbstractDQ_ThematicAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_ThematicAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_QuantitativeAttributeAccuracy_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_QuantitativeAttributeAccuracy_Type.subclass:
            return DQ_QuantitativeAttributeAccuracy_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_QuantitativeAttributeAccuracy_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_QuantitativeAttributeAccuracy_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_QuantitativeAttributeAccuracy_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_QuantitativeAttributeAccuracy_Type'):
        super(DQ_QuantitativeAttributeAccuracy_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_QuantitativeAttributeAccuracy_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_QuantitativeAttributeAccuracy_Type', fromsubclass_=False):
        super(DQ_QuantitativeAttributeAccuracy_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_QuantitativeAttributeAccuracy_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_QuantitativeAttributeAccuracy_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_QuantitativeAttributeAccuracy_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_QuantitativeAttributeAccuracy_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_QuantitativeAttributeAccuracy_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_QuantitativeAttributeAccuracy_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_QuantitativeAttributeAccuracy_Type


class DQ_AccuracyOfATimeMeasurement_Type(AbstractDQ_TemporalAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_TemporalAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_AccuracyOfATimeMeasurement_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_AccuracyOfATimeMeasurement_Type.subclass:
            return DQ_AccuracyOfATimeMeasurement_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_AccuracyOfATimeMeasurement_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_AccuracyOfATimeMeasurement_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_AccuracyOfATimeMeasurement_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_AccuracyOfATimeMeasurement_Type'):
        super(DQ_AccuracyOfATimeMeasurement_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_AccuracyOfATimeMeasurement_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_AccuracyOfATimeMeasurement_Type', fromsubclass_=False):
        super(DQ_AccuracyOfATimeMeasurement_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_AccuracyOfATimeMeasurement_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_AccuracyOfATimeMeasurement_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_AccuracyOfATimeMeasurement_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_AccuracyOfATimeMeasurement_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_AccuracyOfATimeMeasurement_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_AccuracyOfATimeMeasurement_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_AccuracyOfATimeMeasurement_Type


class DQ_TemporalConsistency_Type(AbstractDQ_TemporalAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_TemporalAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_TemporalConsistency_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_TemporalConsistency_Type.subclass:
            return DQ_TemporalConsistency_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_TemporalConsistency_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_TemporalConsistency_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TemporalConsistency_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_TemporalConsistency_Type'):
        super(DQ_TemporalConsistency_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TemporalConsistency_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_TemporalConsistency_Type', fromsubclass_=False):
        super(DQ_TemporalConsistency_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_TemporalConsistency_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_TemporalConsistency_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_TemporalConsistency_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_TemporalConsistency_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_TemporalConsistency_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_TemporalConsistency_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_TemporalConsistency_Type


class DQ_TemporalValidity_Type(AbstractDQ_TemporalAccuracy_Type):
    subclass = None
    superclass = AbstractDQ_TemporalAccuracy_Type
    def __init__(self, id=None, uuid=None, nameOfMeasure=None, measureIdentification=None, measureDescription=None, evaluationMethodType=None, evaluationMethodDescription=None, evaluationProcedure=None, dateTime=None, result=None):
        super(DQ_TemporalValidity_Type, self).__init__(id, uuid, nameOfMeasure, measureIdentification, measureDescription, evaluationMethodType, evaluationMethodDescription, evaluationProcedure, dateTime, result, )
        pass
    def factory(*args_, **kwargs_):
        if DQ_TemporalValidity_Type.subclass:
            return DQ_TemporalValidity_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_TemporalValidity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DQ_TemporalValidity_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TemporalValidity_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_TemporalValidity_Type'):
        super(DQ_TemporalValidity_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_TemporalValidity_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_TemporalValidity_Type', fromsubclass_=False):
        super(DQ_TemporalValidity_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DQ_TemporalValidity_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_TemporalValidity_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_TemporalValidity_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_TemporalValidity_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_TemporalValidity_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DQ_TemporalValidity_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DQ_TemporalValidity_Type


class DQ_QuantitativeResult_Type(AbstractDQ_Result_Type):
    """Quantitative_conformance_measure from Quality Procedures. - -
    Renamed to remove implied use limitation - - OCL - -- result is
    type specified by valueDomain - result.tupleType = valueDomain"""
    subclass = None
    superclass = AbstractDQ_Result_Type
    def __init__(self, id=None, uuid=None, valueType=None, valueUnit=None, errorStatistic=None, value=None):
        super(DQ_QuantitativeResult_Type, self).__init__(id, uuid, )
        self.valueType = valueType
        self.valueUnit = valueUnit
        self.errorStatistic = errorStatistic
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if DQ_QuantitativeResult_Type.subclass:
            return DQ_QuantitativeResult_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_QuantitativeResult_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueType(self): return self.valueType
    def set_valueType(self, valueType): self.valueType = valueType
    def get_valueUnit(self): return self.valueUnit
    def set_valueUnit(self, valueUnit): self.valueUnit = valueUnit
    def get_errorStatistic(self): return self.errorStatistic
    def set_errorStatistic(self, errorStatistic): self.errorStatistic = errorStatistic
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def export(self, outfile, level, namespace_='', name_='DQ_QuantitativeResult_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_QuantitativeResult_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_QuantitativeResult_Type'):
        super(DQ_QuantitativeResult_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_QuantitativeResult_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_QuantitativeResult_Type', fromsubclass_=False):
        super(DQ_QuantitativeResult_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.valueType is not None:
            self.valueType.export(outfile, level, namespace_, name_='valueType')
        if self.valueUnit is not None:
            self.valueUnit.export(outfile, level, namespace_, name_='valueUnit', )
        if self.errorStatistic is not None:
            self.errorStatistic.export(outfile, level, namespace_, name_='errorStatistic')
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
    def hasContent_(self):
        if (
            self.valueType is not None or
            self.valueUnit is not None or
            self.errorStatistic is not None or
            self.value or
            super(DQ_QuantitativeResult_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_QuantitativeResult_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_QuantitativeResult_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_QuantitativeResult_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.valueType is not None:
            showIndent(outfile, level)
            outfile.write('valueType=model_.RecordType_PropertyType(\n')
            self.valueType.exportLiteral(outfile, level, name_='valueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.valueUnit is not None:
            showIndent(outfile, level)
            outfile.write('valueUnit=model_.UnitOfMeasure_PropertyType(\n')
            self.valueUnit.exportLiteral(outfile, level, name_='valueUnit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.errorStatistic is not None:
            showIndent(outfile, level)
            outfile.write('errorStatistic=model_.CharacterString_PropertyType(\n')
            self.errorStatistic.exportLiteral(outfile, level, name_='errorStatistic')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.Record_PropertyType(\n')
            value_.exportLiteral(outfile, level, name_='Record_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_QuantitativeResult_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'valueType':
            obj_ = RecordType_PropertyType.factory()
            obj_.build(child_)
            self.set_valueType(obj_)
        elif nodeName_ == 'valueUnit':
            obj_ = UnitOfMeasure_PropertyType.factory()
            obj_.build(child_)
            self.set_valueUnit(obj_)
        elif nodeName_ == 'errorStatistic':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_errorStatistic(obj_)
        elif nodeName_ == 'value':
            obj_ = Record_PropertyType.factory()
            obj_.build(child_)
            self.value.append(obj_)
        super(DQ_QuantitativeResult_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DQ_QuantitativeResult_Type


class DQ_ConformanceResult_Type(AbstractDQ_Result_Type):
    """quantitative_result from Quality Procedures - - renamed to remove
    implied use limitiation."""
    subclass = None
    superclass = AbstractDQ_Result_Type
    def __init__(self, id=None, uuid=None, specification=None, explanation=None, passxx=None):
        super(DQ_ConformanceResult_Type, self).__init__(id, uuid, )
        self.specification = specification
        self.explanation = explanation
        self.passxx = passxx
    def factory(*args_, **kwargs_):
        if DQ_ConformanceResult_Type.subclass:
            return DQ_ConformanceResult_Type.subclass(*args_, **kwargs_)
        else:
            return DQ_ConformanceResult_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specification(self): return self.specification
    def set_specification(self, specification): self.specification = specification
    def get_explanation(self): return self.explanation
    def set_explanation(self, explanation): self.explanation = explanation
    def get_pass(self): return self.passxx
    def set_pass(self, passxx): self.passxx = passxx
    def export(self, outfile, level, namespace_='', name_='DQ_ConformanceResult_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ConformanceResult_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DQ_ConformanceResult_Type'):
        super(DQ_ConformanceResult_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DQ_ConformanceResult_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DQ_ConformanceResult_Type', fromsubclass_=False):
        super(DQ_ConformanceResult_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.specification is not None:
            self.specification.export(outfile, level, namespace_, name_='specification', )
        if self.explanation is not None:
            self.explanation.export(outfile, level, namespace_, name_='explanation', )
        if self.passxx is not None:
            self.passxx.export(outfile, level, namespace_, name_='pass', )
    def hasContent_(self):
        if (
            self.specification is not None or
            self.explanation is not None or
            self.passxx is not None or
            super(DQ_ConformanceResult_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DQ_ConformanceResult_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DQ_ConformanceResult_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DQ_ConformanceResult_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.specification is not None:
            showIndent(outfile, level)
            outfile.write('specification=model_.CI_Citation_PropertyType(\n')
            self.specification.exportLiteral(outfile, level, name_='specification')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.explanation is not None:
            showIndent(outfile, level)
            outfile.write('explanation=model_.CharacterString_PropertyType(\n')
            self.explanation.exportLiteral(outfile, level, name_='explanation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.passxx is not None:
            showIndent(outfile, level)
            outfile.write('passxx=model_.Boolean_PropertyType(\n')
            self.passxx.exportLiteral(outfile, level, name_='pass')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DQ_ConformanceResult_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'specification':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_specification(obj_)
        elif nodeName_ == 'explanation':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_explanation(obj_)
        elif nodeName_ == 'pass':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_pass(obj_)
        super(DQ_ConformanceResult_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DQ_ConformanceResult_Type


class MD_CoverageDescription_Type(AbstractMD_ContentInformation_Type):
    """Information about the domain of the raster cell"""
    subclass = None
    superclass = AbstractMD_ContentInformation_Type
    def __init__(self, id=None, uuid=None, attributeDescription=None, contentType=None, dimension=None, extensiontype_=None):
        super(MD_CoverageDescription_Type, self).__init__(id, uuid, extensiontype_, )
        self.attributeDescription = attributeDescription
        self.contentType = contentType
        if dimension is None:
            self.dimension = []
        else:
            self.dimension = dimension
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MD_CoverageDescription_Type.subclass:
            return MD_CoverageDescription_Type.subclass(*args_, **kwargs_)
        else:
            return MD_CoverageDescription_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attributeDescription(self): return self.attributeDescription
    def set_attributeDescription(self, attributeDescription): self.attributeDescription = attributeDescription
    def get_contentType(self): return self.contentType
    def set_contentType(self, contentType): self.contentType = contentType
    def get_dimension(self): return self.dimension
    def set_dimension(self, dimension): self.dimension = dimension
    def add_dimension(self, value): self.dimension.append(value)
    def insert_dimension(self, index, value): self.dimension[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MD_CoverageDescription_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_CoverageDescription_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_CoverageDescription_Type'):
        super(MD_CoverageDescription_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_CoverageDescription_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MD_CoverageDescription_Type', fromsubclass_=False):
        super(MD_CoverageDescription_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.attributeDescription is not None:
            self.attributeDescription.export(outfile, level, namespace_, name_='attributeDescription', )
        if self.contentType is not None:
            self.contentType.export(outfile, level, namespace_, name_='contentType', )
        for dimension_ in self.dimension:
            dimension_.export(outfile, level, namespace_, name_='dimension')
    def hasContent_(self):
        if (
            self.attributeDescription is not None or
            self.contentType is not None or
            self.dimension or
            super(MD_CoverageDescription_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_CoverageDescription_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_CoverageDescription_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_CoverageDescription_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.attributeDescription is not None:
            showIndent(outfile, level)
            outfile.write('attributeDescription=model_.RecordType_PropertyType(\n')
            self.attributeDescription.exportLiteral(outfile, level, name_='attributeDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contentType is not None:
            showIndent(outfile, level)
            outfile.write('contentType=model_.MD_CoverageContentTypeCode_PropertyType(\n')
            self.contentType.exportLiteral(outfile, level, name_='contentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('dimension=[\n')
        level += 1
        for dimension_ in self.dimension:
            showIndent(outfile, level)
            outfile.write('model_.MD_RangeDimension_PropertyType(\n')
            dimension_.exportLiteral(outfile, level, name_='MD_RangeDimension_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(MD_CoverageDescription_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attributeDescription':
            obj_ = RecordType_PropertyType.factory()
            obj_.build(child_)
            self.set_attributeDescription(obj_)
        elif nodeName_ == 'contentType':
            obj_ = MD_CoverageContentTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_contentType(obj_)
        elif nodeName_ == 'dimension':
            obj_ = MD_RangeDimension_PropertyType.factory()
            obj_.build(child_)
            self.dimension.append(obj_)
        super(MD_CoverageDescription_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_CoverageDescription_Type


class MD_FeatureCatalogueDescription_Type(AbstractMD_ContentInformation_Type):
    """Information identifing the feature catalogue"""
    subclass = None
    superclass = AbstractMD_ContentInformation_Type
    def __init__(self, id=None, uuid=None, complianceCode=None, language=None, includedWithDataset=None, featureTypes=None, featureCatalogueCitation=None):
        super(MD_FeatureCatalogueDescription_Type, self).__init__(id, uuid, )
        self.complianceCode = complianceCode
        if language is None:
            self.language = []
        else:
            self.language = language
        self.includedWithDataset = includedWithDataset
        if featureTypes is None:
            self.featureTypes = []
        else:
            self.featureTypes = featureTypes
        if featureCatalogueCitation is None:
            self.featureCatalogueCitation = []
        else:
            self.featureCatalogueCitation = featureCatalogueCitation
    def factory(*args_, **kwargs_):
        if MD_FeatureCatalogueDescription_Type.subclass:
            return MD_FeatureCatalogueDescription_Type.subclass(*args_, **kwargs_)
        else:
            return MD_FeatureCatalogueDescription_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_complianceCode(self): return self.complianceCode
    def set_complianceCode(self, complianceCode): self.complianceCode = complianceCode
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language(self, index, value): self.language[index] = value
    def get_includedWithDataset(self): return self.includedWithDataset
    def set_includedWithDataset(self, includedWithDataset): self.includedWithDataset = includedWithDataset
    def get_featureTypes(self): return self.featureTypes
    def set_featureTypes(self, featureTypes): self.featureTypes = featureTypes
    def add_featureTypes(self, value): self.featureTypes.append(value)
    def insert_featureTypes(self, index, value): self.featureTypes[index] = value
    def get_featureCatalogueCitation(self): return self.featureCatalogueCitation
    def set_featureCatalogueCitation(self, featureCatalogueCitation): self.featureCatalogueCitation = featureCatalogueCitation
    def add_featureCatalogueCitation(self, value): self.featureCatalogueCitation.append(value)
    def insert_featureCatalogueCitation(self, index, value): self.featureCatalogueCitation[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_FeatureCatalogueDescription_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_FeatureCatalogueDescription_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_FeatureCatalogueDescription_Type'):
        super(MD_FeatureCatalogueDescription_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_FeatureCatalogueDescription_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_FeatureCatalogueDescription_Type', fromsubclass_=False):
        super(MD_FeatureCatalogueDescription_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.complianceCode is not None:
            self.complianceCode.export(outfile, level, namespace_, name_='complianceCode')
        for language_ in self.language:
            language_.export(outfile, level, namespace_, name_='language')
        if self.includedWithDataset is not None:
            self.includedWithDataset.export(outfile, level, namespace_, name_='includedWithDataset', )
        for featureTypes_ in self.featureTypes:
            featureTypes_.export(outfile, level, namespace_, name_='featureTypes')
        for featureCatalogueCitation_ in self.featureCatalogueCitation:
            featureCatalogueCitation_.export(outfile, level, namespace_, name_='featureCatalogueCitation')
    def hasContent_(self):
        if (
            self.complianceCode is not None or
            self.language or
            self.includedWithDataset is not None or
            self.featureTypes or
            self.featureCatalogueCitation or
            super(MD_FeatureCatalogueDescription_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_FeatureCatalogueDescription_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_FeatureCatalogueDescription_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_FeatureCatalogueDescription_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.complianceCode is not None:
            showIndent(outfile, level)
            outfile.write('complianceCode=model_.Boolean_PropertyType(\n')
            self.complianceCode.exportLiteral(outfile, level, name_='complianceCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('language=[\n')
        level += 1
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            language_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.includedWithDataset is not None:
            showIndent(outfile, level)
            outfile.write('includedWithDataset=model_.Boolean_PropertyType(\n')
            self.includedWithDataset.exportLiteral(outfile, level, name_='includedWithDataset')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('featureTypes=[\n')
        level += 1
        for featureTypes_ in self.featureTypes:
            showIndent(outfile, level)
            outfile.write('model_.GenericName_PropertyType(\n')
            featureTypes_.exportLiteral(outfile, level, name_='GenericName_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('featureCatalogueCitation=[\n')
        level += 1
        for featureCatalogueCitation_ in self.featureCatalogueCitation:
            showIndent(outfile, level)
            outfile.write('model_.CI_Citation_PropertyType(\n')
            featureCatalogueCitation_.exportLiteral(outfile, level, name_='CI_Citation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_FeatureCatalogueDescription_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'complianceCode':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_complianceCode(obj_)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.language.append(obj_)
        elif nodeName_ == 'includedWithDataset':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_includedWithDataset(obj_)
        elif nodeName_ == 'featureTypes':
            obj_ = GenericName_PropertyType.factory()
            obj_.build(child_)
            self.featureTypes.append(obj_)
        elif nodeName_ == 'featureCatalogueCitation':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.featureCatalogueCitation.append(obj_)
        super(MD_FeatureCatalogueDescription_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_FeatureCatalogueDescription_Type


class MultiplicityRange_Type(AbstractObject_Type):
    """A component of a multiplicity, consisting of an non-negative lower
    bound, and a potentially infinite upper bound."""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, lower=None, upper=None):
        super(MultiplicityRange_Type, self).__init__(id, uuid, )
        self.lower = lower
        self.upper = upper
    def factory(*args_, **kwargs_):
        if MultiplicityRange_Type.subclass:
            return MultiplicityRange_Type.subclass(*args_, **kwargs_)
        else:
            return MultiplicityRange_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lower(self): return self.lower
    def set_lower(self, lower): self.lower = lower
    def get_upper(self): return self.upper
    def set_upper(self, upper): self.upper = upper
    def export(self, outfile, level, namespace_='', name_='MultiplicityRange_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiplicityRange_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiplicityRange_Type'):
        super(MultiplicityRange_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MultiplicityRange_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MultiplicityRange_Type', fromsubclass_=False):
        super(MultiplicityRange_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.lower is not None:
            self.lower.export(outfile, level, namespace_, name_='lower', )
        if self.upper is not None:
            self.upper.export(outfile, level, namespace_, name_='upper', )
    def hasContent_(self):
        if (
            self.lower is not None or
            self.upper is not None or
            super(MultiplicityRange_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiplicityRange_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MultiplicityRange_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MultiplicityRange_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.lower is not None:
            showIndent(outfile, level)
            outfile.write('lower=model_.Integer_PropertyType(\n')
            self.lower.exportLiteral(outfile, level, name_='lower')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.upper is not None:
            showIndent(outfile, level)
            outfile.write('upper=model_.UnlimitedInteger_PropertyType(\n')
            self.upper.exportLiteral(outfile, level, name_='upper')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiplicityRange_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lower':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_lower(obj_)
        elif nodeName_ == 'upper':
            obj_ = UnlimitedInteger_PropertyType.factory()
            obj_.build(child_)
            self.set_upper(obj_)
        super(MultiplicityRange_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MultiplicityRange_Type


class Multiplicity_Type(AbstractObject_Type):
    """Use to represent the possible cardinality of a relation. Represented
    by a set of simple multiplicity ranges."""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, range=None):
        super(Multiplicity_Type, self).__init__(id, uuid, )
        if range is None:
            self.range = []
        else:
            self.range = range
    def factory(*args_, **kwargs_):
        if Multiplicity_Type.subclass:
            return Multiplicity_Type.subclass(*args_, **kwargs_)
        else:
            return Multiplicity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_range(self): return self.range
    def set_range(self, range): self.range = range
    def add_range(self, value): self.range.append(value)
    def insert_range(self, index, value): self.range[index] = value
    def export(self, outfile, level, namespace_='', name_='Multiplicity_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Multiplicity_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Multiplicity_Type'):
        super(Multiplicity_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Multiplicity_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='Multiplicity_Type', fromsubclass_=False):
        super(Multiplicity_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for range_ in self.range:
            range_.export(outfile, level, namespace_, name_='range')
    def hasContent_(self):
        if (
            self.range or
            super(Multiplicity_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Multiplicity_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Multiplicity_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Multiplicity_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('range=[\n')
        level += 1
        for range_ in self.range:
            showIndent(outfile, level)
            outfile.write('model_.MultiplicityRange_PropertyType(\n')
            range_.exportLiteral(outfile, level, name_='MultiplicityRange_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Multiplicity_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'range':
            obj_ = MultiplicityRange_PropertyType.factory()
            obj_.build(child_)
            self.range.append(obj_)
        super(Multiplicity_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Multiplicity_Type


class MemberName_Type(AbstractObject_Type):
    """A MemberName is a LocalName that references either an attribute slot
    in a record or recordType or an attribute, operation, or
    association role in an object instance or type description in
    some form of schema. The stored value "aName" is the returned
    value for the "aName()" operation."""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, aName=None, attributeType=None):
        super(MemberName_Type, self).__init__(id, uuid, )
        self.aName = aName
        self.attributeType = attributeType
    def factory(*args_, **kwargs_):
        if MemberName_Type.subclass:
            return MemberName_Type.subclass(*args_, **kwargs_)
        else:
            return MemberName_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aName(self): return self.aName
    def set_aName(self, aName): self.aName = aName
    def get_attributeType(self): return self.attributeType
    def set_attributeType(self, attributeType): self.attributeType = attributeType
    def export(self, outfile, level, namespace_='', name_='MemberName_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemberName_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MemberName_Type'):
        super(MemberName_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MemberName_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MemberName_Type', fromsubclass_=False):
        super(MemberName_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.aName is not None:
            self.aName.export(outfile, level, namespace_, name_='aName', )
        if self.attributeType is not None:
            self.attributeType.export(outfile, level, namespace_, name_='attributeType', )
    def hasContent_(self):
        if (
            self.aName is not None or
            self.attributeType is not None or
            super(MemberName_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MemberName_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MemberName_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MemberName_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.aName is not None:
            showIndent(outfile, level)
            outfile.write('aName=model_.CharacterString_PropertyType(\n')
            self.aName.exportLiteral(outfile, level, name_='aName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attributeType is not None:
            showIndent(outfile, level)
            outfile.write('attributeType=model_.TypeName_PropertyType(\n')
            self.attributeType.exportLiteral(outfile, level, name_='attributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MemberName_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_aName(obj_)
        elif nodeName_ == 'attributeType':
            obj_ = TypeName_PropertyType.factory()
            obj_.build(child_)
            self.set_attributeType(obj_)
        super(MemberName_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MemberName_Type


class TypeName_Type(AbstractObject_Type):
    """A TypeName is a LocalName that references either a recordType or
    object type in some form of schema. The stored value "aName" is
    the returned value for the "aName()" operation. This is the
    types name. - For parsing from types (or objects) the parsible
    name normally uses a "." navigation separator, so that it is of
    the form [class].[member].[memberOfMember]. ...)"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, aName=None):
        super(TypeName_Type, self).__init__(id, uuid, )
        self.aName = aName
    def factory(*args_, **kwargs_):
        if TypeName_Type.subclass:
            return TypeName_Type.subclass(*args_, **kwargs_)
        else:
            return TypeName_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aName(self): return self.aName
    def set_aName(self, aName): self.aName = aName
    def export(self, outfile, level, namespace_='', name_='TypeName_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeName_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TypeName_Type'):
        super(TypeName_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TypeName_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='TypeName_Type', fromsubclass_=False):
        super(TypeName_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.aName is not None:
            self.aName.export(outfile, level, namespace_, name_='aName', )
    def hasContent_(self):
        if (
            self.aName is not None or
            super(TypeName_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TypeName_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TypeName_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TypeName_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.aName is not None:
            showIndent(outfile, level)
            outfile.write('aName=model_.CharacterString_PropertyType(\n')
            self.aName.exportLiteral(outfile, level, name_='aName')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TypeName_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_aName(obj_)
        super(TypeName_Type, self).buildChildren(child_, node, nodeName_, True)
# end class TypeName_Type


class AbstractEX_GeographicExtent_Type(AbstractObject_Type):
    """Geographic area of the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extentTypeCode=None, extensiontype_=None):
        super(AbstractEX_GeographicExtent_Type, self).__init__(id, uuid, extensiontype_, )
        self.extentTypeCode = extentTypeCode
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractEX_GeographicExtent_Type.subclass:
            return AbstractEX_GeographicExtent_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractEX_GeographicExtent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extentTypeCode(self): return self.extentTypeCode
    def set_extentTypeCode(self, extentTypeCode): self.extentTypeCode = extentTypeCode
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractEX_GeographicExtent_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractEX_GeographicExtent_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractEX_GeographicExtent_Type'):
        super(AbstractEX_GeographicExtent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractEX_GeographicExtent_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractEX_GeographicExtent_Type', fromsubclass_=False):
        super(AbstractEX_GeographicExtent_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.extentTypeCode is not None:
            self.extentTypeCode.export(outfile, level, namespace_, name_='extentTypeCode')
    def hasContent_(self):
        if (
            self.extentTypeCode is not None or
            super(AbstractEX_GeographicExtent_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractEX_GeographicExtent_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractEX_GeographicExtent_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractEX_GeographicExtent_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.extentTypeCode is not None:
            showIndent(outfile, level)
            outfile.write('extentTypeCode=model_.Boolean_PropertyType(\n')
            self.extentTypeCode.exportLiteral(outfile, level, name_='extentTypeCode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractEX_GeographicExtent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'extentTypeCode':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_extentTypeCode(obj_)
        super(AbstractEX_GeographicExtent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractEX_GeographicExtent_Type


class EX_Extent_Type(AbstractObject_Type):
    """Information about spatial, vertical, and temporal extent"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, description=None, geographicElement=None, temporalElement=None, verticalElement=None):
        super(EX_Extent_Type, self).__init__(id, uuid, )
        self.description = description
        if geographicElement is None:
            self.geographicElement = []
        else:
            self.geographicElement = geographicElement
        if temporalElement is None:
            self.temporalElement = []
        else:
            self.temporalElement = temporalElement
        if verticalElement is None:
            self.verticalElement = []
        else:
            self.verticalElement = verticalElement
    def factory(*args_, **kwargs_):
        if EX_Extent_Type.subclass:
            return EX_Extent_Type.subclass(*args_, **kwargs_)
        else:
            return EX_Extent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_geographicElement(self): return self.geographicElement
    def set_geographicElement(self, geographicElement): self.geographicElement = geographicElement
    def add_geographicElement(self, value): self.geographicElement.append(value)
    def insert_geographicElement(self, index, value): self.geographicElement[index] = value
    def get_temporalElement(self): return self.temporalElement
    def set_temporalElement(self, temporalElement): self.temporalElement = temporalElement
    def add_temporalElement(self, value): self.temporalElement.append(value)
    def insert_temporalElement(self, index, value): self.temporalElement[index] = value
    def get_verticalElement(self): return self.verticalElement
    def set_verticalElement(self, verticalElement): self.verticalElement = verticalElement
    def add_verticalElement(self, value): self.verticalElement.append(value)
    def insert_verticalElement(self, index, value): self.verticalElement[index] = value
    def export(self, outfile, level, namespace_='', name_='EX_Extent_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_Extent_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_Extent_Type'):
        super(EX_Extent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_Extent_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EX_Extent_Type', fromsubclass_=False):
        super(EX_Extent_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        for geographicElement_ in self.geographicElement:
            geographicElement_.export(outfile, level, namespace_, name_='geographicElement')
        for temporalElement_ in self.temporalElement:
            temporalElement_.export(outfile, level, namespace_, name_='temporalElement')
        for verticalElement_ in self.verticalElement:
            verticalElement_.export(outfile, level, namespace_, name_='verticalElement')
    def hasContent_(self):
        if (
            self.description is not None or
            self.geographicElement or
            self.temporalElement or
            self.verticalElement or
            super(EX_Extent_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_Extent_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EX_Extent_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EX_Extent_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.CharacterString_PropertyType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('geographicElement=[\n')
        level += 1
        for geographicElement_ in self.geographicElement:
            showIndent(outfile, level)
            outfile.write('model_.EX_GeographicExtent_PropertyType(\n')
            geographicElement_.exportLiteral(outfile, level, name_='EX_GeographicExtent_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('temporalElement=[\n')
        level += 1
        for temporalElement_ in self.temporalElement:
            showIndent(outfile, level)
            outfile.write('model_.EX_TemporalExtent_PropertyType(\n')
            temporalElement_.exportLiteral(outfile, level, name_='EX_TemporalExtent_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('verticalElement=[\n')
        level += 1
        for verticalElement_ in self.verticalElement:
            showIndent(outfile, level)
            outfile.write('model_.EX_VerticalExtent_PropertyType(\n')
            verticalElement_.exportLiteral(outfile, level, name_='EX_VerticalExtent_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_Extent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'geographicElement':
            obj_ = EX_GeographicExtent_PropertyType.factory()
            obj_.build(child_)
            self.geographicElement.append(obj_)
        elif nodeName_ == 'temporalElement':
            obj_ = EX_TemporalExtent_PropertyType.factory()
            obj_.build(child_)
            self.temporalElement.append(obj_)
        elif nodeName_ == 'verticalElement':
            obj_ = EX_VerticalExtent_PropertyType.factory()
            obj_.build(child_)
            self.verticalElement.append(obj_)
        super(EX_Extent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_Extent_Type


class EX_BoundingPolygon_Type(AbstractEX_GeographicExtent_Type):
    """Boundary enclosing the dataset expressed as the closed set of (x,y)
    coordinates of the polygon (last point replicates first point)"""
    subclass = None
    superclass = AbstractEX_GeographicExtent_Type
    def __init__(self, id=None, uuid=None, extentTypeCode=None, polygon=None):
        super(EX_BoundingPolygon_Type, self).__init__(id, uuid, extentTypeCode, )
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
    def factory(*args_, **kwargs_):
        if EX_BoundingPolygon_Type.subclass:
            return EX_BoundingPolygon_Type.subclass(*args_, **kwargs_)
        else:
            return EX_BoundingPolygon_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polygon(self): return self.polygon
    def set_polygon(self, polygon): self.polygon = polygon
    def add_polygon(self, value): self.polygon.append(value)
    def insert_polygon(self, index, value): self.polygon[index] = value
    def export(self, outfile, level, namespace_='', name_='EX_BoundingPolygon_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_BoundingPolygon_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_BoundingPolygon_Type'):
        super(EX_BoundingPolygon_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_BoundingPolygon_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EX_BoundingPolygon_Type', fromsubclass_=False):
        super(EX_BoundingPolygon_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
    def hasContent_(self):
        if (
            self.polygon or
            super(EX_BoundingPolygon_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_BoundingPolygon_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EX_BoundingPolygon_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EX_BoundingPolygon_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.GM_Object_PropertyType(\n')
            polygon_.exportLiteral(outfile, level, name_='GM_Object_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_BoundingPolygon_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygon':
            obj_ = GM_Object_PropertyType.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        super(EX_BoundingPolygon_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_BoundingPolygon_Type


class EX_VerticalExtent_Type(AbstractObject_Type):
    """Vertical domain of dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, minimumValue=None, maximumValue=None, verticalCRS=None):
        super(EX_VerticalExtent_Type, self).__init__(id, uuid, )
        self.minimumValue = minimumValue
        self.maximumValue = maximumValue
        self.verticalCRS = verticalCRS
    def factory(*args_, **kwargs_):
        if EX_VerticalExtent_Type.subclass:
            return EX_VerticalExtent_Type.subclass(*args_, **kwargs_)
        else:
            return EX_VerticalExtent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimumValue(self): return self.minimumValue
    def set_minimumValue(self, minimumValue): self.minimumValue = minimumValue
    def get_maximumValue(self): return self.maximumValue
    def set_maximumValue(self, maximumValue): self.maximumValue = maximumValue
    def get_verticalCRS(self): return self.verticalCRS
    def set_verticalCRS(self, verticalCRS): self.verticalCRS = verticalCRS
    def export(self, outfile, level, namespace_='', name_='EX_VerticalExtent_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_VerticalExtent_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_VerticalExtent_Type'):
        super(EX_VerticalExtent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_VerticalExtent_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EX_VerticalExtent_Type', fromsubclass_=False):
        super(EX_VerticalExtent_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.minimumValue is not None:
            self.minimumValue.export(outfile, level, namespace_, name_='minimumValue', )
        if self.maximumValue is not None:
            self.maximumValue.export(outfile, level, namespace_, name_='maximumValue', )
        if self.verticalCRS is not None:
            self.verticalCRS.export(outfile, level, namespace_, name_='verticalCRS', )
    def hasContent_(self):
        if (
            self.minimumValue is not None or
            self.maximumValue is not None or
            self.verticalCRS is not None or
            super(EX_VerticalExtent_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_VerticalExtent_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EX_VerticalExtent_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EX_VerticalExtent_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.minimumValue is not None:
            showIndent(outfile, level)
            outfile.write('minimumValue=model_.Real_PropertyType(\n')
            self.minimumValue.exportLiteral(outfile, level, name_='minimumValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maximumValue is not None:
            showIndent(outfile, level)
            outfile.write('maximumValue=model_.Real_PropertyType(\n')
            self.maximumValue.exportLiteral(outfile, level, name_='maximumValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.verticalCRS is not None:
            showIndent(outfile, level)
            outfile.write('verticalCRS=model_.SC_CRS_PropertyType(\n')
            self.verticalCRS.exportLiteral(outfile, level, name_='verticalCRS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_VerticalExtent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'minimumValue':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_minimumValue(obj_)
        elif nodeName_ == 'maximumValue':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_maximumValue(obj_)
        elif nodeName_ == 'verticalCRS':
            obj_ = SC_CRS_PropertyType.factory()
            obj_.build(child_)
            self.set_verticalCRS(obj_)
        super(EX_VerticalExtent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_VerticalExtent_Type


class EX_TemporalExtent_Type(AbstractObject_Type):
    """Time period covered by the content of the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extent=None, extensiontype_=None):
        super(EX_TemporalExtent_Type, self).__init__(id, uuid, extensiontype_, )
        self.extent = extent
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EX_TemporalExtent_Type.subclass:
            return EX_TemporalExtent_Type.subclass(*args_, **kwargs_)
        else:
            return EX_TemporalExtent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='EX_TemporalExtent_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_TemporalExtent_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_TemporalExtent_Type'):
        super(EX_TemporalExtent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_TemporalExtent_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EX_TemporalExtent_Type', fromsubclass_=False):
        super(EX_TemporalExtent_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.extent is not None:
            self.extent.export(outfile, level, namespace_, name_='extent', )
    def hasContent_(self):
        if (
            self.extent is not None or
            super(EX_TemporalExtent_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_TemporalExtent_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EX_TemporalExtent_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EX_TemporalExtent_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.extent is not None:
            showIndent(outfile, level)
            outfile.write('extent=model_.TM_Primitive_PropertyType(\n')
            self.extent.exportLiteral(outfile, level, name_='extent')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(EX_TemporalExtent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'extent':
            obj_ = TM_Primitive_PropertyType.factory()
            obj_.build(child_)
            self.set_extent(obj_)
        super(EX_TemporalExtent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_TemporalExtent_Type


class AbstractRS_ReferenceSystem_Type(AbstractObject_Type):
    """Description of the spatial and temporal reference systems used in
    the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, name=None, domainOfValidity=None):
        super(AbstractRS_ReferenceSystem_Type, self).__init__(id, uuid, )
        self.name = name
        if domainOfValidity is None:
            self.domainOfValidity = []
        else:
            self.domainOfValidity = domainOfValidity
    def factory(*args_, **kwargs_):
        if AbstractRS_ReferenceSystem_Type.subclass:
            return AbstractRS_ReferenceSystem_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractRS_ReferenceSystem_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_domainOfValidity(self): return self.domainOfValidity
    def set_domainOfValidity(self, domainOfValidity): self.domainOfValidity = domainOfValidity
    def add_domainOfValidity(self, value): self.domainOfValidity.append(value)
    def insert_domainOfValidity(self, index, value): self.domainOfValidity[index] = value
    def export(self, outfile, level, namespace_='', name_='AbstractRS_ReferenceSystem_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractRS_ReferenceSystem_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractRS_ReferenceSystem_Type'):
        super(AbstractRS_ReferenceSystem_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractRS_ReferenceSystem_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractRS_ReferenceSystem_Type', fromsubclass_=False):
        super(AbstractRS_ReferenceSystem_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', )
        for domainOfValidity_ in self.domainOfValidity:
            domainOfValidity_.export(outfile, level, namespace_, name_='domainOfValidity')
    def hasContent_(self):
        if (
            self.name is not None or
            self.domainOfValidity or
            super(AbstractRS_ReferenceSystem_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractRS_ReferenceSystem_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractRS_ReferenceSystem_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractRS_ReferenceSystem_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.RS_Identifier_PropertyType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('domainOfValidity=[\n')
        level += 1
        for domainOfValidity_ in self.domainOfValidity:
            showIndent(outfile, level)
            outfile.write('model_.EX_Extent_PropertyType(\n')
            domainOfValidity_.exportLiteral(outfile, level, name_='EX_Extent_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractRS_ReferenceSystem_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = RS_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'domainOfValidity':
            obj_ = EX_Extent_PropertyType.factory()
            obj_.build(child_)
            self.domainOfValidity.append(obj_)
        super(AbstractRS_ReferenceSystem_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractRS_ReferenceSystem_Type


class MD_Identifier_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, authority=None, code=None, extensiontype_=None):
        super(MD_Identifier_Type, self).__init__(id, uuid, extensiontype_, )
        self.authority = authority
        self.code = code
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MD_Identifier_Type.subclass:
            return MD_Identifier_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Identifier_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_authority(self): return self.authority
    def set_authority(self, authority): self.authority = authority
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MD_Identifier_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Identifier_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Identifier_Type'):
        super(MD_Identifier_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Identifier_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Identifier_Type', fromsubclass_=False):
        super(MD_Identifier_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.authority is not None:
            self.authority.export(outfile, level, namespace_, name_='authority')
        if self.code is not None:
            self.code.export(outfile, level, namespace_, name_='code', )
    def hasContent_(self):
        if (
            self.authority is not None or
            self.code is not None or
            super(MD_Identifier_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Identifier_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Identifier_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Identifier_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.authority is not None:
            showIndent(outfile, level)
            outfile.write('authority=model_.CI_Citation_PropertyType(\n')
            self.authority.exportLiteral(outfile, level, name_='authority')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=model_.CharacterString_PropertyType(\n')
            self.code.exportLiteral(outfile, level, name_='code')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(MD_Identifier_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'authority':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.set_authority(obj_)
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_code(obj_)
        super(MD_Identifier_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Identifier_Type


class MD_ReferenceSystem_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, referenceSystemIdentifier=None):
        super(MD_ReferenceSystem_Type, self).__init__(id, uuid, )
        self.referenceSystemIdentifier = referenceSystemIdentifier
    def factory(*args_, **kwargs_):
        if MD_ReferenceSystem_Type.subclass:
            return MD_ReferenceSystem_Type.subclass(*args_, **kwargs_)
        else:
            return MD_ReferenceSystem_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceSystemIdentifier(self): return self.referenceSystemIdentifier
    def set_referenceSystemIdentifier(self, referenceSystemIdentifier): self.referenceSystemIdentifier = referenceSystemIdentifier
    def export(self, outfile, level, namespace_='', name_='MD_ReferenceSystem_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ReferenceSystem_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ReferenceSystem_Type'):
        super(MD_ReferenceSystem_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ReferenceSystem_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ReferenceSystem_Type', fromsubclass_=False):
        super(MD_ReferenceSystem_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.referenceSystemIdentifier is not None:
            self.referenceSystemIdentifier.export(outfile, level, namespace_, name_='referenceSystemIdentifier')
    def hasContent_(self):
        if (
            self.referenceSystemIdentifier is not None or
            super(MD_ReferenceSystem_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ReferenceSystem_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_ReferenceSystem_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_ReferenceSystem_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.referenceSystemIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('referenceSystemIdentifier=model_.RS_Identifier_PropertyType(\n')
            self.referenceSystemIdentifier.exportLiteral(outfile, level, name_='referenceSystemIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_ReferenceSystem_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceSystemIdentifier':
            obj_ = RS_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.set_referenceSystemIdentifier(obj_)
        super(MD_ReferenceSystem_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_ReferenceSystem_Type


class RS_Identifier_Type(MD_Identifier_Type):
    subclass = None
    superclass = MD_Identifier_Type
    def __init__(self, id=None, uuid=None, authority=None, code=None, codeSpace=None, version=None):
        super(RS_Identifier_Type, self).__init__(id, uuid, authority, code, )
        self.codeSpace = codeSpace
        self.version = version
    def factory(*args_, **kwargs_):
        if RS_Identifier_Type.subclass:
            return RS_Identifier_Type.subclass(*args_, **kwargs_)
        else:
            return RS_Identifier_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codeSpace(self): return self.codeSpace
    def set_codeSpace(self, codeSpace): self.codeSpace = codeSpace
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='', name_='RS_Identifier_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RS_Identifier_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RS_Identifier_Type'):
        super(RS_Identifier_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RS_Identifier_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='RS_Identifier_Type', fromsubclass_=False):
        super(RS_Identifier_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.codeSpace is not None:
            self.codeSpace.export(outfile, level, namespace_, name_='codeSpace')
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version')
    def hasContent_(self):
        if (
            self.codeSpace is not None or
            self.version is not None or
            super(RS_Identifier_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RS_Identifier_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RS_Identifier_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RS_Identifier_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.codeSpace is not None:
            showIndent(outfile, level)
            outfile.write('codeSpace=model_.CharacterString_PropertyType(\n')
            self.codeSpace.exportLiteral(outfile, level, name_='codeSpace')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.CharacterString_PropertyType(\n')
            self.version.exportLiteral(outfile, level, name_='version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(RS_Identifier_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codeSpace':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_codeSpace(obj_)
        elif nodeName_ == 'version':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_version(obj_)
        super(RS_Identifier_Type, self).buildChildren(child_, node, nodeName_, True)
# end class RS_Identifier_Type


class CI_Series_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, name=None, issueIdentification=None, page=None):
        super(CI_Series_Type, self).__init__(id, uuid, )
        self.name = name
        self.issueIdentification = issueIdentification
        self.page = page
    def factory(*args_, **kwargs_):
        if CI_Series_Type.subclass:
            return CI_Series_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Series_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_issueIdentification(self): return self.issueIdentification
    def set_issueIdentification(self, issueIdentification): self.issueIdentification = issueIdentification
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    def export(self, outfile, level, namespace_='', name_='CI_Series_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Series_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Series_Type'):
        super(CI_Series_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Series_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Series_Type', fromsubclass_=False):
        super(CI_Series_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name')
        if self.issueIdentification is not None:
            self.issueIdentification.export(outfile, level, namespace_, name_='issueIdentification')
        if self.page is not None:
            self.page.export(outfile, level, namespace_, name_='page')
    def hasContent_(self):
        if (
            self.name is not None or
            self.issueIdentification is not None or
            self.page is not None or
            super(CI_Series_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Series_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_Series_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_Series_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.CharacterString_PropertyType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.issueIdentification is not None:
            showIndent(outfile, level)
            outfile.write('issueIdentification=model_.CharacterString_PropertyType(\n')
            self.issueIdentification.exportLiteral(outfile, level, name_='issueIdentification')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.page is not None:
            showIndent(outfile, level)
            outfile.write('page=model_.CharacterString_PropertyType(\n')
            self.page.exportLiteral(outfile, level, name_='page')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Series_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'issueIdentification':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_issueIdentification(obj_)
        elif nodeName_ == 'page':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_page(obj_)
        super(CI_Series_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Series_Type


class CI_Date_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, date=None, dateType=None):
        super(CI_Date_Type, self).__init__(id, uuid, )
        self.date = date
        self.dateType = dateType
    def factory(*args_, **kwargs_):
        if CI_Date_Type.subclass:
            return CI_Date_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Date_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_dateType(self): return self.dateType
    def set_dateType(self, dateType): self.dateType = dateType
    def export(self, outfile, level, namespace_='', name_='CI_Date_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Date_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Date_Type'):
        super(CI_Date_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Date_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Date_Type', fromsubclass_=False):
        super(CI_Date_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.date is not None:
            self.date.export(outfile, level, namespace_, name_='date', )
        if self.dateType is not None:
            self.dateType.export(outfile, level, namespace_, name_='dateType', )
    def hasContent_(self):
        if (
            self.date is not None or
            self.dateType is not None or
            super(CI_Date_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Date_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_Date_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_Date_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.date is not None:
            showIndent(outfile, level)
            outfile.write('date=model_.Date_PropertyType(\n')
            self.date.exportLiteral(outfile, level, name_='date')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dateType is not None:
            showIndent(outfile, level)
            outfile.write('dateType=model_.CI_DateTypeCode_PropertyType(\n')
            self.dateType.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Date_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'date':
            obj_ = Date_PropertyType.factory()
            obj_.build(child_)
            self.set_date(obj_)
        elif nodeName_ == 'dateType':
            obj_ = CI_DateTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_dateType(obj_)
        super(CI_Date_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Date_Type


class CI_Telephone_Type(AbstractObject_Type):
    """Telephone numbers for contacting the responsible individual or
    organisation"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, voice=None, facsimile=None):
        super(CI_Telephone_Type, self).__init__(id, uuid, )
        if voice is None:
            self.voice = []
        else:
            self.voice = voice
        if facsimile is None:
            self.facsimile = []
        else:
            self.facsimile = facsimile
    def factory(*args_, **kwargs_):
        if CI_Telephone_Type.subclass:
            return CI_Telephone_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Telephone_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_voice(self): return self.voice
    def set_voice(self, voice): self.voice = voice
    def add_voice(self, value): self.voice.append(value)
    def insert_voice(self, index, value): self.voice[index] = value
    def get_facsimile(self): return self.facsimile
    def set_facsimile(self, facsimile): self.facsimile = facsimile
    def add_facsimile(self, value): self.facsimile.append(value)
    def insert_facsimile(self, index, value): self.facsimile[index] = value
    def export(self, outfile, level, namespace_='', name_='CI_Telephone_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Telephone_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Telephone_Type'):
        super(CI_Telephone_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Telephone_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Telephone_Type', fromsubclass_=False):
        super(CI_Telephone_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for voice_ in self.voice:
            voice_.export(outfile, level, namespace_, name_='voice')
        for facsimile_ in self.facsimile:
            facsimile_.export(outfile, level, namespace_, name_='facsimile')
    def hasContent_(self):
        if (
            self.voice or
            self.facsimile or
            super(CI_Telephone_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Telephone_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_Telephone_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_Telephone_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('voice=[\n')
        level += 1
        for voice_ in self.voice:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            voice_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('facsimile=[\n')
        level += 1
        for facsimile_ in self.facsimile:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            facsimile_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Telephone_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'voice':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.voice.append(obj_)
        elif nodeName_ == 'facsimile':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.facsimile.append(obj_)
        super(CI_Telephone_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Telephone_Type


class CI_Contact_Type(AbstractObject_Type):
    """Information required enabling contact with the responsible person
    and/or organisation"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, phone=None, address=None, onlineResource=None, hoursOfService=None, contactInstructions=None):
        super(CI_Contact_Type, self).__init__(id, uuid, )
        self.phone = phone
        self.address = address
        self.onlineResource = onlineResource
        self.hoursOfService = hoursOfService
        self.contactInstructions = contactInstructions
    def factory(*args_, **kwargs_):
        if CI_Contact_Type.subclass:
            return CI_Contact_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Contact_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_onlineResource(self): return self.onlineResource
    def set_onlineResource(self, onlineResource): self.onlineResource = onlineResource
    def get_hoursOfService(self): return self.hoursOfService
    def set_hoursOfService(self, hoursOfService): self.hoursOfService = hoursOfService
    def get_contactInstructions(self): return self.contactInstructions
    def set_contactInstructions(self, contactInstructions): self.contactInstructions = contactInstructions
    def export(self, outfile, level, namespace_='', name_='CI_Contact_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Contact_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Contact_Type'):
        super(CI_Contact_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Contact_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Contact_Type', fromsubclass_=False):
        super(CI_Contact_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.phone is not None:
            self.phone.export(outfile, level, namespace_, name_='phone')
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address')
        if self.onlineResource is not None:
            self.onlineResource.export(outfile, level, namespace_, name_='onlineResource')
        if self.hoursOfService is not None:
            self.hoursOfService.export(outfile, level, namespace_, name_='hoursOfService')
        if self.contactInstructions is not None:
            self.contactInstructions.export(outfile, level, namespace_, name_='contactInstructions')
    def hasContent_(self):
        if (
            self.phone is not None or
            self.address is not None or
            self.onlineResource is not None or
            self.hoursOfService is not None or
            self.contactInstructions is not None or
            super(CI_Contact_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Contact_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_Contact_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_Contact_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.phone is not None:
            showIndent(outfile, level)
            outfile.write('phone=model_.CI_Telephone_PropertyType(\n')
            self.phone.exportLiteral(outfile, level, name_='phone')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=model_.CI_Address_PropertyType(\n')
            self.address.exportLiteral(outfile, level, name_='address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.onlineResource is not None:
            showIndent(outfile, level)
            outfile.write('onlineResource=model_.CI_OnlineResource_PropertyType(\n')
            self.onlineResource.exportLiteral(outfile, level, name_='onlineResource')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hoursOfService is not None:
            showIndent(outfile, level)
            outfile.write('hoursOfService=model_.CharacterString_PropertyType(\n')
            self.hoursOfService.exportLiteral(outfile, level, name_='hoursOfService')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contactInstructions is not None:
            showIndent(outfile, level)
            outfile.write('contactInstructions=model_.CharacterString_PropertyType(\n')
            self.contactInstructions.exportLiteral(outfile, level, name_='contactInstructions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Contact_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'phone':
            obj_ = CI_Telephone_PropertyType.factory()
            obj_.build(child_)
            self.set_phone(obj_)
        elif nodeName_ == 'address':
            obj_ = CI_Address_PropertyType.factory()
            obj_.build(child_)
            self.set_address(obj_)
        elif nodeName_ == 'onlineResource':
            obj_ = CI_OnlineResource_PropertyType.factory()
            obj_.build(child_)
            self.set_onlineResource(obj_)
        elif nodeName_ == 'hoursOfService':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_hoursOfService(obj_)
        elif nodeName_ == 'contactInstructions':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_contactInstructions(obj_)
        super(CI_Contact_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Contact_Type


class CI_OnlineResource_Type(AbstractObject_Type):
    """Information about online sources from which the dataset,
    specification, or community profile name and extended metadata
    elements can be obtained."""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, linkage=None, protocol=None, applicationProfile=None, name=None, description=None, function=None):
        super(CI_OnlineResource_Type, self).__init__(id, uuid, )
        self.linkage = linkage
        self.protocol = protocol
        self.applicationProfile = applicationProfile
        self.name = name
        self.description = description
        self.function = function
    def factory(*args_, **kwargs_):
        if CI_OnlineResource_Type.subclass:
            return CI_OnlineResource_Type.subclass(*args_, **kwargs_)
        else:
            return CI_OnlineResource_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linkage(self): return self.linkage
    def set_linkage(self, linkage): self.linkage = linkage
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_applicationProfile(self): return self.applicationProfile
    def set_applicationProfile(self, applicationProfile): self.applicationProfile = applicationProfile
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def export(self, outfile, level, namespace_='', name_='CI_OnlineResource_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnlineResource_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_OnlineResource_Type'):
        super(CI_OnlineResource_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_OnlineResource_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_OnlineResource_Type', fromsubclass_=False):
        super(CI_OnlineResource_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.linkage is not None:
            self.linkage.export(outfile, level, namespace_, name_='linkage', )
        if self.protocol is not None:
            self.protocol.export(outfile, level, namespace_, name_='protocol')
        if self.applicationProfile is not None:
            self.applicationProfile.export(outfile, level, namespace_, name_='applicationProfile')
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name')
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.function is not None:
            self.function.export(outfile, level, namespace_, name_='function')
    def hasContent_(self):
        if (
            self.linkage is not None or
            self.protocol is not None or
            self.applicationProfile is not None or
            self.name is not None or
            self.description is not None or
            self.function is not None or
            super(CI_OnlineResource_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_OnlineResource_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_OnlineResource_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_OnlineResource_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.linkage is not None:
            showIndent(outfile, level)
            outfile.write('linkage=model_.URL_PropertyType(\n')
            self.linkage.exportLiteral(outfile, level, name_='linkage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=model_.CharacterString_PropertyType(\n')
            self.protocol.exportLiteral(outfile, level, name_='protocol')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.applicationProfile is not None:
            showIndent(outfile, level)
            outfile.write('applicationProfile=model_.CharacterString_PropertyType(\n')
            self.applicationProfile.exportLiteral(outfile, level, name_='applicationProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.CharacterString_PropertyType(\n')
            self.name.exportLiteral(outfile, level, name_='name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.CharacterString_PropertyType(\n')
            self.description.exportLiteral(outfile, level, name_='description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.function is not None:
            showIndent(outfile, level)
            outfile.write('function=model_.CI_OnLineFunctionCode_PropertyType(\n')
            self.function.exportLiteral(outfile, level, name_='function')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_OnlineResource_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'linkage':
            obj_ = URL_PropertyType.factory()
            obj_.build(child_)
            self.set_linkage(obj_)
        elif nodeName_ == 'protocol':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_protocol(obj_)
        elif nodeName_ == 'applicationProfile':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_applicationProfile(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'function':
            obj_ = CI_OnLineFunctionCode_PropertyType.factory()
            obj_.build(child_)
            self.set_function(obj_)
        super(CI_OnlineResource_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_OnlineResource_Type


class CI_Address_Type(AbstractObject_Type):
    """Location of the responsible individual or organisation"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, deliveryPoint=None, city=None, administrativeArea=None, postalCode=None, country=None, electronicMailAddress=None):
        super(CI_Address_Type, self).__init__(id, uuid, )
        if deliveryPoint is None:
            self.deliveryPoint = []
        else:
            self.deliveryPoint = deliveryPoint
        self.city = city
        self.administrativeArea = administrativeArea
        self.postalCode = postalCode
        self.country = country
        if electronicMailAddress is None:
            self.electronicMailAddress = []
        else:
            self.electronicMailAddress = electronicMailAddress
    def factory(*args_, **kwargs_):
        if CI_Address_Type.subclass:
            return CI_Address_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Address_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPoint(self): return self.deliveryPoint
    def set_deliveryPoint(self, deliveryPoint): self.deliveryPoint = deliveryPoint
    def add_deliveryPoint(self, value): self.deliveryPoint.append(value)
    def insert_deliveryPoint(self, index, value): self.deliveryPoint[index] = value
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_administrativeArea(self): return self.administrativeArea
    def set_administrativeArea(self, administrativeArea): self.administrativeArea = administrativeArea
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_electronicMailAddress(self): return self.electronicMailAddress
    def set_electronicMailAddress(self, electronicMailAddress): self.electronicMailAddress = electronicMailAddress
    def add_electronicMailAddress(self, value): self.electronicMailAddress.append(value)
    def insert_electronicMailAddress(self, index, value): self.electronicMailAddress[index] = value
    def export(self, outfile, level, namespace_='', name_='CI_Address_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Address_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Address_Type'):
        super(CI_Address_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Address_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Address_Type', fromsubclass_=False):
        super(CI_Address_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for deliveryPoint_ in self.deliveryPoint:
            deliveryPoint_.export(outfile, level, namespace_, name_='deliveryPoint')
        if self.city is not None:
            self.city.export(outfile, level, namespace_, name_='city')
        if self.administrativeArea is not None:
            self.administrativeArea.export(outfile, level, namespace_, name_='administrativeArea')
        if self.postalCode is not None:
            self.postalCode.export(outfile, level, namespace_, name_='postalCode')
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country')
        for electronicMailAddress_ in self.electronicMailAddress:
            electronicMailAddress_.export(outfile, level, namespace_, name_='electronicMailAddress')
    def hasContent_(self):
        if (
            self.deliveryPoint or
            self.city is not None or
            self.administrativeArea is not None or
            self.postalCode is not None or
            self.country is not None or
            self.electronicMailAddress or
            super(CI_Address_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Address_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_Address_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_Address_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('deliveryPoint=[\n')
        level += 1
        for deliveryPoint_ in self.deliveryPoint:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            deliveryPoint_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=model_.CharacterString_PropertyType(\n')
            self.city.exportLiteral(outfile, level, name_='city')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.administrativeArea is not None:
            showIndent(outfile, level)
            outfile.write('administrativeArea=model_.CharacterString_PropertyType(\n')
            self.administrativeArea.exportLiteral(outfile, level, name_='administrativeArea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.postalCode is not None:
            showIndent(outfile, level)
            outfile.write('postalCode=model_.CharacterString_PropertyType(\n')
            self.postalCode.exportLiteral(outfile, level, name_='postalCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.country is not None:
            showIndent(outfile, level)
            outfile.write('country=model_.CharacterString_PropertyType(\n')
            self.country.exportLiteral(outfile, level, name_='country')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('electronicMailAddress=[\n')
        level += 1
        for electronicMailAddress_ in self.electronicMailAddress:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            electronicMailAddress_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Address_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPoint':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryPoint.append(obj_)
        elif nodeName_ == 'city':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_city(obj_)
        elif nodeName_ == 'administrativeArea':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_administrativeArea(obj_)
        elif nodeName_ == 'postalCode':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_postalCode(obj_)
        elif nodeName_ == 'country':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_country(obj_)
        elif nodeName_ == 'electronicMailAddress':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.electronicMailAddress.append(obj_)
        super(CI_Address_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Address_Type


class CI_Citation_Type(AbstractObject_Type):
    """Standardized resource reference"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, title=None, alternateTitle=None, date=None, edition=None, editionDate=None, identifier=None, citedResponsibleParty=None, presentationForm=None, series=None, otherCitationDetails=None, collectiveTitle=None, ISBN=None, ISSN=None):
        super(CI_Citation_Type, self).__init__(id, uuid, )
        self.title = title
        if alternateTitle is None:
            self.alternateTitle = []
        else:
            self.alternateTitle = alternateTitle
        if date is None:
            self.date = []
        else:
            self.date = date
        self.edition = edition
        self.editionDate = editionDate
        if identifier is None:
            self.identifier = []
        else:
            self.identifier = identifier
        if citedResponsibleParty is None:
            self.citedResponsibleParty = []
        else:
            self.citedResponsibleParty = citedResponsibleParty
        if presentationForm is None:
            self.presentationForm = []
        else:
            self.presentationForm = presentationForm
        self.series = series
        self.otherCitationDetails = otherCitationDetails
        self.collectiveTitle = collectiveTitle
        self.ISBN = ISBN
        self.ISSN = ISSN
    def factory(*args_, **kwargs_):
        if CI_Citation_Type.subclass:
            return CI_Citation_Type.subclass(*args_, **kwargs_)
        else:
            return CI_Citation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_alternateTitle(self): return self.alternateTitle
    def set_alternateTitle(self, alternateTitle): self.alternateTitle = alternateTitle
    def add_alternateTitle(self, value): self.alternateTitle.append(value)
    def insert_alternateTitle(self, index, value): self.alternateTitle[index] = value
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def add_date(self, value): self.date.append(value)
    def insert_date(self, index, value): self.date[index] = value
    def get_edition(self): return self.edition
    def set_edition(self, edition): self.edition = edition
    def get_editionDate(self): return self.editionDate
    def set_editionDate(self, editionDate): self.editionDate = editionDate
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def add_identifier(self, value): self.identifier.append(value)
    def insert_identifier(self, index, value): self.identifier[index] = value
    def get_citedResponsibleParty(self): return self.citedResponsibleParty
    def set_citedResponsibleParty(self, citedResponsibleParty): self.citedResponsibleParty = citedResponsibleParty
    def add_citedResponsibleParty(self, value): self.citedResponsibleParty.append(value)
    def insert_citedResponsibleParty(self, index, value): self.citedResponsibleParty[index] = value
    def get_presentationForm(self): return self.presentationForm
    def set_presentationForm(self, presentationForm): self.presentationForm = presentationForm
    def add_presentationForm(self, value): self.presentationForm.append(value)
    def insert_presentationForm(self, index, value): self.presentationForm[index] = value
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    def get_otherCitationDetails(self): return self.otherCitationDetails
    def set_otherCitationDetails(self, otherCitationDetails): self.otherCitationDetails = otherCitationDetails
    def get_collectiveTitle(self): return self.collectiveTitle
    def set_collectiveTitle(self, collectiveTitle): self.collectiveTitle = collectiveTitle
    def get_ISBN(self): return self.ISBN
    def set_ISBN(self, ISBN): self.ISBN = ISBN
    def get_ISSN(self): return self.ISSN
    def set_ISSN(self, ISSN): self.ISSN = ISSN
    def export(self, outfile, level, namespace_='', name_='CI_Citation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Citation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_Citation_Type'):
        super(CI_Citation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_Citation_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_Citation_Type', fromsubclass_=False):
        super(CI_Citation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', )
        for alternateTitle_ in self.alternateTitle:
            alternateTitle_.export(outfile, level, namespace_, name_='alternateTitle')
        for date_ in self.date:
            date_.export(outfile, level, namespace_, name_='date')
        if self.edition is not None:
            self.edition.export(outfile, level, namespace_, name_='edition')
        if self.editionDate is not None:
            self.editionDate.export(outfile, level, namespace_, name_='editionDate')
        for identifier_ in self.identifier:
            identifier_.export(outfile, level, namespace_, name_='identifier')
        for citedResponsibleParty_ in self.citedResponsibleParty:
            citedResponsibleParty_.export(outfile, level, namespace_, name_='citedResponsibleParty')
        for presentationForm_ in self.presentationForm:
            presentationForm_.export(outfile, level, namespace_, name_='presentationForm')
        if self.series is not None:
            self.series.export(outfile, level, namespace_, name_='series')
        if self.otherCitationDetails is not None:
            self.otherCitationDetails.export(outfile, level, namespace_, name_='otherCitationDetails')
        if self.collectiveTitle is not None:
            self.collectiveTitle.export(outfile, level, namespace_, name_='collectiveTitle')
        if self.ISBN is not None:
            self.ISBN.export(outfile, level, namespace_, name_='ISBN')
        if self.ISSN is not None:
            self.ISSN.export(outfile, level, namespace_, name_='ISSN')
    def hasContent_(self):
        if (
            self.title is not None or
            self.alternateTitle or
            self.date or
            self.edition is not None or
            self.editionDate is not None or
            self.identifier or
            self.citedResponsibleParty or
            self.presentationForm or
            self.series is not None or
            self.otherCitationDetails is not None or
            self.collectiveTitle is not None or
            self.ISBN is not None or
            self.ISSN is not None or
            super(CI_Citation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_Citation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_Citation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_Citation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.CharacterString_PropertyType(\n')
            self.title.exportLiteral(outfile, level, name_='title')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('alternateTitle=[\n')
        level += 1
        for alternateTitle_ in self.alternateTitle:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            alternateTitle_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('date=[\n')
        level += 1
        for date_ in self.date:
            showIndent(outfile, level)
            outfile.write('model_.CI_Date_PropertyType(\n')
            date_.exportLiteral(outfile, level, name_='CI_Date_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.edition is not None:
            showIndent(outfile, level)
            outfile.write('edition=model_.CharacterString_PropertyType(\n')
            self.edition.exportLiteral(outfile, level, name_='edition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.editionDate is not None:
            showIndent(outfile, level)
            outfile.write('editionDate=model_.Date_PropertyType(\n')
            self.editionDate.exportLiteral(outfile, level, name_='editionDate')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('identifier=[\n')
        level += 1
        for identifier_ in self.identifier:
            showIndent(outfile, level)
            outfile.write('model_.MD_Identifier_PropertyType(\n')
            identifier_.exportLiteral(outfile, level, name_='MD_Identifier_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('citedResponsibleParty=[\n')
        level += 1
        for citedResponsibleParty_ in self.citedResponsibleParty:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            citedResponsibleParty_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('presentationForm=[\n')
        level += 1
        for presentationForm_ in self.presentationForm:
            showIndent(outfile, level)
            outfile.write('model_.CI_PresentationFormCode_PropertyType(\n')
            presentationForm_.exportLiteral(outfile, level, name_='CI_PresentationFormCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.series is not None:
            showIndent(outfile, level)
            outfile.write('series=model_.CI_Series_PropertyType(\n')
            self.series.exportLiteral(outfile, level, name_='series')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.otherCitationDetails is not None:
            showIndent(outfile, level)
            outfile.write('otherCitationDetails=model_.CharacterString_PropertyType(\n')
            self.otherCitationDetails.exportLiteral(outfile, level, name_='otherCitationDetails')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.collectiveTitle is not None:
            showIndent(outfile, level)
            outfile.write('collectiveTitle=model_.CharacterString_PropertyType(\n')
            self.collectiveTitle.exportLiteral(outfile, level, name_='collectiveTitle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ISBN is not None:
            showIndent(outfile, level)
            outfile.write('ISBN=model_.CharacterString_PropertyType(\n')
            self.ISBN.exportLiteral(outfile, level, name_='ISBN')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ISSN is not None:
            showIndent(outfile, level)
            outfile.write('ISSN=model_.CharacterString_PropertyType(\n')
            self.ISSN.exportLiteral(outfile, level, name_='ISSN')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_Citation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_title(obj_)
        elif nodeName_ == 'alternateTitle':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.alternateTitle.append(obj_)
        elif nodeName_ == 'date':
            obj_ = CI_Date_PropertyType.factory()
            obj_.build(child_)
            self.date.append(obj_)
        elif nodeName_ == 'edition':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_edition(obj_)
        elif nodeName_ == 'editionDate':
            obj_ = Date_PropertyType.factory()
            obj_.build(child_)
            self.set_editionDate(obj_)
        elif nodeName_ == 'identifier':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
        elif nodeName_ == 'citedResponsibleParty':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.citedResponsibleParty.append(obj_)
        elif nodeName_ == 'presentationForm':
            obj_ = CI_PresentationFormCode_PropertyType.factory()
            obj_.build(child_)
            self.presentationForm.append(obj_)
        elif nodeName_ == 'series':
            obj_ = CI_Series_PropertyType.factory()
            obj_.build(child_)
            self.set_series(obj_)
        elif nodeName_ == 'otherCitationDetails':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_otherCitationDetails(obj_)
        elif nodeName_ == 'collectiveTitle':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_collectiveTitle(obj_)
        elif nodeName_ == 'ISBN':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_ISBN(obj_)
        elif nodeName_ == 'ISSN':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_ISSN(obj_)
        super(CI_Citation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_Citation_Type


class CI_ResponsibleParty_Type(AbstractObject_Type):
    """Identification of, and means of communication with, person(s) and
    organisations associated with the dataset"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, individualName=None, organisationName=None, positionName=None, contactInfo=None, role=None):
        super(CI_ResponsibleParty_Type, self).__init__(id, uuid, )
        self.individualName = individualName
        self.organisationName = organisationName
        self.positionName = positionName
        self.contactInfo = contactInfo
        self.role = role
    def factory(*args_, **kwargs_):
        if CI_ResponsibleParty_Type.subclass:
            return CI_ResponsibleParty_Type.subclass(*args_, **kwargs_)
        else:
            return CI_ResponsibleParty_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_individualName(self): return self.individualName
    def set_individualName(self, individualName): self.individualName = individualName
    def get_organisationName(self): return self.organisationName
    def set_organisationName(self, organisationName): self.organisationName = organisationName
    def get_positionName(self): return self.positionName
    def set_positionName(self, positionName): self.positionName = positionName
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def export(self, outfile, level, namespace_='', name_='CI_ResponsibleParty_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CI_ResponsibleParty_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CI_ResponsibleParty_Type'):
        super(CI_ResponsibleParty_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CI_ResponsibleParty_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CI_ResponsibleParty_Type', fromsubclass_=False):
        super(CI_ResponsibleParty_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.individualName is not None:
            self.individualName.export(outfile, level, namespace_, name_='individualName')
        if self.organisationName is not None:
            self.organisationName.export(outfile, level, namespace_, name_='organisationName')
        if self.positionName is not None:
            self.positionName.export(outfile, level, namespace_, name_='positionName')
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo')
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', )
    def hasContent_(self):
        if (
            self.individualName is not None or
            self.organisationName is not None or
            self.positionName is not None or
            self.contactInfo is not None or
            self.role is not None or
            super(CI_ResponsibleParty_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CI_ResponsibleParty_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CI_ResponsibleParty_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CI_ResponsibleParty_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.individualName is not None:
            showIndent(outfile, level)
            outfile.write('individualName=model_.CharacterString_PropertyType(\n')
            self.individualName.exportLiteral(outfile, level, name_='individualName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.organisationName is not None:
            showIndent(outfile, level)
            outfile.write('organisationName=model_.CharacterString_PropertyType(\n')
            self.organisationName.exportLiteral(outfile, level, name_='organisationName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.positionName is not None:
            showIndent(outfile, level)
            outfile.write('positionName=model_.CharacterString_PropertyType(\n')
            self.positionName.exportLiteral(outfile, level, name_='positionName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contactInfo is not None:
            showIndent(outfile, level)
            outfile.write('contactInfo=model_.CI_Contact_PropertyType(\n')
            self.contactInfo.exportLiteral(outfile, level, name_='contactInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.role is not None:
            showIndent(outfile, level)
            outfile.write('role=model_.CI_RoleCode_PropertyType(\n')
            self.role.exportLiteral(outfile, level, name_='role')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CI_ResponsibleParty_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'individualName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_individualName(obj_)
        elif nodeName_ == 'organisationName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_organisationName(obj_)
        elif nodeName_ == 'positionName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_positionName(obj_)
        elif nodeName_ == 'contactInfo':
            obj_ = CI_Contact_PropertyType.factory()
            obj_.build(child_)
            self.set_contactInfo(obj_)
        elif nodeName_ == 'role':
            obj_ = CI_RoleCode_PropertyType.factory()
            obj_.build(child_)
            self.set_role(obj_)
        super(CI_ResponsibleParty_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CI_ResponsibleParty_Type


class MD_GeometricObjects_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, geometricObjectType=None, geometricObjectCount=None):
        super(MD_GeometricObjects_Type, self).__init__(id, uuid, )
        self.geometricObjectType = geometricObjectType
        self.geometricObjectCount = geometricObjectCount
    def factory(*args_, **kwargs_):
        if MD_GeometricObjects_Type.subclass:
            return MD_GeometricObjects_Type.subclass(*args_, **kwargs_)
        else:
            return MD_GeometricObjects_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geometricObjectType(self): return self.geometricObjectType
    def set_geometricObjectType(self, geometricObjectType): self.geometricObjectType = geometricObjectType
    def get_geometricObjectCount(self): return self.geometricObjectCount
    def set_geometricObjectCount(self, geometricObjectCount): self.geometricObjectCount = geometricObjectCount
    def export(self, outfile, level, namespace_='', name_='MD_GeometricObjects_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_GeometricObjects_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_GeometricObjects_Type'):
        super(MD_GeometricObjects_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_GeometricObjects_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_GeometricObjects_Type', fromsubclass_=False):
        super(MD_GeometricObjects_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.geometricObjectType is not None:
            self.geometricObjectType.export(outfile, level, namespace_, name_='geometricObjectType', )
        if self.geometricObjectCount is not None:
            self.geometricObjectCount.export(outfile, level, namespace_, name_='geometricObjectCount')
    def hasContent_(self):
        if (
            self.geometricObjectType is not None or
            self.geometricObjectCount is not None or
            super(MD_GeometricObjects_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_GeometricObjects_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_GeometricObjects_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_GeometricObjects_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.geometricObjectType is not None:
            showIndent(outfile, level)
            outfile.write('geometricObjectType=model_.MD_GeometricObjectTypeCode_PropertyType(\n')
            self.geometricObjectType.exportLiteral(outfile, level, name_='geometricObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.geometricObjectCount is not None:
            showIndent(outfile, level)
            outfile.write('geometricObjectCount=model_.Integer_PropertyType(\n')
            self.geometricObjectCount.exportLiteral(outfile, level, name_='geometricObjectCount')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_GeometricObjects_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geometricObjectType':
            obj_ = MD_GeometricObjectTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_geometricObjectType(obj_)
        elif nodeName_ == 'geometricObjectCount':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_geometricObjectCount(obj_)
        super(MD_GeometricObjects_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_GeometricObjects_Type


class MD_Dimension_Type(AbstractObject_Type):
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, dimensionName=None, dimensionSize=None, resolution=None):
        super(MD_Dimension_Type, self).__init__(id, uuid, )
        self.dimensionName = dimensionName
        self.dimensionSize = dimensionSize
        self.resolution = resolution
    def factory(*args_, **kwargs_):
        if MD_Dimension_Type.subclass:
            return MD_Dimension_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Dimension_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dimensionName(self): return self.dimensionName
    def set_dimensionName(self, dimensionName): self.dimensionName = dimensionName
    def get_dimensionSize(self): return self.dimensionSize
    def set_dimensionSize(self, dimensionSize): self.dimensionSize = dimensionSize
    def get_resolution(self): return self.resolution
    def set_resolution(self, resolution): self.resolution = resolution
    def export(self, outfile, level, namespace_='', name_='MD_Dimension_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Dimension_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Dimension_Type'):
        super(MD_Dimension_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Dimension_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Dimension_Type', fromsubclass_=False):
        super(MD_Dimension_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.dimensionName is not None:
            self.dimensionName.export(outfile, level, namespace_, name_='dimensionName', )
        if self.dimensionSize is not None:
            self.dimensionSize.export(outfile, level, namespace_, name_='dimensionSize', )
        if self.resolution is not None:
            self.resolution.export(outfile, level, namespace_, name_='resolution')
    def hasContent_(self):
        if (
            self.dimensionName is not None or
            self.dimensionSize is not None or
            self.resolution is not None or
            super(MD_Dimension_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Dimension_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Dimension_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Dimension_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.dimensionName is not None:
            showIndent(outfile, level)
            outfile.write('dimensionName=model_.MD_DimensionNameTypeCode_PropertyType(\n')
            self.dimensionName.exportLiteral(outfile, level, name_='dimensionName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dimensionSize is not None:
            showIndent(outfile, level)
            outfile.write('dimensionSize=model_.Integer_PropertyType(\n')
            self.dimensionSize.exportLiteral(outfile, level, name_='dimensionSize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resolution is not None:
            showIndent(outfile, level)
            outfile.write('resolution=model_.Measure_PropertyType(\n')
            self.resolution.exportLiteral(outfile, level, name_='resolution')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Dimension_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dimensionName':
            obj_ = MD_DimensionNameTypeCode_PropertyType.factory()
            obj_.build(child_)
            self.set_dimensionName(obj_)
        elif nodeName_ == 'dimensionSize':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_dimensionSize(obj_)
        elif nodeName_ == 'resolution':
            obj_ = Measure_PropertyType.factory()
            obj_.build(child_)
            self.set_resolution(obj_)
        super(MD_Dimension_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Dimension_Type


class AbstractMD_SpatialRepresentation_Type(AbstractObject_Type):
    """Digital mechanism used to represent spatial information"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, extensiontype_=None):
        super(AbstractMD_SpatialRepresentation_Type, self).__init__(id, uuid, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractMD_SpatialRepresentation_Type.subclass:
            return AbstractMD_SpatialRepresentation_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractMD_SpatialRepresentation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractMD_SpatialRepresentation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMD_SpatialRepresentation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractMD_SpatialRepresentation_Type'):
        super(AbstractMD_SpatialRepresentation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractMD_SpatialRepresentation_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractMD_SpatialRepresentation_Type', fromsubclass_=False):
        super(AbstractMD_SpatialRepresentation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(AbstractMD_SpatialRepresentation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractMD_SpatialRepresentation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractMD_SpatialRepresentation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractMD_SpatialRepresentation_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractMD_SpatialRepresentation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractMD_SpatialRepresentation_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractMD_SpatialRepresentation_Type


class MD_VectorSpatialRepresentation_Type(AbstractMD_SpatialRepresentation_Type):
    """Information about the vector spatial objects in the dataset"""
    subclass = None
    superclass = AbstractMD_SpatialRepresentation_Type
    def __init__(self, id=None, uuid=None, topologyLevel=None, geometricObjects=None):
        super(MD_VectorSpatialRepresentation_Type, self).__init__(id, uuid, )
        self.topologyLevel = topologyLevel
        if geometricObjects is None:
            self.geometricObjects = []
        else:
            self.geometricObjects = geometricObjects
    def factory(*args_, **kwargs_):
        if MD_VectorSpatialRepresentation_Type.subclass:
            return MD_VectorSpatialRepresentation_Type.subclass(*args_, **kwargs_)
        else:
            return MD_VectorSpatialRepresentation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topologyLevel(self): return self.topologyLevel
    def set_topologyLevel(self, topologyLevel): self.topologyLevel = topologyLevel
    def get_geometricObjects(self): return self.geometricObjects
    def set_geometricObjects(self, geometricObjects): self.geometricObjects = geometricObjects
    def add_geometricObjects(self, value): self.geometricObjects.append(value)
    def insert_geometricObjects(self, index, value): self.geometricObjects[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_VectorSpatialRepresentation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_VectorSpatialRepresentation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_VectorSpatialRepresentation_Type'):
        super(MD_VectorSpatialRepresentation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_VectorSpatialRepresentation_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_VectorSpatialRepresentation_Type', fromsubclass_=False):
        super(MD_VectorSpatialRepresentation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.topologyLevel is not None:
            self.topologyLevel.export(outfile, level, namespace_, name_='topologyLevel')
        for geometricObjects_ in self.geometricObjects:
            geometricObjects_.export(outfile, level, namespace_, name_='geometricObjects')
    def hasContent_(self):
        if (
            self.topologyLevel is not None or
            self.geometricObjects or
            super(MD_VectorSpatialRepresentation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_VectorSpatialRepresentation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_VectorSpatialRepresentation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_VectorSpatialRepresentation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.topologyLevel is not None:
            showIndent(outfile, level)
            outfile.write('topologyLevel=model_.MD_TopologyLevelCode_PropertyType(\n')
            self.topologyLevel.exportLiteral(outfile, level, name_='topologyLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('geometricObjects=[\n')
        level += 1
        for geometricObjects_ in self.geometricObjects:
            showIndent(outfile, level)
            outfile.write('model_.MD_GeometricObjects_PropertyType(\n')
            geometricObjects_.exportLiteral(outfile, level, name_='MD_GeometricObjects_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_VectorSpatialRepresentation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'topologyLevel':
            obj_ = MD_TopologyLevelCode_PropertyType.factory()
            obj_.build(child_)
            self.set_topologyLevel(obj_)
        elif nodeName_ == 'geometricObjects':
            obj_ = MD_GeometricObjects_PropertyType.factory()
            obj_.build(child_)
            self.geometricObjects.append(obj_)
        super(MD_VectorSpatialRepresentation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_VectorSpatialRepresentation_Type


class MD_GridSpatialRepresentation_Type(AbstractMD_SpatialRepresentation_Type):
    """Types and numbers of raster spatial objects in the dataset"""
    subclass = None
    superclass = AbstractMD_SpatialRepresentation_Type
    def __init__(self, id=None, uuid=None, numberOfDimensions=None, axisDimensionProperties=None, cellGeometry=None, transformationParameterAvailability=None, extensiontype_=None):
        super(MD_GridSpatialRepresentation_Type, self).__init__(id, uuid, extensiontype_, )
        self.numberOfDimensions = numberOfDimensions
        if axisDimensionProperties is None:
            self.axisDimensionProperties = []
        else:
            self.axisDimensionProperties = axisDimensionProperties
        self.cellGeometry = cellGeometry
        self.transformationParameterAvailability = transformationParameterAvailability
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MD_GridSpatialRepresentation_Type.subclass:
            return MD_GridSpatialRepresentation_Type.subclass(*args_, **kwargs_)
        else:
            return MD_GridSpatialRepresentation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfDimensions(self): return self.numberOfDimensions
    def set_numberOfDimensions(self, numberOfDimensions): self.numberOfDimensions = numberOfDimensions
    def get_axisDimensionProperties(self): return self.axisDimensionProperties
    def set_axisDimensionProperties(self, axisDimensionProperties): self.axisDimensionProperties = axisDimensionProperties
    def add_axisDimensionProperties(self, value): self.axisDimensionProperties.append(value)
    def insert_axisDimensionProperties(self, index, value): self.axisDimensionProperties[index] = value
    def get_cellGeometry(self): return self.cellGeometry
    def set_cellGeometry(self, cellGeometry): self.cellGeometry = cellGeometry
    def get_transformationParameterAvailability(self): return self.transformationParameterAvailability
    def set_transformationParameterAvailability(self, transformationParameterAvailability): self.transformationParameterAvailability = transformationParameterAvailability
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='MD_GridSpatialRepresentation_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_GridSpatialRepresentation_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_GridSpatialRepresentation_Type'):
        super(MD_GridSpatialRepresentation_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_GridSpatialRepresentation_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MD_GridSpatialRepresentation_Type', fromsubclass_=False):
        super(MD_GridSpatialRepresentation_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.numberOfDimensions is not None:
            self.numberOfDimensions.export(outfile, level, namespace_, name_='numberOfDimensions', )
        for axisDimensionProperties_ in self.axisDimensionProperties:
            axisDimensionProperties_.export(outfile, level, namespace_, name_='axisDimensionProperties')
        if self.cellGeometry is not None:
            self.cellGeometry.export(outfile, level, namespace_, name_='cellGeometry', )
        if self.transformationParameterAvailability is not None:
            self.transformationParameterAvailability.export(outfile, level, namespace_, name_='transformationParameterAvailability', )
    def hasContent_(self):
        if (
            self.numberOfDimensions is not None or
            self.axisDimensionProperties or
            self.cellGeometry is not None or
            self.transformationParameterAvailability is not None or
            super(MD_GridSpatialRepresentation_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_GridSpatialRepresentation_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_GridSpatialRepresentation_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_GridSpatialRepresentation_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.numberOfDimensions is not None:
            showIndent(outfile, level)
            outfile.write('numberOfDimensions=model_.Integer_PropertyType(\n')
            self.numberOfDimensions.exportLiteral(outfile, level, name_='numberOfDimensions')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('axisDimensionProperties=[\n')
        level += 1
        for axisDimensionProperties_ in self.axisDimensionProperties:
            showIndent(outfile, level)
            outfile.write('model_.MD_Dimension_PropertyType(\n')
            axisDimensionProperties_.exportLiteral(outfile, level, name_='MD_Dimension_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cellGeometry is not None:
            showIndent(outfile, level)
            outfile.write('cellGeometry=model_.MD_CellGeometryCode_PropertyType(\n')
            self.cellGeometry.exportLiteral(outfile, level, name_='cellGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transformationParameterAvailability is not None:
            showIndent(outfile, level)
            outfile.write('transformationParameterAvailability=model_.Boolean_PropertyType(\n')
            self.transformationParameterAvailability.exportLiteral(outfile, level, name_='transformationParameterAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(MD_GridSpatialRepresentation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numberOfDimensions':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_numberOfDimensions(obj_)
        elif nodeName_ == 'axisDimensionProperties':
            obj_ = MD_Dimension_PropertyType.factory()
            obj_.build(child_)
            self.axisDimensionProperties.append(obj_)
        elif nodeName_ == 'cellGeometry':
            obj_ = MD_CellGeometryCode_PropertyType.factory()
            obj_.build(child_)
            self.set_cellGeometry(obj_)
        elif nodeName_ == 'transformationParameterAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_transformationParameterAvailability(obj_)
        super(MD_GridSpatialRepresentation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_GridSpatialRepresentation_Type


class MD_Metadata_Type(AbstractObject_Type):
    """Information about the metadata"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, fileIdentifier=None, language=None, characterSet=None, parentIdentifier=None, hierarchyLevel=None, hierarchyLevelName=None, contact=None, dateStamp=None, metadataStandardName=None, metadataStandardVersion=None, dataSetURI=None, locale=None, spatialRepresentationInfo=None, referenceSystemInfo=None, metadataExtensionInfo=None, identificationInfo=None, contentInfo=None, distributionInfo=None, dataQualityInfo=None, portrayalCatalogueInfo=None, metadataConstraints=None, applicationSchemaInfo=None, metadataMaintenance=None, series=None, describes=None, propertyType=None, featureType=None, featureAttribute=None):
        super(MD_Metadata_Type, self).__init__(id, uuid, )
        self.fileIdentifier = fileIdentifier
        self.language = language
        self.characterSet = characterSet
        self.parentIdentifier = parentIdentifier
        if hierarchyLevel is None:
            self.hierarchyLevel = []
        else:
            self.hierarchyLevel = hierarchyLevel
        if hierarchyLevelName is None:
            self.hierarchyLevelName = []
        else:
            self.hierarchyLevelName = hierarchyLevelName
        if contact is None:
            self.contact = []
        else:
            self.contact = contact
        self.dateStamp = dateStamp
        self.metadataStandardName = metadataStandardName
        self.metadataStandardVersion = metadataStandardVersion
        self.dataSetURI = dataSetURI
        if locale is None:
            self.locale = []
        else:
            self.locale = locale
        if spatialRepresentationInfo is None:
            self.spatialRepresentationInfo = []
        else:
            self.spatialRepresentationInfo = spatialRepresentationInfo
        if referenceSystemInfo is None:
            self.referenceSystemInfo = []
        else:
            self.referenceSystemInfo = referenceSystemInfo
        if metadataExtensionInfo is None:
            self.metadataExtensionInfo = []
        else:
            self.metadataExtensionInfo = metadataExtensionInfo
        if identificationInfo is None:
            self.identificationInfo = []
        else:
            self.identificationInfo = identificationInfo
        if contentInfo is None:
            self.contentInfo = []
        else:
            self.contentInfo = contentInfo
        self.distributionInfo = distributionInfo
        if dataQualityInfo is None:
            self.dataQualityInfo = []
        else:
            self.dataQualityInfo = dataQualityInfo
        if portrayalCatalogueInfo is None:
            self.portrayalCatalogueInfo = []
        else:
            self.portrayalCatalogueInfo = portrayalCatalogueInfo
        if metadataConstraints is None:
            self.metadataConstraints = []
        else:
            self.metadataConstraints = metadataConstraints
        if applicationSchemaInfo is None:
            self.applicationSchemaInfo = []
        else:
            self.applicationSchemaInfo = applicationSchemaInfo
        self.metadataMaintenance = metadataMaintenance
        if series is None:
            self.series = []
        else:
            self.series = series
        if describes is None:
            self.describes = []
        else:
            self.describes = describes
        if propertyType is None:
            self.propertyType = []
        else:
            self.propertyType = propertyType
        if featureType is None:
            self.featureType = []
        else:
            self.featureType = featureType
        if featureAttribute is None:
            self.featureAttribute = []
        else:
            self.featureAttribute = featureAttribute
    def factory(*args_, **kwargs_):
        if MD_Metadata_Type.subclass:
            return MD_Metadata_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Metadata_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileIdentifier(self): return self.fileIdentifier
    def set_fileIdentifier(self, fileIdentifier): self.fileIdentifier = fileIdentifier
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_characterSet(self): return self.characterSet
    def set_characterSet(self, characterSet): self.characterSet = characterSet
    def get_parentIdentifier(self): return self.parentIdentifier
    def set_parentIdentifier(self, parentIdentifier): self.parentIdentifier = parentIdentifier
    def get_hierarchyLevel(self): return self.hierarchyLevel
    def set_hierarchyLevel(self, hierarchyLevel): self.hierarchyLevel = hierarchyLevel
    def add_hierarchyLevel(self, value): self.hierarchyLevel.append(value)
    def insert_hierarchyLevel(self, index, value): self.hierarchyLevel[index] = value
    def get_hierarchyLevelName(self): return self.hierarchyLevelName
    def set_hierarchyLevelName(self, hierarchyLevelName): self.hierarchyLevelName = hierarchyLevelName
    def add_hierarchyLevelName(self, value): self.hierarchyLevelName.append(value)
    def insert_hierarchyLevelName(self, index, value): self.hierarchyLevelName[index] = value
    def get_contact(self): return self.contact
    def set_contact(self, contact): self.contact = contact
    def add_contact(self, value): self.contact.append(value)
    def insert_contact(self, index, value): self.contact[index] = value
    def get_dateStamp(self): return self.dateStamp
    def set_dateStamp(self, dateStamp): self.dateStamp = dateStamp
    def get_metadataStandardName(self): return self.metadataStandardName
    def set_metadataStandardName(self, metadataStandardName): self.metadataStandardName = metadataStandardName
    def get_metadataStandardVersion(self): return self.metadataStandardVersion
    def set_metadataStandardVersion(self, metadataStandardVersion): self.metadataStandardVersion = metadataStandardVersion
    def get_dataSetURI(self): return self.dataSetURI
    def set_dataSetURI(self, dataSetURI): self.dataSetURI = dataSetURI
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def add_locale(self, value): self.locale.append(value)
    def insert_locale(self, index, value): self.locale[index] = value
    def get_spatialRepresentationInfo(self): return self.spatialRepresentationInfo
    def set_spatialRepresentationInfo(self, spatialRepresentationInfo): self.spatialRepresentationInfo = spatialRepresentationInfo
    def add_spatialRepresentationInfo(self, value): self.spatialRepresentationInfo.append(value)
    def insert_spatialRepresentationInfo(self, index, value): self.spatialRepresentationInfo[index] = value
    def get_referenceSystemInfo(self): return self.referenceSystemInfo
    def set_referenceSystemInfo(self, referenceSystemInfo): self.referenceSystemInfo = referenceSystemInfo
    def add_referenceSystemInfo(self, value): self.referenceSystemInfo.append(value)
    def insert_referenceSystemInfo(self, index, value): self.referenceSystemInfo[index] = value
    def get_metadataExtensionInfo(self): return self.metadataExtensionInfo
    def set_metadataExtensionInfo(self, metadataExtensionInfo): self.metadataExtensionInfo = metadataExtensionInfo
    def add_metadataExtensionInfo(self, value): self.metadataExtensionInfo.append(value)
    def insert_metadataExtensionInfo(self, index, value): self.metadataExtensionInfo[index] = value
    def get_identificationInfo(self): return self.identificationInfo
    def set_identificationInfo(self, identificationInfo): self.identificationInfo = identificationInfo
    def add_identificationInfo(self, value): self.identificationInfo.append(value)
    def insert_identificationInfo(self, index, value): self.identificationInfo[index] = value
    def get_contentInfo(self): return self.contentInfo
    def set_contentInfo(self, contentInfo): self.contentInfo = contentInfo
    def add_contentInfo(self, value): self.contentInfo.append(value)
    def insert_contentInfo(self, index, value): self.contentInfo[index] = value
    def get_distributionInfo(self): return self.distributionInfo
    def set_distributionInfo(self, distributionInfo): self.distributionInfo = distributionInfo
    def get_dataQualityInfo(self): return self.dataQualityInfo
    def set_dataQualityInfo(self, dataQualityInfo): self.dataQualityInfo = dataQualityInfo
    def add_dataQualityInfo(self, value): self.dataQualityInfo.append(value)
    def insert_dataQualityInfo(self, index, value): self.dataQualityInfo[index] = value
    def get_portrayalCatalogueInfo(self): return self.portrayalCatalogueInfo
    def set_portrayalCatalogueInfo(self, portrayalCatalogueInfo): self.portrayalCatalogueInfo = portrayalCatalogueInfo
    def add_portrayalCatalogueInfo(self, value): self.portrayalCatalogueInfo.append(value)
    def insert_portrayalCatalogueInfo(self, index, value): self.portrayalCatalogueInfo[index] = value
    def get_metadataConstraints(self): return self.metadataConstraints
    def set_metadataConstraints(self, metadataConstraints): self.metadataConstraints = metadataConstraints
    def add_metadataConstraints(self, value): self.metadataConstraints.append(value)
    def insert_metadataConstraints(self, index, value): self.metadataConstraints[index] = value
    def get_applicationSchemaInfo(self): return self.applicationSchemaInfo
    def set_applicationSchemaInfo(self, applicationSchemaInfo): self.applicationSchemaInfo = applicationSchemaInfo
    def add_applicationSchemaInfo(self, value): self.applicationSchemaInfo.append(value)
    def insert_applicationSchemaInfo(self, index, value): self.applicationSchemaInfo[index] = value
    def get_metadataMaintenance(self): return self.metadataMaintenance
    def set_metadataMaintenance(self, metadataMaintenance): self.metadataMaintenance = metadataMaintenance
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    def add_series(self, value): self.series.append(value)
    def insert_series(self, index, value): self.series[index] = value
    def get_describes(self): return self.describes
    def set_describes(self, describes): self.describes = describes
    def add_describes(self, value): self.describes.append(value)
    def insert_describes(self, index, value): self.describes[index] = value
    def get_propertyType(self): return self.propertyType
    def set_propertyType(self, propertyType): self.propertyType = propertyType
    def add_propertyType(self, value): self.propertyType.append(value)
    def insert_propertyType(self, index, value): self.propertyType[index] = value
    def get_featureType(self): return self.featureType
    def set_featureType(self, featureType): self.featureType = featureType
    def add_featureType(self, value): self.featureType.append(value)
    def insert_featureType(self, index, value): self.featureType[index] = value
    def get_featureAttribute(self): return self.featureAttribute
    def set_featureAttribute(self, featureAttribute): self.featureAttribute = featureAttribute
    def add_featureAttribute(self, value): self.featureAttribute.append(value)
    def insert_featureAttribute(self, index, value): self.featureAttribute[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_Metadata_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Metadata_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Metadata_Type'):
        super(MD_Metadata_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Metadata_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Metadata_Type', fromsubclass_=False):
        super(MD_Metadata_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.fileIdentifier is not None:
            self.fileIdentifier.export(outfile, level, namespace_, name_='fileIdentifier')
        if self.language is not None:
            self.language.export(outfile, level, namespace_, name_='language')
        if self.characterSet is not None:
            self.characterSet.export(outfile, level, namespace_, name_='characterSet')
        if self.parentIdentifier is not None:
            self.parentIdentifier.export(outfile, level, namespace_, name_='parentIdentifier')
        for hierarchyLevel_ in self.hierarchyLevel:
            hierarchyLevel_.export(outfile, level, namespace_, name_='hierarchyLevel')
        for hierarchyLevelName_ in self.hierarchyLevelName:
            hierarchyLevelName_.export(outfile, level, namespace_, name_='hierarchyLevelName')
        for contact_ in self.contact:
            contact_.export(outfile, level, namespace_, name_='contact')
        if self.dateStamp is not None:
            self.dateStamp.export(outfile, level, namespace_, name_='dateStamp', )
        if self.metadataStandardName is not None:
            self.metadataStandardName.export(outfile, level, namespace_, name_='metadataStandardName')
        if self.metadataStandardVersion is not None:
            self.metadataStandardVersion.export(outfile, level, namespace_, name_='metadataStandardVersion')
        if self.dataSetURI is not None:
            self.dataSetURI.export(outfile, level, namespace_, name_='dataSetURI')
        for locale_ in self.locale:
            locale_.export(outfile, level, namespace_, name_='locale')
        for spatialRepresentationInfo_ in self.spatialRepresentationInfo:
            spatialRepresentationInfo_.export(outfile, level, namespace_, name_='spatialRepresentationInfo')
        for referenceSystemInfo_ in self.referenceSystemInfo:
            referenceSystemInfo_.export(outfile, level, namespace_, name_='referenceSystemInfo')
        for metadataExtensionInfo_ in self.metadataExtensionInfo:
            metadataExtensionInfo_.export(outfile, level, namespace_, name_='metadataExtensionInfo')
        for identificationInfo_ in self.identificationInfo:
            identificationInfo_.export(outfile, level, namespace_, name_='identificationInfo')
        for contentInfo_ in self.contentInfo:
            contentInfo_.export(outfile, level, namespace_, name_='contentInfo')
        if self.distributionInfo is not None:
            self.distributionInfo.export(outfile, level, namespace_, name_='distributionInfo')
        for dataQualityInfo_ in self.dataQualityInfo:
            dataQualityInfo_.export(outfile, level, namespace_, name_='dataQualityInfo')
        for portrayalCatalogueInfo_ in self.portrayalCatalogueInfo:
            portrayalCatalogueInfo_.export(outfile, level, namespace_, name_='portrayalCatalogueInfo')
        for metadataConstraints_ in self.metadataConstraints:
            metadataConstraints_.export(outfile, level, namespace_, name_='metadataConstraints')
        for applicationSchemaInfo_ in self.applicationSchemaInfo:
            applicationSchemaInfo_.export(outfile, level, namespace_, name_='applicationSchemaInfo')
        if self.metadataMaintenance is not None:
            self.metadataMaintenance.export(outfile, level, namespace_, name_='metadataMaintenance')
        for series_ in self.series:
            series_.export(outfile, level, namespace_, name_='series')
        for describes_ in self.describes:
            describes_.export(outfile, level, namespace_, name_='describes')
        for propertyType_ in self.propertyType:
            propertyType_.export(outfile, level, namespace_, name_='propertyType')
        for featureType_ in self.featureType:
            featureType_.export(outfile, level, namespace_, name_='featureType')
        for featureAttribute_ in self.featureAttribute:
            featureAttribute_.export(outfile, level, namespace_, name_='featureAttribute')
    def hasContent_(self):
        if (
            self.fileIdentifier is not None or
            self.language is not None or
            self.characterSet is not None or
            self.parentIdentifier is not None or
            self.hierarchyLevel or
            self.hierarchyLevelName or
            self.contact or
            self.dateStamp is not None or
            self.metadataStandardName is not None or
            self.metadataStandardVersion is not None or
            self.dataSetURI is not None or
            self.locale or
            self.spatialRepresentationInfo or
            self.referenceSystemInfo or
            self.metadataExtensionInfo or
            self.identificationInfo or
            self.contentInfo or
            self.distributionInfo is not None or
            self.dataQualityInfo or
            self.portrayalCatalogueInfo or
            self.metadataConstraints or
            self.applicationSchemaInfo or
            self.metadataMaintenance is not None or
            self.series or
            self.describes or
            self.propertyType or
            self.featureType or
            self.featureAttribute or
            super(MD_Metadata_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Metadata_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Metadata_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Metadata_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.fileIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('fileIdentifier=model_.CharacterString_PropertyType(\n')
            self.fileIdentifier.exportLiteral(outfile, level, name_='fileIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.language is not None:
            showIndent(outfile, level)
            outfile.write('language=model_.CharacterString_PropertyType(\n')
            self.language.exportLiteral(outfile, level, name_='language')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.characterSet is not None:
            showIndent(outfile, level)
            outfile.write('characterSet=model_.MD_CharacterSetCode_PropertyType(\n')
            self.characterSet.exportLiteral(outfile, level, name_='characterSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parentIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('parentIdentifier=model_.CharacterString_PropertyType(\n')
            self.parentIdentifier.exportLiteral(outfile, level, name_='parentIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('hierarchyLevel=[\n')
        level += 1
        for hierarchyLevel_ in self.hierarchyLevel:
            showIndent(outfile, level)
            outfile.write('model_.MD_ScopeCode_PropertyType(\n')
            hierarchyLevel_.exportLiteral(outfile, level, name_='MD_ScopeCode_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hierarchyLevelName=[\n')
        level += 1
        for hierarchyLevelName_ in self.hierarchyLevelName:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            hierarchyLevelName_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contact=[\n')
        level += 1
        for contact_ in self.contact:
            showIndent(outfile, level)
            outfile.write('model_.CI_ResponsibleParty_PropertyType(\n')
            contact_.exportLiteral(outfile, level, name_='CI_ResponsibleParty_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.dateStamp is not None:
            showIndent(outfile, level)
            outfile.write('dateStamp=model_.Date_PropertyType(\n')
            self.dateStamp.exportLiteral(outfile, level, name_='dateStamp')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadataStandardName is not None:
            showIndent(outfile, level)
            outfile.write('metadataStandardName=model_.CharacterString_PropertyType(\n')
            self.metadataStandardName.exportLiteral(outfile, level, name_='metadataStandardName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadataStandardVersion is not None:
            showIndent(outfile, level)
            outfile.write('metadataStandardVersion=model_.CharacterString_PropertyType(\n')
            self.metadataStandardVersion.exportLiteral(outfile, level, name_='metadataStandardVersion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataSetURI is not None:
            showIndent(outfile, level)
            outfile.write('dataSetURI=model_.CharacterString_PropertyType(\n')
            self.dataSetURI.exportLiteral(outfile, level, name_='dataSetURI')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('locale=[\n')
        level += 1
        for locale_ in self.locale:
            showIndent(outfile, level)
            outfile.write('model_.PT_Locale_PropertyType(\n')
            locale_.exportLiteral(outfile, level, name_='PT_Locale_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('spatialRepresentationInfo=[\n')
        level += 1
        for spatialRepresentationInfo_ in self.spatialRepresentationInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_SpatialRepresentation_PropertyType(\n')
            spatialRepresentationInfo_.exportLiteral(outfile, level, name_='MD_SpatialRepresentation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('referenceSystemInfo=[\n')
        level += 1
        for referenceSystemInfo_ in self.referenceSystemInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_ReferenceSystem_PropertyType(\n')
            referenceSystemInfo_.exportLiteral(outfile, level, name_='MD_ReferenceSystem_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('metadataExtensionInfo=[\n')
        level += 1
        for metadataExtensionInfo_ in self.metadataExtensionInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_MetadataExtensionInformation_PropertyType(\n')
            metadataExtensionInfo_.exportLiteral(outfile, level, name_='MD_MetadataExtensionInformation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('identificationInfo=[\n')
        level += 1
        for identificationInfo_ in self.identificationInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_Identification_PropertyType(\n')
            identificationInfo_.exportLiteral(outfile, level, name_='MD_Identification_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contentInfo=[\n')
        level += 1
        for contentInfo_ in self.contentInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_ContentInformation_PropertyType(\n')
            contentInfo_.exportLiteral(outfile, level, name_='MD_ContentInformation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.distributionInfo is not None:
            showIndent(outfile, level)
            outfile.write('distributionInfo=model_.MD_Distribution_PropertyType(\n')
            self.distributionInfo.exportLiteral(outfile, level, name_='distributionInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('dataQualityInfo=[\n')
        level += 1
        for dataQualityInfo_ in self.dataQualityInfo:
            showIndent(outfile, level)
            outfile.write('model_.DQ_DataQuality_PropertyType(\n')
            dataQualityInfo_.exportLiteral(outfile, level, name_='DQ_DataQuality_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('portrayalCatalogueInfo=[\n')
        level += 1
        for portrayalCatalogueInfo_ in self.portrayalCatalogueInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_PortrayalCatalogueReference_PropertyType(\n')
            portrayalCatalogueInfo_.exportLiteral(outfile, level, name_='MD_PortrayalCatalogueReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('metadataConstraints=[\n')
        level += 1
        for metadataConstraints_ in self.metadataConstraints:
            showIndent(outfile, level)
            outfile.write('model_.MD_Constraints_PropertyType(\n')
            metadataConstraints_.exportLiteral(outfile, level, name_='MD_Constraints_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('applicationSchemaInfo=[\n')
        level += 1
        for applicationSchemaInfo_ in self.applicationSchemaInfo:
            showIndent(outfile, level)
            outfile.write('model_.MD_ApplicationSchemaInformation_PropertyType(\n')
            applicationSchemaInfo_.exportLiteral(outfile, level, name_='MD_ApplicationSchemaInformation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.metadataMaintenance is not None:
            showIndent(outfile, level)
            outfile.write('metadataMaintenance=model_.MD_MaintenanceInformation_PropertyType(\n')
            self.metadataMaintenance.exportLiteral(outfile, level, name_='metadataMaintenance')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('series=[\n')
        level += 1
        for series_ in self.series:
            showIndent(outfile, level)
            outfile.write('model_.DS_Aggregate_PropertyType(\n')
            series_.exportLiteral(outfile, level, name_='DS_Aggregate_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('describes=[\n')
        level += 1
        for describes_ in self.describes:
            showIndent(outfile, level)
            outfile.write('model_.DS_DataSet_PropertyType(\n')
            describes_.exportLiteral(outfile, level, name_='DS_DataSet_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('propertyType=[\n')
        level += 1
        for propertyType_ in self.propertyType:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReference_PropertyType(\n')
            propertyType_.exportLiteral(outfile, level, name_='ObjectReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('featureType=[\n')
        level += 1
        for featureType_ in self.featureType:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReference_PropertyType(\n')
            featureType_.exportLiteral(outfile, level, name_='ObjectReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('featureAttribute=[\n')
        level += 1
        for featureAttribute_ in self.featureAttribute:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReference_PropertyType(\n')
            featureAttribute_.exportLiteral(outfile, level, name_='ObjectReference_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Metadata_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileIdentifier':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_fileIdentifier(obj_)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_language(obj_)
        elif nodeName_ == 'characterSet':
            obj_ = MD_CharacterSetCode_PropertyType.factory()
            obj_.build(child_)
            self.set_characterSet(obj_)
        elif nodeName_ == 'parentIdentifier':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_parentIdentifier(obj_)
        elif nodeName_ == 'hierarchyLevel':
            obj_ = MD_ScopeCode_PropertyType.factory()
            obj_.build(child_)
            self.hierarchyLevel.append(obj_)
        elif nodeName_ == 'hierarchyLevelName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.hierarchyLevelName.append(obj_)
        elif nodeName_ == 'contact':
            obj_ = CI_ResponsibleParty_PropertyType.factory()
            obj_.build(child_)
            self.contact.append(obj_)
        elif nodeName_ == 'dateStamp':
            obj_ = Date_PropertyType.factory()
            obj_.build(child_)
            self.set_dateStamp(obj_)
        elif nodeName_ == 'metadataStandardName':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_metadataStandardName(obj_)
        elif nodeName_ == 'metadataStandardVersion':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_metadataStandardVersion(obj_)
        elif nodeName_ == 'dataSetURI':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_dataSetURI(obj_)
        elif nodeName_ == 'locale':
            obj_ = PT_Locale_PropertyType.factory()
            obj_.build(child_)
            self.locale.append(obj_)
        elif nodeName_ == 'spatialRepresentationInfo':
            obj_ = MD_SpatialRepresentation_PropertyType.factory()
            obj_.build(child_)
            self.spatialRepresentationInfo.append(obj_)
        elif nodeName_ == 'referenceSystemInfo':
            obj_ = MD_ReferenceSystem_PropertyType.factory()
            obj_.build(child_)
            self.referenceSystemInfo.append(obj_)
        elif nodeName_ == 'metadataExtensionInfo':
            obj_ = MD_MetadataExtensionInformation_PropertyType.factory()
            obj_.build(child_)
            self.metadataExtensionInfo.append(obj_)
        elif nodeName_ == 'identificationInfo':
            obj_ = MD_Identification_PropertyType.factory()
            obj_.build(child_)
            self.identificationInfo.append(obj_)
        elif nodeName_ == 'contentInfo':
            obj_ = MD_ContentInformation_PropertyType.factory()
            obj_.build(child_)
            self.contentInfo.append(obj_)
        elif nodeName_ == 'distributionInfo':
            obj_ = MD_Distribution_PropertyType.factory()
            obj_.build(child_)
            self.set_distributionInfo(obj_)
        elif nodeName_ == 'dataQualityInfo':
            obj_ = DQ_DataQuality_PropertyType.factory()
            obj_.build(child_)
            self.dataQualityInfo.append(obj_)
        elif nodeName_ == 'portrayalCatalogueInfo':
            obj_ = MD_PortrayalCatalogueReference_PropertyType.factory()
            obj_.build(child_)
            self.portrayalCatalogueInfo.append(obj_)
        elif nodeName_ == 'metadataConstraints':
            obj_ = MD_Constraints_PropertyType.factory()
            obj_.build(child_)
            self.metadataConstraints.append(obj_)
        elif nodeName_ == 'applicationSchemaInfo':
            obj_ = MD_ApplicationSchemaInformation_PropertyType.factory()
            obj_.build(child_)
            self.applicationSchemaInfo.append(obj_)
        elif nodeName_ == 'metadataMaintenance':
            obj_ = MD_MaintenanceInformation_PropertyType.factory()
            obj_.build(child_)
            self.set_metadataMaintenance(obj_)
        elif nodeName_ == 'series':
            obj_ = DS_Aggregate_PropertyType.factory()
            obj_.build(child_)
            self.series.append(obj_)
        elif nodeName_ == 'describes':
            obj_ = DS_DataSet_PropertyType.factory()
            obj_.build(child_)
            self.describes.append(obj_)
        elif nodeName_ == 'propertyType':
            class_obj_ = self.get_class_obj_(child_, ObjectReference_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.propertyType.append(obj_)
        elif nodeName_ == 'featureType':
            class_obj_ = self.get_class_obj_(child_, ObjectReference_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.featureType.append(obj_)
        elif nodeName_ == 'featureAttribute':
            class_obj_ = self.get_class_obj_(child_, ObjectReference_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.featureAttribute.append(obj_)
        super(MD_Metadata_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Metadata_Type


class DS_DataSet_Type(AbstractObject_Type):
    """Identifiable collection of data"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, has=None, partOf=None):
        super(DS_DataSet_Type, self).__init__(id, uuid, )
        if has is None:
            self.has = []
        else:
            self.has = has
        if partOf is None:
            self.partOf = []
        else:
            self.partOf = partOf
    def factory(*args_, **kwargs_):
        if DS_DataSet_Type.subclass:
            return DS_DataSet_Type.subclass(*args_, **kwargs_)
        else:
            return DS_DataSet_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_has(self): return self.has
    def set_has(self, has): self.has = has
    def add_has(self, value): self.has.append(value)
    def insert_has(self, index, value): self.has[index] = value
    def get_partOf(self): return self.partOf
    def set_partOf(self, partOf): self.partOf = partOf
    def add_partOf(self, value): self.partOf.append(value)
    def insert_partOf(self, index, value): self.partOf[index] = value
    def export(self, outfile, level, namespace_='', name_='DS_DataSet_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_DataSet_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_DataSet_Type'):
        super(DS_DataSet_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_DataSet_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DS_DataSet_Type', fromsubclass_=False):
        super(DS_DataSet_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for has_ in self.has:
            has_.export(outfile, level, namespace_, name_='has')
        for partOf_ in self.partOf:
            partOf_.export(outfile, level, namespace_, name_='partOf')
    def hasContent_(self):
        if (
            self.has or
            self.partOf or
            super(DS_DataSet_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_DataSet_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_DataSet_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_DataSet_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('has=[\n')
        level += 1
        for has_ in self.has:
            showIndent(outfile, level)
            outfile.write('model_.MD_Metadata_PropertyType(\n')
            has_.exportLiteral(outfile, level, name_='MD_Metadata_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('partOf=[\n')
        level += 1
        for partOf_ in self.partOf:
            showIndent(outfile, level)
            outfile.write('model_.DS_Aggregate_PropertyType(\n')
            partOf_.exportLiteral(outfile, level, name_='DS_Aggregate_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DS_DataSet_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'has':
            obj_ = MD_Metadata_PropertyType.factory()
            obj_.build(child_)
            self.has.append(obj_)
        elif nodeName_ == 'partOf':
            obj_ = DS_Aggregate_PropertyType.factory()
            obj_.build(child_)
            self.partOf.append(obj_)
        super(DS_DataSet_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DS_DataSet_Type


class AbstractDS_Aggregate_Type(AbstractObject_Type):
    """Identifiable collection of datasets"""
    subclass = None
    superclass = AbstractObject_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None, extensiontype_=None):
        super(AbstractDS_Aggregate_Type, self).__init__(id, uuid, extensiontype_, )
        if composedOf is None:
            self.composedOf = []
        else:
            self.composedOf = composedOf
        if seriesMetadata is None:
            self.seriesMetadata = []
        else:
            self.seriesMetadata = seriesMetadata
        if subset is None:
            self.subset = []
        else:
            self.subset = subset
        if superset is None:
            self.superset = []
        else:
            self.superset = superset
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractDS_Aggregate_Type.subclass:
            return AbstractDS_Aggregate_Type.subclass(*args_, **kwargs_)
        else:
            return AbstractDS_Aggregate_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_composedOf(self): return self.composedOf
    def set_composedOf(self, composedOf): self.composedOf = composedOf
    def add_composedOf(self, value): self.composedOf.append(value)
    def insert_composedOf(self, index, value): self.composedOf[index] = value
    def get_seriesMetadata(self): return self.seriesMetadata
    def set_seriesMetadata(self, seriesMetadata): self.seriesMetadata = seriesMetadata
    def add_seriesMetadata(self, value): self.seriesMetadata.append(value)
    def insert_seriesMetadata(self, index, value): self.seriesMetadata[index] = value
    def get_subset(self): return self.subset
    def set_subset(self, subset): self.subset = subset
    def add_subset(self, value): self.subset.append(value)
    def insert_subset(self, index, value): self.subset[index] = value
    def get_superset(self): return self.superset
    def set_superset(self, superset): self.superset = superset
    def add_superset(self, value): self.superset.append(value)
    def insert_superset(self, index, value): self.superset[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractDS_Aggregate_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDS_Aggregate_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDS_Aggregate_Type'):
        super(AbstractDS_Aggregate_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDS_Aggregate_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDS_Aggregate_Type', fromsubclass_=False):
        super(AbstractDS_Aggregate_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for composedOf_ in self.composedOf:
            composedOf_.export(outfile, level, namespace_, name_='composedOf')
        for seriesMetadata_ in self.seriesMetadata:
            seriesMetadata_.export(outfile, level, namespace_, name_='seriesMetadata')
        for subset_ in self.subset:
            subset_.export(outfile, level, namespace_, name_='subset')
        for superset_ in self.superset:
            superset_.export(outfile, level, namespace_, name_='superset')
    def hasContent_(self):
        if (
            self.composedOf or
            self.seriesMetadata or
            self.subset or
            self.superset or
            super(AbstractDS_Aggregate_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractDS_Aggregate_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDS_Aggregate_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDS_Aggregate_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('composedOf=[\n')
        level += 1
        for composedOf_ in self.composedOf:
            showIndent(outfile, level)
            outfile.write('model_.DS_DataSet_PropertyType(\n')
            composedOf_.exportLiteral(outfile, level, name_='DS_DataSet_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('seriesMetadata=[\n')
        level += 1
        for seriesMetadata_ in self.seriesMetadata:
            showIndent(outfile, level)
            outfile.write('model_.MD_Metadata_PropertyType(\n')
            seriesMetadata_.exportLiteral(outfile, level, name_='MD_Metadata_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subset=[\n')
        level += 1
        for subset_ in self.subset:
            showIndent(outfile, level)
            outfile.write('model_.DS_Aggregate_PropertyType(\n')
            subset_.exportLiteral(outfile, level, name_='DS_Aggregate_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('superset=[\n')
        level += 1
        for superset_ in self.superset:
            showIndent(outfile, level)
            outfile.write('model_.DS_Aggregate_PropertyType(\n')
            superset_.exportLiteral(outfile, level, name_='DS_Aggregate_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractDS_Aggregate_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'composedOf':
            obj_ = DS_DataSet_PropertyType.factory()
            obj_.build(child_)
            self.composedOf.append(obj_)
        elif nodeName_ == 'seriesMetadata':
            obj_ = MD_Metadata_PropertyType.factory()
            obj_.build(child_)
            self.seriesMetadata.append(obj_)
        elif nodeName_ == 'subset':
            obj_ = DS_Aggregate_PropertyType.factory()
            obj_.build(child_)
            self.subset.append(obj_)
        elif nodeName_ == 'superset':
            obj_ = DS_Aggregate_PropertyType.factory()
            obj_.build(child_)
            self.superset.append(obj_)
        super(AbstractDS_Aggregate_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractDS_Aggregate_Type


class AbstractCoordinateSystemType(IdentifiedObjectType):
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None, extensiontype_=None):
        super(AbstractCoordinateSystemType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.aggregationType = _cast(None, aggregationType)
        if axis is None:
            self.axis = []
        else:
            self.axis = axis
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractCoordinateSystemType.subclass:
            return AbstractCoordinateSystemType.subclass(*args_, **kwargs_)
        else:
            return AbstractCoordinateSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def add_axis(self, value): self.axis.append(value)
    def insert_axis(self, index, value): self.axis[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractCoordinateSystemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateSystemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractCoordinateSystemType'):
        super(AbstractCoordinateSystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoordinateSystemType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCoordinateSystemType', fromsubclass_=False):
        super(AbstractCoordinateSystemType, self).exportChildren(outfile, level, namespace_, name_, True)
        for axis_ in self.axis:
            axis_.export(outfile, level, namespace_, name_='axis')
    def hasContent_(self):
        if (
            self.axis or
            super(AbstractCoordinateSystemType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCoordinateSystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(AbstractCoordinateSystemType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractCoordinateSystemType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('axis=[\n')
        level += 1
        for axis_ in self.axis:
            showIndent(outfile, level)
            outfile.write('model_.axis(\n')
            axis_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractCoordinateSystemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'axis':
            obj_ = CoordinateSystemAxisPropertyType.factory()
            obj_.build(child_)
            self.axis.append(obj_)
        super(AbstractCoordinateSystemType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractCoordinateSystemType


class CoordinateSystemAxisType(IdentifiedObjectType):
    """The uom attribute provides an identifier of the unit of measure used
    for this coordinate system axis. The value of this coordinate in
    a coordinate tuple shall be recorded using this unit of measure,
    whenever those coordinates use a coordinate reference system
    that uses a coordinate system that uses this axis."""
    subclass = None
    superclass = IdentifiedObjectType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, uom=None, axisAbbrev=None, axisDirection=None, minimumValue=None, maximumValue=None, rangeMeaning=None):
        super(CoordinateSystemAxisType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, )
        self.uom = _cast(None, uom)
        self.axisAbbrev = axisAbbrev
        self.axisDirection = axisDirection
        self.minimumValue = minimumValue
        self.maximumValue = maximumValue
        self.rangeMeaning = rangeMeaning
    def factory(*args_, **kwargs_):
        if CoordinateSystemAxisType.subclass:
            return CoordinateSystemAxisType.subclass(*args_, **kwargs_)
        else:
            return CoordinateSystemAxisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_axisAbbrev(self): return self.axisAbbrev
    def set_axisAbbrev(self, axisAbbrev): self.axisAbbrev = axisAbbrev
    def get_axisDirection(self): return self.axisDirection
    def set_axisDirection(self, axisDirection): self.axisDirection = axisDirection
    def get_minimumValue(self): return self.minimumValue
    def set_minimumValue(self, minimumValue): self.minimumValue = minimumValue
    def get_maximumValue(self): return self.maximumValue
    def set_maximumValue(self, maximumValue): self.maximumValue = maximumValue
    def get_rangeMeaning(self): return self.rangeMeaning
    def set_rangeMeaning(self, rangeMeaning): self.rangeMeaning = rangeMeaning
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    def export(self, outfile, level, namespace_='', name_='CoordinateSystemAxisType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateSystemAxisType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoordinateSystemAxisType'):
        super(CoordinateSystemAxisType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoordinateSystemAxisType')
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            outfile.write(' uom=%s' % (quote_attrib(self.uom), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoordinateSystemAxisType', fromsubclass_=False):
        super(CoordinateSystemAxisType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.axisAbbrev is not None:
            self.axisAbbrev.export(outfile, level, namespace_, name_='axisAbbrev', )
        if self.axisDirection is not None:
            self.axisDirection.export(outfile, level, namespace_, name_='axisDirection', )
        if self.minimumValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sminimumValue>%s</%sminimumValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.minimumValue).encode(ExternalEncoding), input_name='minimumValue'), namespace_))
        if self.maximumValue is not None:
            showIndent(outfile, level)
            outfile.write('<%smaximumValue>%s</%smaximumValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.maximumValue).encode(ExternalEncoding), input_name='maximumValue'), namespace_))
        if self.rangeMeaning is not None:
            self.rangeMeaning.export(outfile, level, namespace_, name_='rangeMeaning')
    def hasContent_(self):
        if (
            self.axisAbbrev is not None or
            self.axisDirection is not None or
            self.minimumValue is not None or
            self.maximumValue is not None or
            self.rangeMeaning is not None or
            super(CoordinateSystemAxisType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoordinateSystemAxisType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            showIndent(outfile, level)
            outfile.write('uom = %s,\n' % (self.uom,))
        super(CoordinateSystemAxisType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CoordinateSystemAxisType, self).exportLiteralChildren(outfile, level, name_)
        if self.axisAbbrev is not None:
            showIndent(outfile, level)
            outfile.write('axisAbbrev=model_.axisAbbrev(\n')
            self.axisAbbrev.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.axisDirection is not None:
            showIndent(outfile, level)
            outfile.write('axisDirection=model_.axisDirection(\n')
            self.axisDirection.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.minimumValue is not None:
            showIndent(outfile, level)
            outfile.write('minimumValue=%s,\n' % quote_python(self.minimumValue).encode(ExternalEncoding))
        if self.maximumValue is not None:
            showIndent(outfile, level)
            outfile.write('maximumValue=%s,\n' % quote_python(self.maximumValue).encode(ExternalEncoding))
        if self.rangeMeaning is not None:
            showIndent(outfile, level)
            outfile.write('rangeMeaning=model_.rangeMeaning(\n')
            self.rangeMeaning.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.append('uom')
            self.uom = value
        super(CoordinateSystemAxisType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'axisAbbrev':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_axisAbbrev(obj_)
        elif nodeName_ == 'axisDirection':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_axisDirection(obj_)
        elif nodeName_ == 'minimumValue':
            minimumValue_ = child_.text
            minimumValue_ = self.gds_validate_string(minimumValue_, node, 'minimumValue')
            self.minimumValue = minimumValue_
        elif nodeName_ == 'maximumValue':
            maximumValue_ = child_.text
            maximumValue_ = self.gds_validate_string(maximumValue_, node, 'maximumValue')
            self.maximumValue = maximumValue_
        elif nodeName_ == 'rangeMeaning':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_rangeMeaning(obj_)
        super(CoordinateSystemAxisType, self).buildChildren(child_, node, nodeName_, True)
# end class CoordinateSystemAxisType


class TemporalCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, timeCS=None, usesTemporalCS=None, temporalDatum=None):
        super(TemporalCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.timeCS = timeCS
        self.usesTemporalCS = usesTemporalCS
        self.temporalDatum = temporalDatum
    def factory(*args_, **kwargs_):
        if TemporalCRSType.subclass:
            return TemporalCRSType.subclass(*args_, **kwargs_)
        else:
            return TemporalCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeCS(self): return self.timeCS
    def set_timeCS(self, timeCS): self.timeCS = timeCS
    def get_usesTemporalCS(self): return self.usesTemporalCS
    def set_usesTemporalCS(self, usesTemporalCS): self.usesTemporalCS = usesTemporalCS
    def get_temporalDatum(self): return self.temporalDatum
    def set_temporalDatum(self, temporalDatum): self.temporalDatum = temporalDatum
    def export(self, outfile, level, namespace_='', name_='TemporalCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TemporalCRSType'):
        super(TemporalCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='TemporalCRSType', fromsubclass_=False):
        super(TemporalCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.timeCS is not None:
            self.timeCS.export(outfile, level, namespace_, name_='timeCS', )
        if self.usesTemporalCS is not None:
            self.usesTemporalCS.export(outfile, level, namespace_, name_='usesTemporalCS', )
        if self.temporalDatum is not None:
            self.temporalDatum.export(outfile, level, namespace_, name_='temporalDatum', )
    def hasContent_(self):
        if (
            self.timeCS is not None or
            self.usesTemporalCS is not None or
            self.temporalDatum is not None or
            super(TemporalCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TemporalCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TemporalCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TemporalCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.timeCS is not None:
            showIndent(outfile, level)
            outfile.write('timeCS=model_.timeCS(\n')
            self.timeCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usesTemporalCS is not None:
            showIndent(outfile, level)
            outfile.write('usesTemporalCS=model_.usesTemporalCS(\n')
            self.usesTemporalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.temporalDatum is not None:
            showIndent(outfile, level)
            outfile.write('temporalDatum=model_.temporalDatum(\n')
            self.temporalDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TemporalCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timeCS':
            obj_ = TimeCSPropertyType.factory()
            obj_.build(child_)
            self.set_timeCS(obj_)
        elif nodeName_ == 'usesTemporalCS':
            obj_ = TemporalCSPropertyType.factory()
            obj_.build(child_)
            self.set_usesTemporalCS(obj_)
        elif nodeName_ == 'temporalDatum':
            obj_ = TemporalDatumPropertyType.factory()
            obj_.build(child_)
            self.set_temporalDatum(obj_)
        super(TemporalCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class TemporalCRSType


class ImageCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, cartesianCS=None, affineCS=None, usesObliqueCartesianCS=None, imageDatum=None):
        super(ImageCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.cartesianCS = cartesianCS
        self.affineCS = affineCS
        self.usesObliqueCartesianCS = usesObliqueCartesianCS
        self.imageDatum = imageDatum
    def factory(*args_, **kwargs_):
        if ImageCRSType.subclass:
            return ImageCRSType.subclass(*args_, **kwargs_)
        else:
            return ImageCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cartesianCS(self): return self.cartesianCS
    def set_cartesianCS(self, cartesianCS): self.cartesianCS = cartesianCS
    def get_affineCS(self): return self.affineCS
    def set_affineCS(self, affineCS): self.affineCS = affineCS
    def get_usesObliqueCartesianCS(self): return self.usesObliqueCartesianCS
    def set_usesObliqueCartesianCS(self, usesObliqueCartesianCS): self.usesObliqueCartesianCS = usesObliqueCartesianCS
    def get_imageDatum(self): return self.imageDatum
    def set_imageDatum(self, imageDatum): self.imageDatum = imageDatum
    def export(self, outfile, level, namespace_='', name_='ImageCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImageCRSType'):
        super(ImageCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ImageCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='ImageCRSType', fromsubclass_=False):
        super(ImageCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.cartesianCS is not None:
            self.cartesianCS.export(outfile, level, namespace_, name_='cartesianCS', )
        if self.affineCS is not None:
            self.affineCS.export(outfile, level, namespace_, name_='affineCS', )
        if self.usesObliqueCartesianCS is not None:
            self.usesObliqueCartesianCS.export(outfile, level, namespace_, name_='usesObliqueCartesianCS', )
        if self.imageDatum is not None:
            self.imageDatum.export(outfile, level, namespace_, name_='imageDatum', )
    def hasContent_(self):
        if (
            self.cartesianCS is not None or
            self.affineCS is not None or
            self.usesObliqueCartesianCS is not None or
            self.imageDatum is not None or
            super(ImageCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImageCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ImageCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ImageCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.cartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('cartesianCS=model_.cartesianCS(\n')
            self.cartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.affineCS is not None:
            showIndent(outfile, level)
            outfile.write('affineCS=model_.affineCS(\n')
            self.affineCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usesObliqueCartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('usesObliqueCartesianCS=model_.usesObliqueCartesianCS(\n')
            self.usesObliqueCartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.imageDatum is not None:
            showIndent(outfile, level)
            outfile.write('imageDatum=model_.imageDatum(\n')
            self.imageDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ImageCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cartesianCS':
            obj_ = CartesianCSPropertyType.factory()
            obj_.build(child_)
            self.set_cartesianCS(obj_)
        elif nodeName_ == 'affineCS':
            obj_ = AffineCSPropertyType.factory()
            obj_.build(child_)
            self.set_affineCS(obj_)
        elif nodeName_ == 'usesObliqueCartesianCS':
            obj_ = ObliqueCartesianCSPropertyType.factory()
            obj_.build(child_)
            self.set_usesObliqueCartesianCS(obj_)
        elif nodeName_ == 'imageDatum':
            obj_ = ImageDatumPropertyType.factory()
            obj_.build(child_)
            self.set_imageDatum(obj_)
        super(ImageCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class ImageCRSType


class EngineeringCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, affineCS=None, cartesianCS=None, cylindricalCS=None, linearCS=None, polarCS=None, sphericalCS=None, userDefinedCS=None, coordinateSystem=None, engineeringDatum=None):
        super(EngineeringCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.affineCS = affineCS
        self.cartesianCS = cartesianCS
        self.cylindricalCS = cylindricalCS
        self.linearCS = linearCS
        self.polarCS = polarCS
        self.sphericalCS = sphericalCS
        self.userDefinedCS = userDefinedCS
        self.coordinateSystem = coordinateSystem
        self.engineeringDatum = engineeringDatum
    def factory(*args_, **kwargs_):
        if EngineeringCRSType.subclass:
            return EngineeringCRSType.subclass(*args_, **kwargs_)
        else:
            return EngineeringCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_affineCS(self): return self.affineCS
    def set_affineCS(self, affineCS): self.affineCS = affineCS
    def get_cartesianCS(self): return self.cartesianCS
    def set_cartesianCS(self, cartesianCS): self.cartesianCS = cartesianCS
    def get_cylindricalCS(self): return self.cylindricalCS
    def set_cylindricalCS(self, cylindricalCS): self.cylindricalCS = cylindricalCS
    def get_linearCS(self): return self.linearCS
    def set_linearCS(self, linearCS): self.linearCS = linearCS
    def get_polarCS(self): return self.polarCS
    def set_polarCS(self, polarCS): self.polarCS = polarCS
    def get_sphericalCS(self): return self.sphericalCS
    def set_sphericalCS(self, sphericalCS): self.sphericalCS = sphericalCS
    def get_userDefinedCS(self): return self.userDefinedCS
    def set_userDefinedCS(self, userDefinedCS): self.userDefinedCS = userDefinedCS
    def get_coordinateSystem(self): return self.coordinateSystem
    def set_coordinateSystem(self, coordinateSystem): self.coordinateSystem = coordinateSystem
    def get_engineeringDatum(self): return self.engineeringDatum
    def set_engineeringDatum(self, engineeringDatum): self.engineeringDatum = engineeringDatum
    def export(self, outfile, level, namespace_='', name_='EngineeringCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EngineeringCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EngineeringCRSType'):
        super(EngineeringCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EngineeringCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='EngineeringCRSType', fromsubclass_=False):
        super(EngineeringCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.affineCS is not None:
            self.affineCS.export(outfile, level, namespace_, name_='affineCS', )
        if self.cartesianCS is not None:
            self.cartesianCS.export(outfile, level, namespace_, name_='cartesianCS', )
        if self.cylindricalCS is not None:
            self.cylindricalCS.export(outfile, level, namespace_, name_='cylindricalCS', )
        if self.linearCS is not None:
            self.linearCS.export(outfile, level, namespace_, name_='linearCS', )
        if self.polarCS is not None:
            self.polarCS.export(outfile, level, namespace_, name_='polarCS', )
        if self.sphericalCS is not None:
            self.sphericalCS.export(outfile, level, namespace_, name_='sphericalCS', )
        if self.userDefinedCS is not None:
            self.userDefinedCS.export(outfile, level, namespace_, name_='userDefinedCS', )
        if self.coordinateSystem is not None:
            self.coordinateSystem.export(outfile, level, namespace_, name_='coordinateSystem', )
        if self.engineeringDatum is not None:
            self.engineeringDatum.export(outfile, level, namespace_, name_='engineeringDatum', )
    def hasContent_(self):
        if (
            self.affineCS is not None or
            self.cartesianCS is not None or
            self.cylindricalCS is not None or
            self.linearCS is not None or
            self.polarCS is not None or
            self.sphericalCS is not None or
            self.userDefinedCS is not None or
            self.coordinateSystem is not None or
            self.engineeringDatum is not None or
            super(EngineeringCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EngineeringCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EngineeringCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EngineeringCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.affineCS is not None:
            showIndent(outfile, level)
            outfile.write('affineCS=model_.affineCS(\n')
            self.affineCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('cartesianCS=model_.cartesianCS(\n')
            self.cartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cylindricalCS is not None:
            showIndent(outfile, level)
            outfile.write('cylindricalCS=model_.cylindricalCS(\n')
            self.cylindricalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.linearCS is not None:
            showIndent(outfile, level)
            outfile.write('linearCS=model_.linearCS(\n')
            self.linearCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.polarCS is not None:
            showIndent(outfile, level)
            outfile.write('polarCS=model_.polarCS(\n')
            self.polarCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sphericalCS is not None:
            showIndent(outfile, level)
            outfile.write('sphericalCS=model_.sphericalCS(\n')
            self.sphericalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.userDefinedCS is not None:
            showIndent(outfile, level)
            outfile.write('userDefinedCS=model_.userDefinedCS(\n')
            self.userDefinedCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinateSystem is not None:
            showIndent(outfile, level)
            outfile.write('coordinateSystem=model_.coordinateSystem(\n')
            self.coordinateSystem.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.engineeringDatum is not None:
            showIndent(outfile, level)
            outfile.write('engineeringDatum=model_.engineeringDatum(\n')
            self.engineeringDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EngineeringCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'affineCS':
            obj_ = AffineCSPropertyType.factory()
            obj_.build(child_)
            self.set_affineCS(obj_)
        elif nodeName_ == 'cartesianCS':
            obj_ = CartesianCSPropertyType.factory()
            obj_.build(child_)
            self.set_cartesianCS(obj_)
        elif nodeName_ == 'cylindricalCS':
            obj_ = CylindricalCSPropertyType.factory()
            obj_.build(child_)
            self.set_cylindricalCS(obj_)
        elif nodeName_ == 'linearCS':
            obj_ = LinearCSPropertyType.factory()
            obj_.build(child_)
            self.set_linearCS(obj_)
        elif nodeName_ == 'polarCS':
            obj_ = PolarCSPropertyType.factory()
            obj_.build(child_)
            self.set_polarCS(obj_)
        elif nodeName_ == 'sphericalCS':
            obj_ = SphericalCSPropertyType.factory()
            obj_.build(child_)
            self.set_sphericalCS(obj_)
        elif nodeName_ == 'userDefinedCS':
            obj_ = UserDefinedCSPropertyType.factory()
            obj_.build(child_)
            self.set_userDefinedCS(obj_)
        elif nodeName_ == 'coordinateSystem':
            obj_ = CoordinateSystemPropertyType.factory()
            obj_.build(child_)
            self.set_coordinateSystem(obj_)
        elif nodeName_ == 'engineeringDatum':
            obj_ = EngineeringDatumPropertyType.factory()
            obj_.build(child_)
            self.set_engineeringDatum(obj_)
        super(EngineeringCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class EngineeringCRSType


class VerticalCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, verticalCS=None, verticalDatum=None):
        super(VerticalCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.verticalCS = verticalCS
        self.verticalDatum = verticalDatum
    def factory(*args_, **kwargs_):
        if VerticalCRSType.subclass:
            return VerticalCRSType.subclass(*args_, **kwargs_)
        else:
            return VerticalCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_verticalCS(self): return self.verticalCS
    def set_verticalCS(self, verticalCS): self.verticalCS = verticalCS
    def get_verticalDatum(self): return self.verticalDatum
    def set_verticalDatum(self, verticalDatum): self.verticalDatum = verticalDatum
    def export(self, outfile, level, namespace_='', name_='VerticalCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerticalCRSType'):
        super(VerticalCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='VerticalCRSType', fromsubclass_=False):
        super(VerticalCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.verticalCS is not None:
            self.verticalCS.export(outfile, level, namespace_, name_='verticalCS', )
        if self.verticalDatum is not None:
            self.verticalDatum.export(outfile, level, namespace_, name_='verticalDatum', )
    def hasContent_(self):
        if (
            self.verticalCS is not None or
            self.verticalDatum is not None or
            super(VerticalCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VerticalCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VerticalCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VerticalCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.verticalCS is not None:
            showIndent(outfile, level)
            outfile.write('verticalCS=model_.verticalCS(\n')
            self.verticalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.verticalDatum is not None:
            showIndent(outfile, level)
            outfile.write('verticalDatum=model_.verticalDatum(\n')
            self.verticalDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'verticalCS':
            obj_ = VerticalCSPropertyType.factory()
            obj_.build(child_)
            self.set_verticalCS(obj_)
        elif nodeName_ == 'verticalDatum':
            obj_ = VerticalDatumPropertyType.factory()
            obj_.build(child_)
            self.set_verticalDatum(obj_)
        super(VerticalCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class VerticalCRSType


class GeodeticCRSType(AbstractCRSType):
    """gml:GeodeticCRS is a coordinate reference system based on a geodetic
    datum."""
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, ellipsoidalCS=None, cartesianCS=None, sphericalCS=None, geodeticDatum=None):
        super(GeodeticCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.ellipsoidalCS = ellipsoidalCS
        self.cartesianCS = cartesianCS
        self.sphericalCS = sphericalCS
        self.geodeticDatum = geodeticDatum
    def factory(*args_, **kwargs_):
        if GeodeticCRSType.subclass:
            return GeodeticCRSType.subclass(*args_, **kwargs_)
        else:
            return GeodeticCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ellipsoidalCS(self): return self.ellipsoidalCS
    def set_ellipsoidalCS(self, ellipsoidalCS): self.ellipsoidalCS = ellipsoidalCS
    def get_cartesianCS(self): return self.cartesianCS
    def set_cartesianCS(self, cartesianCS): self.cartesianCS = cartesianCS
    def get_sphericalCS(self): return self.sphericalCS
    def set_sphericalCS(self, sphericalCS): self.sphericalCS = sphericalCS
    def get_geodeticDatum(self): return self.geodeticDatum
    def set_geodeticDatum(self, geodeticDatum): self.geodeticDatum = geodeticDatum
    def export(self, outfile, level, namespace_='', name_='GeodeticCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeodeticCRSType'):
        super(GeodeticCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeodeticCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='GeodeticCRSType', fromsubclass_=False):
        super(GeodeticCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ellipsoidalCS is not None:
            self.ellipsoidalCS.export(outfile, level, namespace_, name_='ellipsoidalCS', )
        if self.cartesianCS is not None:
            self.cartesianCS.export(outfile, level, namespace_, name_='cartesianCS', )
        if self.sphericalCS is not None:
            self.sphericalCS.export(outfile, level, namespace_, name_='sphericalCS', )
        if self.geodeticDatum is not None:
            self.geodeticDatum.export(outfile, level, namespace_, name_='geodeticDatum', )
    def hasContent_(self):
        if (
            self.ellipsoidalCS is not None or
            self.cartesianCS is not None or
            self.sphericalCS is not None or
            self.geodeticDatum is not None or
            super(GeodeticCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeodeticCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeodeticCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GeodeticCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.ellipsoidalCS is not None:
            showIndent(outfile, level)
            outfile.write('ellipsoidalCS=model_.ellipsoidalCS(\n')
            self.ellipsoidalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('cartesianCS=model_.cartesianCS(\n')
            self.cartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sphericalCS is not None:
            showIndent(outfile, level)
            outfile.write('sphericalCS=model_.sphericalCS(\n')
            self.sphericalCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.geodeticDatum is not None:
            showIndent(outfile, level)
            outfile.write('geodeticDatum=model_.geodeticDatum(\n')
            self.geodeticDatum.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GeodeticCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ellipsoidalCS':
            obj_ = EllipsoidalCSPropertyType.factory()
            obj_.build(child_)
            self.set_ellipsoidalCS(obj_)
        elif nodeName_ == 'cartesianCS':
            obj_ = CartesianCSPropertyType.factory()
            obj_.build(child_)
            self.set_cartesianCS(obj_)
        elif nodeName_ == 'sphericalCS':
            obj_ = SphericalCSPropertyType.factory()
            obj_.build(child_)
            self.set_sphericalCS(obj_)
        elif nodeName_ == 'geodeticDatum':
            obj_ = GeodeticDatumPropertyType.factory()
            obj_.build(child_)
            self.set_geodeticDatum(obj_)
        super(GeodeticCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class GeodeticCRSType


class CompoundCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, aggregationType=None, componentReferenceSystem=None):
        super(CompoundCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, )
        self.aggregationType = _cast(None, aggregationType)
        if componentReferenceSystem is None:
            self.componentReferenceSystem = []
        else:
            self.componentReferenceSystem = componentReferenceSystem
    def factory(*args_, **kwargs_):
        if CompoundCRSType.subclass:
            return CompoundCRSType.subclass(*args_, **kwargs_)
        else:
            return CompoundCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentReferenceSystem(self): return self.componentReferenceSystem
    def set_componentReferenceSystem(self, componentReferenceSystem): self.componentReferenceSystem = componentReferenceSystem
    def add_componentReferenceSystem(self, value): self.componentReferenceSystem.append(value)
    def insert_componentReferenceSystem(self, index, value): self.componentReferenceSystem[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='CompoundCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompoundCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompoundCRSType'):
        super(CompoundCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CompoundCRSType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CompoundCRSType', fromsubclass_=False):
        super(CompoundCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        for componentReferenceSystem_ in self.componentReferenceSystem:
            componentReferenceSystem_.export(outfile, level, namespace_, name_='componentReferenceSystem')
    def hasContent_(self):
        if (
            self.componentReferenceSystem or
            super(CompoundCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CompoundCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(CompoundCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CompoundCRSType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('componentReferenceSystem=[\n')
        level += 1
        for componentReferenceSystem_ in self.componentReferenceSystem:
            showIndent(outfile, level)
            outfile.write('model_.componentReferenceSystem(\n')
            componentReferenceSystem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(CompoundCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentReferenceSystem':
            obj_ = SingleCRSPropertyType.factory()
            obj_.build(child_)
            self.componentReferenceSystem.append(obj_)
        super(CompoundCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class CompoundCRSType


class AbstractGeneralDerivedCRSType(AbstractCRSType):
    subclass = None
    superclass = AbstractCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, conversion=None, extensiontype_=None):
        super(AbstractGeneralDerivedCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, extensiontype_, )
        self.conversion = conversion
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeneralDerivedCRSType.subclass:
            return AbstractGeneralDerivedCRSType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeneralDerivedCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conversion(self): return self.conversion
    def set_conversion(self, conversion): self.conversion = conversion
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeneralDerivedCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralDerivedCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeneralDerivedCRSType'):
        super(AbstractGeneralDerivedCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeneralDerivedCRSType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeneralDerivedCRSType', fromsubclass_=False):
        super(AbstractGeneralDerivedCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.conversion is not None:
            self.conversion.export(outfile, level, namespace_, name_='conversion', )
    def hasContent_(self):
        if (
            self.conversion is not None or
            super(AbstractGeneralDerivedCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeneralDerivedCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractGeneralDerivedCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractGeneralDerivedCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.conversion is not None:
            showIndent(outfile, level)
            outfile.write('conversion=model_.conversion(\n')
            self.conversion.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractGeneralDerivedCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'conversion':
            obj_ = GeneralConversionPropertyType.factory()
            obj_.build(child_)
            self.set_conversion(obj_)
        super(AbstractGeneralDerivedCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractGeneralDerivedCRSType


class AbstractCoverageType(AbstractFeatureType):
    """The base type for coverages is gml:AbstractCoverageType. The basic
    elements of a coverage can be seen in this content model: the
    coverage contains gml:domainSet and gml:rangeSet properties. The
    gml:domainSet property describes the domain of the coverage and
    the gml:rangeSet property describes the range of the coverage."""
    subclass = None
    superclass = AbstractFeatureType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, domainSet=None, rangeSet=None, extensiontype_=None):
        super(AbstractCoverageType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, extensiontype_, )
        self.domainSet = domainSet
        self.rangeSet = rangeSet
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractCoverageType.subclass:
            return AbstractCoverageType.subclass(*args_, **kwargs_)
        else:
            return AbstractCoverageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainSet(self): return self.domainSet
    def set_domainSet(self, domainSet): self.domainSet = domainSet
    def get_rangeSet(self): return self.rangeSet
    def set_rangeSet(self, rangeSet): self.rangeSet = rangeSet
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractCoverageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoverageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractCoverageType'):
        super(AbstractCoverageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCoverageType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCoverageType', fromsubclass_=False):
        super(AbstractCoverageType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.domainSet is not None:
            self.domainSet.export(outfile, level, namespace_, name_='domainSet', )
        if self.rangeSet is not None:
            self.rangeSet.export(outfile, level, namespace_, name_='rangeSet', )
    def hasContent_(self):
        if (
            self.domainSet is not None or
            self.rangeSet is not None or
            super(AbstractCoverageType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCoverageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractCoverageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractCoverageType, self).exportLiteralChildren(outfile, level, name_)
        if self.domainSet is not None:
            showIndent(outfile, level)
            outfile.write('domainSet=model_.domainSet(\n')
            self.domainSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rangeSet is not None:
            showIndent(outfile, level)
            outfile.write('rangeSet=model_.rangeSet(\n')
            self.rangeSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractCoverageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainSet':
            obj_ = DomainSetType.factory()
            obj_.build(child_)
            self.set_domainSet(obj_)
        elif nodeName_ == 'rangeSet':
            obj_ = RangeSetType.factory()
            obj_.build(child_)
            self.set_rangeSet(obj_)
        super(AbstractCoverageType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractCoverageType


class DictionaryEntryType(AbstractMemberType):
    subclass = None
    superclass = AbstractMemberType
    def __init__(self, owns='false', Definition=None):
        super(DictionaryEntryType, self).__init__(owns, )
        self.Definition = Definition
    def factory(*args_, **kwargs_):
        if DictionaryEntryType.subclass:
            return DictionaryEntryType.subclass(*args_, **kwargs_)
        else:
            return DictionaryEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Definition(self): return self.Definition
    def set_Definition(self, Definition): self.Definition = Definition
    def export(self, outfile, level, namespace_='', name_='DictionaryEntryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DictionaryEntryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DictionaryEntryType'):
        super(DictionaryEntryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DictionaryEntryType')
    def exportChildren(self, outfile, level, namespace_='', name_='DictionaryEntryType', fromsubclass_=False):
        super(DictionaryEntryType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Definition is not None:
            self.Definition.export(outfile, level, namespace_, name_='Definition', )
    def hasContent_(self):
        if (
            self.Definition is not None or
            super(DictionaryEntryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DictionaryEntryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DictionaryEntryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DictionaryEntryType, self).exportLiteralChildren(outfile, level, name_)
        if self.Definition is not None:
            showIndent(outfile, level)
            outfile.write('Definition=model_.Definition(\n')
            self.Definition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DictionaryEntryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Definition':
            class_obj_ = self.get_class_obj_(child_, DefinitionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Definition(obj_)
        super(DictionaryEntryType, self).buildChildren(child_, node, nodeName_, True)
# end class DictionaryEntryType


class UnitDefinitionType(DefinitionType):
    subclass = None
    superclass = DefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, quantityType=None, quantityTypeReference=None, catalogSymbol=None, extensiontype_=None):
        super(UnitDefinitionType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, extensiontype_, )
        self.quantityType = quantityType
        self.quantityTypeReference = quantityTypeReference
        self.catalogSymbol = catalogSymbol
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if UnitDefinitionType.subclass:
            return UnitDefinitionType.subclass(*args_, **kwargs_)
        else:
            return UnitDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityType(self): return self.quantityType
    def set_quantityType(self, quantityType): self.quantityType = quantityType
    def get_quantityTypeReference(self): return self.quantityTypeReference
    def set_quantityTypeReference(self, quantityTypeReference): self.quantityTypeReference = quantityTypeReference
    def get_catalogSymbol(self): return self.catalogSymbol
    def set_catalogSymbol(self, catalogSymbol): self.catalogSymbol = catalogSymbol
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='UnitDefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitDefinitionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitDefinitionType'):
        super(UnitDefinitionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnitDefinitionType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='UnitDefinitionType', fromsubclass_=False):
        super(UnitDefinitionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.quantityType is not None:
            self.quantityType.export(outfile, level, namespace_, name_='quantityType')
        if self.quantityTypeReference is not None:
            self.quantityTypeReference.export(outfile, level, namespace_, name_='quantityTypeReference')
        if self.catalogSymbol is not None:
            self.catalogSymbol.export(outfile, level, namespace_, name_='catalogSymbol')
    def hasContent_(self):
        if (
            self.quantityType is not None or
            self.quantityTypeReference is not None or
            self.catalogSymbol is not None or
            super(UnitDefinitionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnitDefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UnitDefinitionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UnitDefinitionType, self).exportLiteralChildren(outfile, level, name_)
        if self.quantityType is not None:
            showIndent(outfile, level)
            outfile.write('quantityType=model_.quantityType(\n')
            self.quantityType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.quantityTypeReference is not None:
            showIndent(outfile, level)
            outfile.write('quantityTypeReference=model_.quantityTypeReference(\n')
            self.quantityTypeReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.catalogSymbol is not None:
            showIndent(outfile, level)
            outfile.write('catalogSymbol=model_.catalogSymbol(\n')
            self.catalogSymbol.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(UnitDefinitionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantityType':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_quantityType(obj_)
        elif nodeName_ == 'quantityTypeReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_quantityTypeReference(obj_)
        elif nodeName_ == 'catalogSymbol':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_catalogSymbol(obj_)
        super(UnitDefinitionType, self).buildChildren(child_, node, nodeName_, True)
# end class UnitDefinitionType


class AngleType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(AngleType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AngleType.subclass:
            return AngleType.subclass(*args_, **kwargs_)
        else:
            return AngleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='AngleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AngleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AngleType'):
        super(AngleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AngleType')
    def exportChildren(self, outfile, level, namespace_='', name_='AngleType', fromsubclass_=False):
        super(AngleType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AngleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AngleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AngleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AngleType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AngleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AngleType


class SpeedType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(SpeedType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SpeedType.subclass:
            return SpeedType.subclass(*args_, **kwargs_)
        else:
            return SpeedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='SpeedType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpeedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpeedType'):
        super(SpeedType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpeedType')
    def exportChildren(self, outfile, level, namespace_='', name_='SpeedType', fromsubclass_=False):
        super(SpeedType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(SpeedType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpeedType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SpeedType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SpeedType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SpeedType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpeedType


class VolumeType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(VolumeType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if VolumeType.subclass:
            return VolumeType.subclass(*args_, **kwargs_)
        else:
            return VolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='VolumeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VolumeType'):
        super(VolumeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeType')
    def exportChildren(self, outfile, level, namespace_='', name_='VolumeType', fromsubclass_=False):
        super(VolumeType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(VolumeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VolumeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VolumeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VolumeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VolumeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VolumeType


class AreaType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(AreaType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AreaType.subclass:
            return AreaType.subclass(*args_, **kwargs_)
        else:
            return AreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='AreaType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AreaType'):
        super(AreaType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AreaType')
    def exportChildren(self, outfile, level, namespace_='', name_='AreaType', fromsubclass_=False):
        super(AreaType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AreaType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AreaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AreaType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AreaType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AreaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaType


class GridLengthType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(GridLengthType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if GridLengthType.subclass:
            return GridLengthType.subclass(*args_, **kwargs_)
        else:
            return GridLengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='GridLengthType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GridLengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GridLengthType'):
        super(GridLengthType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GridLengthType')
    def exportChildren(self, outfile, level, namespace_='', name_='GridLengthType', fromsubclass_=False):
        super(GridLengthType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(GridLengthType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GridLengthType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GridLengthType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GridLengthType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GridLengthType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GridLengthType


class TimeType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(TimeType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimeType.subclass:
            return TimeType.subclass(*args_, **kwargs_)
        else:
            return TimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='TimeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeType'):
        super(TimeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeType', fromsubclass_=False):
        super(TimeType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(TimeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeType


class ScaleType(MeasureType):
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(ScaleType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ScaleType.subclass:
            return ScaleType.subclass(*args_, **kwargs_)
        else:
            return ScaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ScaleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScaleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScaleType'):
        super(ScaleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ScaleType')
    def exportChildren(self, outfile, level, namespace_='', name_='ScaleType', fromsubclass_=False):
        super(ScaleType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ScaleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScaleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ScaleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ScaleType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ScaleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ScaleType


class LengthType(MeasureType):
    """This is a prototypical definition for a specific measure type
    defined as a vacuous extension (i.e. aliases) of
    gml:MeasureType. In this case, the content model supports the
    description of a length (or distance) quantity, with its units.
    The unit of measure referenced by uom shall be suitable for a
    length, such as metres or feet."""
    subclass = None
    superclass = MeasureType
    def __init__(self, uom=None, valueOf_=None):
        super(LengthType, self).__init__(uom, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LengthType.subclass:
            return LengthType.subclass(*args_, **kwargs_)
        else:
            return LengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='LengthType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LengthType'):
        super(LengthType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LengthType')
    def exportChildren(self, outfile, level, namespace_='', name_='LengthType', fromsubclass_=False):
        super(LengthType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LengthType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LengthType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LengthType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LengthType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LengthType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LengthType


class AbstractGeometryType(AbstractGMLType):
    """All geometry elements are derived directly or indirectly from this
    abstract supertype. A geometry element may have an identifying
    attribute (gml:id), one or more names (elements identifier and
    name) and a description (elements description and
    descriptionReference) . It may be associated with a spatial
    reference system (attribute group gml:SRSReferenceGroup). The
    following rules shall be adhered to: - Every geometry type shall
    derive from this abstract type. - Every geometry element (i.e.
    an element of a geometry type) shall be directly or indirectly
    in the substitution group of AbstractGeometry."""
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, extensiontype_=None):
        super(AbstractGeometryType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.srsName = _cast(None, srsName)
        self.srsDimension = _cast(None, srsDimension)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeometryType.subclass:
            return AbstractGeometryType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeometryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_srsName(self): return self.srsName
    def set_srsName(self, srsName): self.srsName = srsName
    def get_srsDimension(self): return self.srsDimension
    def set_srsDimension(self, srsDimension): self.srsDimension = srsDimension
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeometryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeometryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeometryType'):
        super(AbstractGeometryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeometryType')
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            outfile.write(' srsName=%s' % (quote_attrib(self.srsName), ))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            outfile.write(' srsDimension=%s' % (quote_attrib(self.srsDimension), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeometryType', fromsubclass_=False):
        super(AbstractGeometryType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractGeometryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeometryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            showIndent(outfile, level)
            outfile.write('srsName = %s,\n' % (self.srsName,))
        if self.srsDimension is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            showIndent(outfile, level)
            outfile.write('srsDimension = %s,\n' % (self.srsDimension,))
        super(AbstractGeometryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractGeometryType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('srsName', node)
        if value is not None and 'srsName' not in already_processed:
            already_processed.append('srsName')
            self.srsName = value
        value = find_attr_value_('srsDimension', node)
        if value is not None and 'srsDimension' not in already_processed:
            already_processed.append('srsDimension')
            self.srsDimension = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractGeometryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractGeometryType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractGeometryType


class RingType(AbstractRingType):
    subclass = None
    superclass = AbstractRingType
    def __init__(self, aggregationType=None, curveMember=None):
        super(RingType, self).__init__()
        self.aggregationType = _cast(None, aggregationType)
        if curveMember is None:
            self.curveMember = []
        else:
            self.curveMember = curveMember
    def factory(*args_, **kwargs_):
        if RingType.subclass:
            return RingType.subclass(*args_, **kwargs_)
        else:
            return RingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_curveMember(self): return self.curveMember
    def set_curveMember(self, curveMember): self.curveMember = curveMember
    def add_curveMember(self, value): self.curveMember.append(value)
    def insert_curveMember(self, index, value): self.curveMember[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='RingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RingType'):
        super(RingType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RingType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RingType', fromsubclass_=False):
        super(RingType, self).exportChildren(outfile, level, namespace_, name_, True)
        for curveMember_ in self.curveMember:
            curveMember_.export(outfile, level, namespace_, name_='curveMember')
    def hasContent_(self):
        if (
            self.curveMember or
            super(RingType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(RingType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RingType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('curveMember=[\n')
        level += 1
        for curveMember_ in self.curveMember:
            showIndent(outfile, level)
            outfile.write('model_.curveMember(\n')
            curveMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(RingType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'curveMember':
            obj_ = CurvePropertyType.factory()
            obj_.build(child_)
            self.curveMember.append(obj_)
        super(RingType, self).buildChildren(child_, node, nodeName_, True)
# end class RingType


class AbstractGeometricAggregateType(AbstractGeometryType):
    subclass = None
    superclass = AbstractGeometryType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, extensiontype_=None):
        super(AbstractGeometricAggregateType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, extensiontype_, )
        self.aggregationType = _cast(None, aggregationType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeometricAggregateType.subclass:
            return AbstractGeometricAggregateType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeometricAggregateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeometricAggregateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeometricAggregateType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeometricAggregateType'):
        super(AbstractGeometricAggregateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeometricAggregateType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeometricAggregateType', fromsubclass_=False):
        super(AbstractGeometricAggregateType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractGeometricAggregateType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeometricAggregateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(AbstractGeometricAggregateType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractGeometricAggregateType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractGeometricAggregateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractGeometricAggregateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractGeometricAggregateType


class GeometricComplexType(AbstractGeometryType):
    subclass = None
    superclass = AbstractGeometryType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, element=None):
        super(GeometricComplexType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.aggregationType = _cast(None, aggregationType)
        if element is None:
            self.element = []
        else:
            self.element = element
    def factory(*args_, **kwargs_):
        if GeometricComplexType.subclass:
            return GeometricComplexType.subclass(*args_, **kwargs_)
        else:
            return GeometricComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_element(self): return self.element
    def set_element(self, element): self.element = element
    def add_element(self, value): self.element.append(value)
    def insert_element(self, index, value): self.element[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='GeometricComplexType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeometricComplexType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeometricComplexType'):
        super(GeometricComplexType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GeometricComplexType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GeometricComplexType', fromsubclass_=False):
        super(GeometricComplexType, self).exportChildren(outfile, level, namespace_, name_, True)
        for element_ in self.element:
            element_.export(outfile, level, namespace_, name_='element')
    def hasContent_(self):
        if (
            self.element or
            super(GeometricComplexType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeometricComplexType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(GeometricComplexType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GeometricComplexType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('element=[\n')
        level += 1
        for element_ in self.element:
            showIndent(outfile, level)
            outfile.write('model_.GeometricPrimitivePropertyType(\n')
            element_.exportLiteral(outfile, level, name_='GeometricPrimitivePropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(GeometricComplexType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'element':
            obj_ = GeometricPrimitivePropertyType.factory()
            obj_.build(child_)
            self.element.append(obj_)
        super(GeometricComplexType, self).buildChildren(child_, node, nodeName_, True)
# end class GeometricComplexType


class AbstractTopologyType(AbstractGMLType):
    """This abstract type supplies the root or base type for all
    topological elements including primitives and complexes. It
    inherits AbstractGMLType and hence can be identified using the
    gml:id attribute."""
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        super(AbstractTopologyType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTopologyType.subclass:
            return AbstractTopologyType.subclass(*args_, **kwargs_)
        else:
            return AbstractTopologyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTopologyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTopologyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTopologyType'):
        super(AbstractTopologyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTopologyType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTopologyType', fromsubclass_=False):
        super(AbstractTopologyType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractTopologyType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTopologyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractTopologyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTopologyType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTopologyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractTopologyType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractTopologyType


class AbstractTimeSliceType(AbstractGMLType):
    subclass = None
    superclass = AbstractGMLType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, validTime=None, dataSource=None, extensiontype_=None):
        super(AbstractTimeSliceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.validTime = validTime
        self.dataSource = dataSource
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTimeSliceType.subclass:
            return AbstractTimeSliceType.subclass(*args_, **kwargs_)
        else:
            return AbstractTimeSliceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validTime(self): return self.validTime
    def set_validTime(self, validTime): self.validTime = validTime
    def get_dataSource(self): return self.dataSource
    def set_dataSource(self, dataSource): self.dataSource = dataSource
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTimeSliceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeSliceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTimeSliceType'):
        super(AbstractTimeSliceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTimeSliceType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTimeSliceType', fromsubclass_=False):
        super(AbstractTimeSliceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.validTime is not None:
            self.validTime.export(outfile, level, namespace_, name_='validTime', )
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespace_, name_='dataSource')
    def hasContent_(self):
        if (
            self.validTime is not None or
            self.dataSource is not None or
            super(AbstractTimeSliceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTimeSliceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractTimeSliceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTimeSliceType, self).exportLiteralChildren(outfile, level, name_)
        if self.validTime is not None:
            showIndent(outfile, level)
            outfile.write('validTime=model_.validTime(\n')
            self.validTime.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataSource is not None:
            showIndent(outfile, level)
            outfile.write('dataSource=model_.dataSource(\n')
            self.dataSource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTimeSliceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validTime':
            class_obj_ = self.get_class_obj_(child_, TimePrimitivePropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_validTime(obj_)
        elif nodeName_ == 'dataSource':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_dataSource(obj_)
        super(AbstractTimeSliceType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractTimeSliceType


class DynamicFeatureMemberType(AbstractFeatureMemberType):
    subclass = None
    superclass = AbstractFeatureMemberType
    def __init__(self, owns='false', DynamicFeature=None):
        super(DynamicFeatureMemberType, self).__init__(owns, )
        if DynamicFeature is None:
            self.DynamicFeature = []
        else:
            self.DynamicFeature = DynamicFeature
    def factory(*args_, **kwargs_):
        if DynamicFeatureMemberType.subclass:
            return DynamicFeatureMemberType.subclass(*args_, **kwargs_)
        else:
            return DynamicFeatureMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DynamicFeature(self): return self.DynamicFeature
    def set_DynamicFeature(self, DynamicFeature): self.DynamicFeature = DynamicFeature
    def add_DynamicFeature(self, value): self.DynamicFeature.append(value)
    def insert_DynamicFeature(self, index, value): self.DynamicFeature[index] = value
    def export(self, outfile, level, namespace_='', name_='DynamicFeatureMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicFeatureMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DynamicFeatureMemberType'):
        super(DynamicFeatureMemberType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicFeatureMemberType')
    def exportChildren(self, outfile, level, namespace_='', name_='DynamicFeatureMemberType', fromsubclass_=False):
        super(DynamicFeatureMemberType, self).exportChildren(outfile, level, namespace_, name_, True)
        for DynamicFeature_ in self.DynamicFeature:
            DynamicFeature_.export(outfile, level, namespace_, name_='DynamicFeature')
    def hasContent_(self):
        if (
            self.DynamicFeature or
            super(DynamicFeatureMemberType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DynamicFeatureMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DynamicFeatureMemberType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DynamicFeatureMemberType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('DynamicFeature=[\n')
        level += 1
        for DynamicFeature_ in self.DynamicFeature:
            showIndent(outfile, level)
            outfile.write('model_.DynamicFeature(\n')
            DynamicFeature_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DynamicFeatureMemberType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DynamicFeature':
            class_obj_ = self.get_class_obj_(child_, DynamicFeatureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DynamicFeature.append(obj_)
        super(DynamicFeatureMemberType, self).buildChildren(child_, node, nodeName_, True)
# end class DynamicFeatureMemberType


class DynamicFeatureType(AbstractFeatureType):
    subclass = None
    superclass = AbstractFeatureType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, validTime=None, history=None, dataSource=None, dataSourceReference=None, extensiontype_=None):
        super(DynamicFeatureType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, extensiontype_, )
        self.validTime = validTime
        self.history = history
        self.dataSource = dataSource
        self.dataSourceReference = dataSourceReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DynamicFeatureType.subclass:
            return DynamicFeatureType.subclass(*args_, **kwargs_)
        else:
            return DynamicFeatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validTime(self): return self.validTime
    def set_validTime(self, validTime): self.validTime = validTime
    def get_history(self): return self.history
    def set_history(self, history): self.history = history
    def get_dataSource(self): return self.dataSource
    def set_dataSource(self, dataSource): self.dataSource = dataSource
    def get_dataSourceReference(self): return self.dataSourceReference
    def set_dataSourceReference(self, dataSourceReference): self.dataSourceReference = dataSourceReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DynamicFeatureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicFeatureType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DynamicFeatureType'):
        super(DynamicFeatureType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicFeatureType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DynamicFeatureType', fromsubclass_=False):
        super(DynamicFeatureType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.validTime is not None:
            self.validTime.export(outfile, level, namespace_, name_='validTime')
        if self.history is not None:
            self.history.export(outfile, level, namespace_, name_='history')
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespace_, name_='dataSource')
        if self.dataSourceReference is not None:
            self.dataSourceReference.export(outfile, level, namespace_, name_='dataSourceReference')
    def hasContent_(self):
        if (
            self.validTime is not None or
            self.history is not None or
            self.dataSource is not None or
            self.dataSourceReference is not None or
            super(DynamicFeatureType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DynamicFeatureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DynamicFeatureType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DynamicFeatureType, self).exportLiteralChildren(outfile, level, name_)
        if self.validTime is not None:
            showIndent(outfile, level)
            outfile.write('validTime=model_.validTime(\n')
            self.validTime.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.history is not None:
            showIndent(outfile, level)
            outfile.write('history=model_.history(\n')
            self.history.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataSource is not None:
            showIndent(outfile, level)
            outfile.write('dataSource=model_.dataSource(\n')
            self.dataSource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataSourceReference is not None:
            showIndent(outfile, level)
            outfile.write('dataSourceReference=model_.dataSourceReference(\n')
            self.dataSourceReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(DynamicFeatureType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validTime':
            class_obj_ = self.get_class_obj_(child_, TimePrimitivePropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_validTime(obj_)
        elif nodeName_ == 'history':
            obj_ = HistoryPropertyType.factory()
            obj_.build(child_)
            self.set_history(obj_)
        elif nodeName_ == 'dataSource':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_dataSource(obj_)
        elif nodeName_ == 'dataSourceReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_dataSourceReference(obj_)
        super(DynamicFeatureType, self).buildChildren(child_, node, nodeName_, True)
# end class DynamicFeatureType


class StopsResponseType(AbstractResponseType):
    """Structure de requête du service de collecte des arrêts d'un SIM"""
    subclass = None
    superclass = AbstractResponseType
    def __init__(self, RequestId=None, ResponseDefaults=None, Status=None, PublicationDelivery=None):
        super(StopsResponseType, self).__init__(RequestId, ResponseDefaults, )
        self.Status = Status
        self.PublicationDelivery = PublicationDelivery
    def factory(*args_, **kwargs_):
        if StopsResponseType.subclass:
            return StopsResponseType.subclass(*args_, **kwargs_)
        else:
            return StopsResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_PublicationDelivery(self): return self.PublicationDelivery
    def set_PublicationDelivery(self, PublicationDelivery): self.PublicationDelivery = PublicationDelivery
    def export(self, outfile, level, namespace_='', name_='StopsResponseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StopsResponseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StopsResponseType'):
        super(StopsResponseType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StopsResponseType')
    def exportChildren(self, outfile, level, namespace_='', name_='StopsResponseType', fromsubclass_=False):
        super(StopsResponseType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Status is not None:
            self.Status.export(outfile, level, namespace_, name_='Status', )
        if self.PublicationDelivery is not None:
            self.PublicationDelivery.export(outfile, level, namespace_, name_='PublicationDelivery', )
    def hasContent_(self):
        if (
            self.Status is not None or
            self.PublicationDelivery is not None or
            super(StopsResponseType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StopsResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StopsResponseType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StopsResponseType, self).exportLiteralChildren(outfile, level, name_)
        if self.Status is not None:
            showIndent(outfile, level)
            outfile.write('Status=model_.StatusType(\n')
            self.Status.exportLiteral(outfile, level, name_='Status')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PublicationDelivery is not None:
            showIndent(outfile, level)
            outfile.write('PublicationDelivery=model_.PublicationDeliveryType(\n')
            self.PublicationDelivery.exportLiteral(outfile, level, name_='PublicationDelivery')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StopsResponseType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Status':
            obj_ = StatusType.factory()
            obj_.build(child_)
            self.set_Status(obj_)
        elif nodeName_ == 'PublicationDelivery':
            obj_ = PublicationDeliveryType.factory()
            obj_.build(child_)
            self.set_PublicationDelivery(obj_)
        super(StopsResponseType, self).buildChildren(child_, node, nodeName_, True)
# end class StopsResponseType


class MovingObjectStatusType(AbstractTimeSliceType):
    subclass = None
    superclass = AbstractTimeSliceType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, validTime=None, dataSource=None, position=None, pos=None, locationName=None, locationReference=None, location=None, speed=None, bearing=None, acceleration=None, elevation=None, status=None, statusReference=None):
        super(MovingObjectStatusType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, validTime, dataSource, )
        self.position = position
        self.pos = pos
        self.locationName = locationName
        self.locationReference = locationReference
        self.location = location
        self.speed = speed
        self.bearing = bearing
        self.acceleration = acceleration
        self.elevation = elevation
        self.status = status
        self.statusReference = statusReference
    def factory(*args_, **kwargs_):
        if MovingObjectStatusType.subclass:
            return MovingObjectStatusType.subclass(*args_, **kwargs_)
        else:
            return MovingObjectStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def get_locationName(self): return self.locationName
    def set_locationName(self, locationName): self.locationName = locationName
    def get_locationReference(self): return self.locationReference
    def set_locationReference(self, locationReference): self.locationReference = locationReference
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_speed(self): return self.speed
    def set_speed(self, speed): self.speed = speed
    def get_bearing(self): return self.bearing
    def set_bearing(self, bearing): self.bearing = bearing
    def get_acceleration(self): return self.acceleration
    def set_acceleration(self, acceleration): self.acceleration = acceleration
    def get_elevation(self): return self.elevation
    def set_elevation(self, elevation): self.elevation = elevation
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_statusReference(self): return self.statusReference
    def set_statusReference(self, statusReference): self.statusReference = statusReference
    def export(self, outfile, level, namespace_='', name_='MovingObjectStatusType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MovingObjectStatusType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MovingObjectStatusType'):
        super(MovingObjectStatusType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MovingObjectStatusType')
    def exportChildren(self, outfile, level, namespace_='', name_='MovingObjectStatusType', fromsubclass_=False):
        super(MovingObjectStatusType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.position is not None:
            self.position.export(outfile, level, namespace_, name_='position', )
        if self.pos is not None:
            self.pos.export(outfile, level, namespace_, name_='pos', )
        if self.locationName is not None:
            self.locationName.export(outfile, level, namespace_, name_='locationName', )
        if self.locationReference is not None:
            self.locationReference.export(outfile, level, namespace_, name_='locationReference', )
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', )
        if self.speed is not None:
            self.speed.export(outfile, level, namespace_, name_='speed')
        if self.bearing is not None:
            self.bearing.export(outfile, level, namespace_, name_='bearing')
        if self.acceleration is not None:
            self.acceleration.export(outfile, level, namespace_, name_='acceleration')
        if self.elevation is not None:
            self.elevation.export(outfile, level, namespace_, name_='elevation')
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status')
        if self.statusReference is not None:
            self.statusReference.export(outfile, level, namespace_, name_='statusReference')
    def hasContent_(self):
        if (
            self.position is not None or
            self.pos is not None or
            self.locationName is not None or
            self.locationReference is not None or
            self.location is not None or
            self.speed is not None or
            self.bearing is not None or
            self.acceleration is not None or
            self.elevation is not None or
            self.status is not None or
            self.statusReference is not None or
            super(MovingObjectStatusType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MovingObjectStatusType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MovingObjectStatusType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MovingObjectStatusType, self).exportLiteralChildren(outfile, level, name_)
        if self.position is not None:
            showIndent(outfile, level)
            outfile.write('position=model_.GeometryPropertyType(\n')
            self.position.exportLiteral(outfile, level, name_='position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=model_.pos(\n')
            self.pos.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.locationName is not None:
            showIndent(outfile, level)
            outfile.write('locationName=model_.locationName(\n')
            self.locationName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.locationReference is not None:
            showIndent(outfile, level)
            outfile.write('locationReference=model_.locationReference(\n')
            self.locationReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.location(\n')
            self.location.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.speed is not None:
            showIndent(outfile, level)
            outfile.write('speed=model_.MeasureType(\n')
            self.speed.exportLiteral(outfile, level, name_='speed')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bearing is not None:
            showIndent(outfile, level)
            outfile.write('bearing=model_.DirectionPropertyType(\n')
            self.bearing.exportLiteral(outfile, level, name_='bearing')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.acceleration is not None:
            showIndent(outfile, level)
            outfile.write('acceleration=model_.MeasureType(\n')
            self.acceleration.exportLiteral(outfile, level, name_='acceleration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.elevation is not None:
            showIndent(outfile, level)
            outfile.write('elevation=model_.MeasureType(\n')
            self.elevation.exportLiteral(outfile, level, name_='elevation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=model_.status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.statusReference is not None:
            showIndent(outfile, level)
            outfile.write('statusReference=model_.statusReference(\n')
            self.statusReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MovingObjectStatusType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'position':
            obj_ = GeometryPropertyType.factory()
            obj_.build(child_)
            self.set_position(obj_)
        elif nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_pos(obj_)
        elif nodeName_ == 'locationName':
            class_obj_ = self.get_class_obj_(child_, CodeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_locationName(obj_)
        elif nodeName_ == 'locationReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_locationReference(obj_)
        elif nodeName_ == 'location':
            class_obj_ = self.get_class_obj_(child_, LocationPropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_location(obj_)
        elif nodeName_ == 'speed':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_speed(obj_)
        elif nodeName_ == 'bearing':
            obj_ = DirectionPropertyType.factory()
            obj_.build(child_)
            self.set_bearing(obj_)
        elif nodeName_ == 'acceleration':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_acceleration(obj_)
        elif nodeName_ == 'elevation':
            class_obj_ = self.get_class_obj_(child_, MeasureType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_elevation(obj_)
        elif nodeName_ == 'status':
            obj_ = StringOrRefType.factory()
            obj_.build(child_)
            self.set_status(obj_)
        elif nodeName_ == 'statusReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_statusReference(obj_)
        super(MovingObjectStatusType, self).buildChildren(child_, node, nodeName_, True)
# end class MovingObjectStatusType


class ObliqueCartesianCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(ObliqueCartesianCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if ObliqueCartesianCSType.subclass:
            return ObliqueCartesianCSType.subclass(*args_, **kwargs_)
        else:
            return ObliqueCartesianCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ObliqueCartesianCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObliqueCartesianCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObliqueCartesianCSType'):
        super(ObliqueCartesianCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObliqueCartesianCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='ObliqueCartesianCSType', fromsubclass_=False):
        super(ObliqueCartesianCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(ObliqueCartesianCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObliqueCartesianCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ObliqueCartesianCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObliqueCartesianCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ObliqueCartesianCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ObliqueCartesianCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ObliqueCartesianCSType


class TemporalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(TemporalCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if TemporalCSType.subclass:
            return TemporalCSType.subclass(*args_, **kwargs_)
        else:
            return TemporalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='TemporalCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TemporalCSType'):
        super(TemporalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='TemporalCSType', fromsubclass_=False):
        super(TemporalCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(TemporalCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TemporalCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TemporalCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TemporalCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TemporalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TemporalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TemporalCSType


class MD_ImageDescription_Type(MD_CoverageDescription_Type):
    """Information about an image's suitability for use"""
    subclass = None
    superclass = MD_CoverageDescription_Type
    def __init__(self, id=None, uuid=None, attributeDescription=None, contentType=None, dimension=None, illuminationElevationAngle=None, illuminationAzimuthAngle=None, imagingCondition=None, imageQualityCode=None, cloudCoverPercentage=None, processingLevelCode=None, compressionGenerationQuantity=None, triangulationIndicator=None, radiometricCalibrationDataAvailability=None, cameraCalibrationInformationAvailability=None, filmDistortionInformationAvailability=None, lensDistortionInformationAvailability=None):
        super(MD_ImageDescription_Type, self).__init__(id, uuid, attributeDescription, contentType, dimension, )
        self.illuminationElevationAngle = illuminationElevationAngle
        self.illuminationAzimuthAngle = illuminationAzimuthAngle
        self.imagingCondition = imagingCondition
        self.imageQualityCode = imageQualityCode
        self.cloudCoverPercentage = cloudCoverPercentage
        self.processingLevelCode = processingLevelCode
        self.compressionGenerationQuantity = compressionGenerationQuantity
        self.triangulationIndicator = triangulationIndicator
        self.radiometricCalibrationDataAvailability = radiometricCalibrationDataAvailability
        self.cameraCalibrationInformationAvailability = cameraCalibrationInformationAvailability
        self.filmDistortionInformationAvailability = filmDistortionInformationAvailability
        self.lensDistortionInformationAvailability = lensDistortionInformationAvailability
    def factory(*args_, **kwargs_):
        if MD_ImageDescription_Type.subclass:
            return MD_ImageDescription_Type.subclass(*args_, **kwargs_)
        else:
            return MD_ImageDescription_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_illuminationElevationAngle(self): return self.illuminationElevationAngle
    def set_illuminationElevationAngle(self, illuminationElevationAngle): self.illuminationElevationAngle = illuminationElevationAngle
    def get_illuminationAzimuthAngle(self): return self.illuminationAzimuthAngle
    def set_illuminationAzimuthAngle(self, illuminationAzimuthAngle): self.illuminationAzimuthAngle = illuminationAzimuthAngle
    def get_imagingCondition(self): return self.imagingCondition
    def set_imagingCondition(self, imagingCondition): self.imagingCondition = imagingCondition
    def get_imageQualityCode(self): return self.imageQualityCode
    def set_imageQualityCode(self, imageQualityCode): self.imageQualityCode = imageQualityCode
    def get_cloudCoverPercentage(self): return self.cloudCoverPercentage
    def set_cloudCoverPercentage(self, cloudCoverPercentage): self.cloudCoverPercentage = cloudCoverPercentage
    def get_processingLevelCode(self): return self.processingLevelCode
    def set_processingLevelCode(self, processingLevelCode): self.processingLevelCode = processingLevelCode
    def get_compressionGenerationQuantity(self): return self.compressionGenerationQuantity
    def set_compressionGenerationQuantity(self, compressionGenerationQuantity): self.compressionGenerationQuantity = compressionGenerationQuantity
    def get_triangulationIndicator(self): return self.triangulationIndicator
    def set_triangulationIndicator(self, triangulationIndicator): self.triangulationIndicator = triangulationIndicator
    def get_radiometricCalibrationDataAvailability(self): return self.radiometricCalibrationDataAvailability
    def set_radiometricCalibrationDataAvailability(self, radiometricCalibrationDataAvailability): self.radiometricCalibrationDataAvailability = radiometricCalibrationDataAvailability
    def get_cameraCalibrationInformationAvailability(self): return self.cameraCalibrationInformationAvailability
    def set_cameraCalibrationInformationAvailability(self, cameraCalibrationInformationAvailability): self.cameraCalibrationInformationAvailability = cameraCalibrationInformationAvailability
    def get_filmDistortionInformationAvailability(self): return self.filmDistortionInformationAvailability
    def set_filmDistortionInformationAvailability(self, filmDistortionInformationAvailability): self.filmDistortionInformationAvailability = filmDistortionInformationAvailability
    def get_lensDistortionInformationAvailability(self): return self.lensDistortionInformationAvailability
    def set_lensDistortionInformationAvailability(self, lensDistortionInformationAvailability): self.lensDistortionInformationAvailability = lensDistortionInformationAvailability
    def export(self, outfile, level, namespace_='', name_='MD_ImageDescription_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ImageDescription_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_ImageDescription_Type'):
        super(MD_ImageDescription_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_ImageDescription_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_ImageDescription_Type', fromsubclass_=False):
        super(MD_ImageDescription_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.illuminationElevationAngle is not None:
            self.illuminationElevationAngle.export(outfile, level, namespace_, name_='illuminationElevationAngle')
        if self.illuminationAzimuthAngle is not None:
            self.illuminationAzimuthAngle.export(outfile, level, namespace_, name_='illuminationAzimuthAngle')
        if self.imagingCondition is not None:
            self.imagingCondition.export(outfile, level, namespace_, name_='imagingCondition')
        if self.imageQualityCode is not None:
            self.imageQualityCode.export(outfile, level, namespace_, name_='imageQualityCode')
        if self.cloudCoverPercentage is not None:
            self.cloudCoverPercentage.export(outfile, level, namespace_, name_='cloudCoverPercentage')
        if self.processingLevelCode is not None:
            self.processingLevelCode.export(outfile, level, namespace_, name_='processingLevelCode')
        if self.compressionGenerationQuantity is not None:
            self.compressionGenerationQuantity.export(outfile, level, namespace_, name_='compressionGenerationQuantity')
        if self.triangulationIndicator is not None:
            self.triangulationIndicator.export(outfile, level, namespace_, name_='triangulationIndicator')
        if self.radiometricCalibrationDataAvailability is not None:
            self.radiometricCalibrationDataAvailability.export(outfile, level, namespace_, name_='radiometricCalibrationDataAvailability')
        if self.cameraCalibrationInformationAvailability is not None:
            self.cameraCalibrationInformationAvailability.export(outfile, level, namespace_, name_='cameraCalibrationInformationAvailability')
        if self.filmDistortionInformationAvailability is not None:
            self.filmDistortionInformationAvailability.export(outfile, level, namespace_, name_='filmDistortionInformationAvailability')
        if self.lensDistortionInformationAvailability is not None:
            self.lensDistortionInformationAvailability.export(outfile, level, namespace_, name_='lensDistortionInformationAvailability')
    def hasContent_(self):
        if (
            self.illuminationElevationAngle is not None or
            self.illuminationAzimuthAngle is not None or
            self.imagingCondition is not None or
            self.imageQualityCode is not None or
            self.cloudCoverPercentage is not None or
            self.processingLevelCode is not None or
            self.compressionGenerationQuantity is not None or
            self.triangulationIndicator is not None or
            self.radiometricCalibrationDataAvailability is not None or
            self.cameraCalibrationInformationAvailability is not None or
            self.filmDistortionInformationAvailability is not None or
            self.lensDistortionInformationAvailability is not None or
            super(MD_ImageDescription_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_ImageDescription_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_ImageDescription_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_ImageDescription_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.illuminationElevationAngle is not None:
            showIndent(outfile, level)
            outfile.write('illuminationElevationAngle=model_.Real_PropertyType(\n')
            self.illuminationElevationAngle.exportLiteral(outfile, level, name_='illuminationElevationAngle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.illuminationAzimuthAngle is not None:
            showIndent(outfile, level)
            outfile.write('illuminationAzimuthAngle=model_.Real_PropertyType(\n')
            self.illuminationAzimuthAngle.exportLiteral(outfile, level, name_='illuminationAzimuthAngle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.imagingCondition is not None:
            showIndent(outfile, level)
            outfile.write('imagingCondition=model_.MD_ImagingConditionCode_PropertyType(\n')
            self.imagingCondition.exportLiteral(outfile, level, name_='imagingCondition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.imageQualityCode is not None:
            showIndent(outfile, level)
            outfile.write('imageQualityCode=model_.MD_Identifier_PropertyType(\n')
            self.imageQualityCode.exportLiteral(outfile, level, name_='imageQualityCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cloudCoverPercentage is not None:
            showIndent(outfile, level)
            outfile.write('cloudCoverPercentage=model_.Real_PropertyType(\n')
            self.cloudCoverPercentage.exportLiteral(outfile, level, name_='cloudCoverPercentage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.processingLevelCode is not None:
            showIndent(outfile, level)
            outfile.write('processingLevelCode=model_.MD_Identifier_PropertyType(\n')
            self.processingLevelCode.exportLiteral(outfile, level, name_='processingLevelCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.compressionGenerationQuantity is not None:
            showIndent(outfile, level)
            outfile.write('compressionGenerationQuantity=model_.Integer_PropertyType(\n')
            self.compressionGenerationQuantity.exportLiteral(outfile, level, name_='compressionGenerationQuantity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.triangulationIndicator is not None:
            showIndent(outfile, level)
            outfile.write('triangulationIndicator=model_.Boolean_PropertyType(\n')
            self.triangulationIndicator.exportLiteral(outfile, level, name_='triangulationIndicator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.radiometricCalibrationDataAvailability is not None:
            showIndent(outfile, level)
            outfile.write('radiometricCalibrationDataAvailability=model_.Boolean_PropertyType(\n')
            self.radiometricCalibrationDataAvailability.exportLiteral(outfile, level, name_='radiometricCalibrationDataAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cameraCalibrationInformationAvailability is not None:
            showIndent(outfile, level)
            outfile.write('cameraCalibrationInformationAvailability=model_.Boolean_PropertyType(\n')
            self.cameraCalibrationInformationAvailability.exportLiteral(outfile, level, name_='cameraCalibrationInformationAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filmDistortionInformationAvailability is not None:
            showIndent(outfile, level)
            outfile.write('filmDistortionInformationAvailability=model_.Boolean_PropertyType(\n')
            self.filmDistortionInformationAvailability.exportLiteral(outfile, level, name_='filmDistortionInformationAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lensDistortionInformationAvailability is not None:
            showIndent(outfile, level)
            outfile.write('lensDistortionInformationAvailability=model_.Boolean_PropertyType(\n')
            self.lensDistortionInformationAvailability.exportLiteral(outfile, level, name_='lensDistortionInformationAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_ImageDescription_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'illuminationElevationAngle':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_illuminationElevationAngle(obj_)
        elif nodeName_ == 'illuminationAzimuthAngle':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_illuminationAzimuthAngle(obj_)
        elif nodeName_ == 'imagingCondition':
            obj_ = MD_ImagingConditionCode_PropertyType.factory()
            obj_.build(child_)
            self.set_imagingCondition(obj_)
        elif nodeName_ == 'imageQualityCode':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.set_imageQualityCode(obj_)
        elif nodeName_ == 'cloudCoverPercentage':
            obj_ = Real_PropertyType.factory()
            obj_.build(child_)
            self.set_cloudCoverPercentage(obj_)
        elif nodeName_ == 'processingLevelCode':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.set_processingLevelCode(obj_)
        elif nodeName_ == 'compressionGenerationQuantity':
            obj_ = Integer_PropertyType.factory()
            obj_.build(child_)
            self.set_compressionGenerationQuantity(obj_)
        elif nodeName_ == 'triangulationIndicator':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_triangulationIndicator(obj_)
        elif nodeName_ == 'radiometricCalibrationDataAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_radiometricCalibrationDataAvailability(obj_)
        elif nodeName_ == 'cameraCalibrationInformationAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_cameraCalibrationInformationAvailability(obj_)
        elif nodeName_ == 'filmDistortionInformationAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_filmDistortionInformationAvailability(obj_)
        elif nodeName_ == 'lensDistortionInformationAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_lensDistortionInformationAvailability(obj_)
        super(MD_ImageDescription_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_ImageDescription_Type


class EX_GeographicDescription_Type(AbstractEX_GeographicExtent_Type):
    subclass = None
    superclass = AbstractEX_GeographicExtent_Type
    def __init__(self, id=None, uuid=None, extentTypeCode=None, geographicIdentifier=None):
        super(EX_GeographicDescription_Type, self).__init__(id, uuid, extentTypeCode, )
        self.geographicIdentifier = geographicIdentifier
    def factory(*args_, **kwargs_):
        if EX_GeographicDescription_Type.subclass:
            return EX_GeographicDescription_Type.subclass(*args_, **kwargs_)
        else:
            return EX_GeographicDescription_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geographicIdentifier(self): return self.geographicIdentifier
    def set_geographicIdentifier(self, geographicIdentifier): self.geographicIdentifier = geographicIdentifier
    def export(self, outfile, level, namespace_='', name_='EX_GeographicDescription_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicDescription_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_GeographicDescription_Type'):
        super(EX_GeographicDescription_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicDescription_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EX_GeographicDescription_Type', fromsubclass_=False):
        super(EX_GeographicDescription_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.geographicIdentifier is not None:
            self.geographicIdentifier.export(outfile, level, namespace_, name_='geographicIdentifier', )
    def hasContent_(self):
        if (
            self.geographicIdentifier is not None or
            super(EX_GeographicDescription_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_GeographicDescription_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EX_GeographicDescription_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EX_GeographicDescription_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.geographicIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('geographicIdentifier=model_.MD_Identifier_PropertyType(\n')
            self.geographicIdentifier.exportLiteral(outfile, level, name_='geographicIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_GeographicDescription_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geographicIdentifier':
            obj_ = MD_Identifier_PropertyType.factory()
            obj_.build(child_)
            self.set_geographicIdentifier(obj_)
        super(EX_GeographicDescription_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_GeographicDescription_Type


class EX_SpatialTemporalExtent_Type(EX_TemporalExtent_Type):
    """Extent with respect to date and time"""
    subclass = None
    superclass = EX_TemporalExtent_Type
    def __init__(self, id=None, uuid=None, extent=None, spatialExtent=None):
        super(EX_SpatialTemporalExtent_Type, self).__init__(id, uuid, extent, )
        if spatialExtent is None:
            self.spatialExtent = []
        else:
            self.spatialExtent = spatialExtent
    def factory(*args_, **kwargs_):
        if EX_SpatialTemporalExtent_Type.subclass:
            return EX_SpatialTemporalExtent_Type.subclass(*args_, **kwargs_)
        else:
            return EX_SpatialTemporalExtent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spatialExtent(self): return self.spatialExtent
    def set_spatialExtent(self, spatialExtent): self.spatialExtent = spatialExtent
    def add_spatialExtent(self, value): self.spatialExtent.append(value)
    def insert_spatialExtent(self, index, value): self.spatialExtent[index] = value
    def export(self, outfile, level, namespace_='', name_='EX_SpatialTemporalExtent_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_SpatialTemporalExtent_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_SpatialTemporalExtent_Type'):
        super(EX_SpatialTemporalExtent_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_SpatialTemporalExtent_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EX_SpatialTemporalExtent_Type', fromsubclass_=False):
        super(EX_SpatialTemporalExtent_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        for spatialExtent_ in self.spatialExtent:
            spatialExtent_.export(outfile, level, namespace_, name_='spatialExtent')
    def hasContent_(self):
        if (
            self.spatialExtent or
            super(EX_SpatialTemporalExtent_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_SpatialTemporalExtent_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EX_SpatialTemporalExtent_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EX_SpatialTemporalExtent_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('spatialExtent=[\n')
        level += 1
        for spatialExtent_ in self.spatialExtent:
            showIndent(outfile, level)
            outfile.write('model_.EX_GeographicExtent_PropertyType(\n')
            spatialExtent_.exportLiteral(outfile, level, name_='EX_GeographicExtent_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_SpatialTemporalExtent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spatialExtent':
            obj_ = EX_GeographicExtent_PropertyType.factory()
            obj_.build(child_)
            self.spatialExtent.append(obj_)
        super(EX_SpatialTemporalExtent_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_SpatialTemporalExtent_Type


class EX_GeographicBoundingBox_Type(AbstractEX_GeographicExtent_Type):
    """Geographic area of the entire dataset referenced to WGS 84"""
    subclass = None
    superclass = AbstractEX_GeographicExtent_Type
    def __init__(self, id=None, uuid=None, extentTypeCode=None, westBoundLongitude=None, eastBoundLongitude=None, southBoundLatitude=None, northBoundLatitude=None):
        super(EX_GeographicBoundingBox_Type, self).__init__(id, uuid, extentTypeCode, )
        self.westBoundLongitude = westBoundLongitude
        self.eastBoundLongitude = eastBoundLongitude
        self.southBoundLatitude = southBoundLatitude
        self.northBoundLatitude = northBoundLatitude
    def factory(*args_, **kwargs_):
        if EX_GeographicBoundingBox_Type.subclass:
            return EX_GeographicBoundingBox_Type.subclass(*args_, **kwargs_)
        else:
            return EX_GeographicBoundingBox_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_westBoundLongitude(self): return self.westBoundLongitude
    def set_westBoundLongitude(self, westBoundLongitude): self.westBoundLongitude = westBoundLongitude
    def get_eastBoundLongitude(self): return self.eastBoundLongitude
    def set_eastBoundLongitude(self, eastBoundLongitude): self.eastBoundLongitude = eastBoundLongitude
    def get_southBoundLatitude(self): return self.southBoundLatitude
    def set_southBoundLatitude(self, southBoundLatitude): self.southBoundLatitude = southBoundLatitude
    def get_northBoundLatitude(self): return self.northBoundLatitude
    def set_northBoundLatitude(self, northBoundLatitude): self.northBoundLatitude = northBoundLatitude
    def export(self, outfile, level, namespace_='', name_='EX_GeographicBoundingBox_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicBoundingBox_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EX_GeographicBoundingBox_Type'):
        super(EX_GeographicBoundingBox_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EX_GeographicBoundingBox_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EX_GeographicBoundingBox_Type', fromsubclass_=False):
        super(EX_GeographicBoundingBox_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.westBoundLongitude is not None:
            self.westBoundLongitude.export(outfile, level, namespace_, name_='westBoundLongitude', )
        if self.eastBoundLongitude is not None:
            self.eastBoundLongitude.export(outfile, level, namespace_, name_='eastBoundLongitude', )
        if self.southBoundLatitude is not None:
            self.southBoundLatitude.export(outfile, level, namespace_, name_='southBoundLatitude', )
        if self.northBoundLatitude is not None:
            self.northBoundLatitude.export(outfile, level, namespace_, name_='northBoundLatitude', )
    def hasContent_(self):
        if (
            self.westBoundLongitude is not None or
            self.eastBoundLongitude is not None or
            self.southBoundLatitude is not None or
            self.northBoundLatitude is not None or
            super(EX_GeographicBoundingBox_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EX_GeographicBoundingBox_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EX_GeographicBoundingBox_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EX_GeographicBoundingBox_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.westBoundLongitude is not None:
            showIndent(outfile, level)
            outfile.write('westBoundLongitude=model_.Decimal_PropertyType(\n')
            self.westBoundLongitude.exportLiteral(outfile, level, name_='westBoundLongitude')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.eastBoundLongitude is not None:
            showIndent(outfile, level)
            outfile.write('eastBoundLongitude=model_.Decimal_PropertyType(\n')
            self.eastBoundLongitude.exportLiteral(outfile, level, name_='eastBoundLongitude')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.southBoundLatitude is not None:
            showIndent(outfile, level)
            outfile.write('southBoundLatitude=model_.Decimal_PropertyType(\n')
            self.southBoundLatitude.exportLiteral(outfile, level, name_='southBoundLatitude')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.northBoundLatitude is not None:
            showIndent(outfile, level)
            outfile.write('northBoundLatitude=model_.Decimal_PropertyType(\n')
            self.northBoundLatitude.exportLiteral(outfile, level, name_='northBoundLatitude')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EX_GeographicBoundingBox_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'westBoundLongitude':
            obj_ = Decimal_PropertyType.factory()
            obj_.build(child_)
            self.set_westBoundLongitude(obj_)
        elif nodeName_ == 'eastBoundLongitude':
            obj_ = Decimal_PropertyType.factory()
            obj_.build(child_)
            self.set_eastBoundLongitude(obj_)
        elif nodeName_ == 'southBoundLatitude':
            obj_ = Decimal_PropertyType.factory()
            obj_.build(child_)
            self.set_southBoundLatitude(obj_)
        elif nodeName_ == 'northBoundLatitude':
            obj_ = Decimal_PropertyType.factory()
            obj_.build(child_)
            self.set_northBoundLatitude(obj_)
        super(EX_GeographicBoundingBox_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EX_GeographicBoundingBox_Type


class MD_Georectified_Type(MD_GridSpatialRepresentation_Type):
    subclass = None
    superclass = MD_GridSpatialRepresentation_Type
    def __init__(self, id=None, uuid=None, numberOfDimensions=None, axisDimensionProperties=None, cellGeometry=None, transformationParameterAvailability=None, checkPointAvailability=None, checkPointDescription=None, cornerPoints=None, centerPoint=None, pointInPixel=None, transformationDimensionDescription=None, transformationDimensionMapping=None):
        super(MD_Georectified_Type, self).__init__(id, uuid, numberOfDimensions, axisDimensionProperties, cellGeometry, transformationParameterAvailability, )
        self.checkPointAvailability = checkPointAvailability
        self.checkPointDescription = checkPointDescription
        if cornerPoints is None:
            self.cornerPoints = []
        else:
            self.cornerPoints = cornerPoints
        self.centerPoint = centerPoint
        self.pointInPixel = pointInPixel
        self.transformationDimensionDescription = transformationDimensionDescription
        if transformationDimensionMapping is None:
            self.transformationDimensionMapping = []
        else:
            self.transformationDimensionMapping = transformationDimensionMapping
    def factory(*args_, **kwargs_):
        if MD_Georectified_Type.subclass:
            return MD_Georectified_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Georectified_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_checkPointAvailability(self): return self.checkPointAvailability
    def set_checkPointAvailability(self, checkPointAvailability): self.checkPointAvailability = checkPointAvailability
    def get_checkPointDescription(self): return self.checkPointDescription
    def set_checkPointDescription(self, checkPointDescription): self.checkPointDescription = checkPointDescription
    def get_cornerPoints(self): return self.cornerPoints
    def set_cornerPoints(self, cornerPoints): self.cornerPoints = cornerPoints
    def add_cornerPoints(self, value): self.cornerPoints.append(value)
    def insert_cornerPoints(self, index, value): self.cornerPoints[index] = value
    def get_centerPoint(self): return self.centerPoint
    def set_centerPoint(self, centerPoint): self.centerPoint = centerPoint
    def get_pointInPixel(self): return self.pointInPixel
    def set_pointInPixel(self, pointInPixel): self.pointInPixel = pointInPixel
    def get_transformationDimensionDescription(self): return self.transformationDimensionDescription
    def set_transformationDimensionDescription(self, transformationDimensionDescription): self.transformationDimensionDescription = transformationDimensionDescription
    def get_transformationDimensionMapping(self): return self.transformationDimensionMapping
    def set_transformationDimensionMapping(self, transformationDimensionMapping): self.transformationDimensionMapping = transformationDimensionMapping
    def add_transformationDimensionMapping(self, value): self.transformationDimensionMapping.append(value)
    def insert_transformationDimensionMapping(self, index, value): self.transformationDimensionMapping[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_Georectified_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Georectified_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Georectified_Type'):
        super(MD_Georectified_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Georectified_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Georectified_Type', fromsubclass_=False):
        super(MD_Georectified_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.checkPointAvailability is not None:
            self.checkPointAvailability.export(outfile, level, namespace_, name_='checkPointAvailability', )
        if self.checkPointDescription is not None:
            self.checkPointDescription.export(outfile, level, namespace_, name_='checkPointDescription')
        for cornerPoints_ in self.cornerPoints:
            cornerPoints_.export(outfile, level, namespace_, name_='cornerPoints')
        if self.centerPoint is not None:
            self.centerPoint.export(outfile, level, namespace_, name_='centerPoint')
        if self.pointInPixel is not None:
            self.pointInPixel.export(outfile, level, namespace_, name_='pointInPixel', )
        if self.transformationDimensionDescription is not None:
            self.transformationDimensionDescription.export(outfile, level, namespace_, name_='transformationDimensionDescription')
        for transformationDimensionMapping_ in self.transformationDimensionMapping:
            transformationDimensionMapping_.export(outfile, level, namespace_, name_='transformationDimensionMapping')
    def hasContent_(self):
        if (
            self.checkPointAvailability is not None or
            self.checkPointDescription is not None or
            self.cornerPoints or
            self.centerPoint is not None or
            self.pointInPixel is not None or
            self.transformationDimensionDescription is not None or
            self.transformationDimensionMapping or
            super(MD_Georectified_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Georectified_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Georectified_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Georectified_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.checkPointAvailability is not None:
            showIndent(outfile, level)
            outfile.write('checkPointAvailability=model_.Boolean_PropertyType(\n')
            self.checkPointAvailability.exportLiteral(outfile, level, name_='checkPointAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.checkPointDescription is not None:
            showIndent(outfile, level)
            outfile.write('checkPointDescription=model_.CharacterString_PropertyType(\n')
            self.checkPointDescription.exportLiteral(outfile, level, name_='checkPointDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('cornerPoints=[\n')
        level += 1
        for cornerPoints_ in self.cornerPoints:
            showIndent(outfile, level)
            outfile.write('model_.GM_Point_PropertyType(\n')
            cornerPoints_.exportLiteral(outfile, level, name_='GM_Point_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.centerPoint is not None:
            showIndent(outfile, level)
            outfile.write('centerPoint=model_.GM_Point_PropertyType(\n')
            self.centerPoint.exportLiteral(outfile, level, name_='centerPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pointInPixel is not None:
            showIndent(outfile, level)
            outfile.write('pointInPixel=model_.MD_PixelOrientationCode_PropertyType(\n')
            self.pointInPixel.exportLiteral(outfile, level, name_='pointInPixel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transformationDimensionDescription is not None:
            showIndent(outfile, level)
            outfile.write('transformationDimensionDescription=model_.CharacterString_PropertyType(\n')
            self.transformationDimensionDescription.exportLiteral(outfile, level, name_='transformationDimensionDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('transformationDimensionMapping=[\n')
        level += 1
        for transformationDimensionMapping_ in self.transformationDimensionMapping:
            showIndent(outfile, level)
            outfile.write('model_.CharacterString_PropertyType(\n')
            transformationDimensionMapping_.exportLiteral(outfile, level, name_='CharacterString_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Georectified_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'checkPointAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_checkPointAvailability(obj_)
        elif nodeName_ == 'checkPointDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_checkPointDescription(obj_)
        elif nodeName_ == 'cornerPoints':
            obj_ = GM_Point_PropertyType.factory()
            obj_.build(child_)
            self.cornerPoints.append(obj_)
        elif nodeName_ == 'centerPoint':
            obj_ = GM_Point_PropertyType.factory()
            obj_.build(child_)
            self.set_centerPoint(obj_)
        elif nodeName_ == 'pointInPixel':
            obj_ = MD_PixelOrientationCode_PropertyType.factory()
            obj_.build(child_)
            self.set_pointInPixel(obj_)
        elif nodeName_ == 'transformationDimensionDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_transformationDimensionDescription(obj_)
        elif nodeName_ == 'transformationDimensionMapping':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.transformationDimensionMapping.append(obj_)
        super(MD_Georectified_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Georectified_Type


class MD_Georeferenceable_Type(MD_GridSpatialRepresentation_Type):
    subclass = None
    superclass = MD_GridSpatialRepresentation_Type
    def __init__(self, id=None, uuid=None, numberOfDimensions=None, axisDimensionProperties=None, cellGeometry=None, transformationParameterAvailability=None, controlPointAvailability=None, orientationParameterAvailability=None, orientationParameterDescription=None, georeferencedParameters=None, parameterCitation=None):
        super(MD_Georeferenceable_Type, self).__init__(id, uuid, numberOfDimensions, axisDimensionProperties, cellGeometry, transformationParameterAvailability, )
        self.controlPointAvailability = controlPointAvailability
        self.orientationParameterAvailability = orientationParameterAvailability
        self.orientationParameterDescription = orientationParameterDescription
        self.georeferencedParameters = georeferencedParameters
        if parameterCitation is None:
            self.parameterCitation = []
        else:
            self.parameterCitation = parameterCitation
    def factory(*args_, **kwargs_):
        if MD_Georeferenceable_Type.subclass:
            return MD_Georeferenceable_Type.subclass(*args_, **kwargs_)
        else:
            return MD_Georeferenceable_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_controlPointAvailability(self): return self.controlPointAvailability
    def set_controlPointAvailability(self, controlPointAvailability): self.controlPointAvailability = controlPointAvailability
    def get_orientationParameterAvailability(self): return self.orientationParameterAvailability
    def set_orientationParameterAvailability(self, orientationParameterAvailability): self.orientationParameterAvailability = orientationParameterAvailability
    def get_orientationParameterDescription(self): return self.orientationParameterDescription
    def set_orientationParameterDescription(self, orientationParameterDescription): self.orientationParameterDescription = orientationParameterDescription
    def get_georeferencedParameters(self): return self.georeferencedParameters
    def set_georeferencedParameters(self, georeferencedParameters): self.georeferencedParameters = georeferencedParameters
    def get_parameterCitation(self): return self.parameterCitation
    def set_parameterCitation(self, parameterCitation): self.parameterCitation = parameterCitation
    def add_parameterCitation(self, value): self.parameterCitation.append(value)
    def insert_parameterCitation(self, index, value): self.parameterCitation[index] = value
    def export(self, outfile, level, namespace_='', name_='MD_Georeferenceable_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Georeferenceable_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MD_Georeferenceable_Type'):
        super(MD_Georeferenceable_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MD_Georeferenceable_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='MD_Georeferenceable_Type', fromsubclass_=False):
        super(MD_Georeferenceable_Type, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.controlPointAvailability is not None:
            self.controlPointAvailability.export(outfile, level, namespace_, name_='controlPointAvailability', )
        if self.orientationParameterAvailability is not None:
            self.orientationParameterAvailability.export(outfile, level, namespace_, name_='orientationParameterAvailability', )
        if self.orientationParameterDescription is not None:
            self.orientationParameterDescription.export(outfile, level, namespace_, name_='orientationParameterDescription')
        if self.georeferencedParameters is not None:
            self.georeferencedParameters.export(outfile, level, namespace_, name_='georeferencedParameters', )
        for parameterCitation_ in self.parameterCitation:
            parameterCitation_.export(outfile, level, namespace_, name_='parameterCitation')
    def hasContent_(self):
        if (
            self.controlPointAvailability is not None or
            self.orientationParameterAvailability is not None or
            self.orientationParameterDescription is not None or
            self.georeferencedParameters is not None or
            self.parameterCitation or
            super(MD_Georeferenceable_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MD_Georeferenceable_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MD_Georeferenceable_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MD_Georeferenceable_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.controlPointAvailability is not None:
            showIndent(outfile, level)
            outfile.write('controlPointAvailability=model_.Boolean_PropertyType(\n')
            self.controlPointAvailability.exportLiteral(outfile, level, name_='controlPointAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orientationParameterAvailability is not None:
            showIndent(outfile, level)
            outfile.write('orientationParameterAvailability=model_.Boolean_PropertyType(\n')
            self.orientationParameterAvailability.exportLiteral(outfile, level, name_='orientationParameterAvailability')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orientationParameterDescription is not None:
            showIndent(outfile, level)
            outfile.write('orientationParameterDescription=model_.CharacterString_PropertyType(\n')
            self.orientationParameterDescription.exportLiteral(outfile, level, name_='orientationParameterDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.georeferencedParameters is not None:
            showIndent(outfile, level)
            outfile.write('georeferencedParameters=model_.Record_PropertyType(\n')
            self.georeferencedParameters.exportLiteral(outfile, level, name_='georeferencedParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('parameterCitation=[\n')
        level += 1
        for parameterCitation_ in self.parameterCitation:
            showIndent(outfile, level)
            outfile.write('model_.CI_Citation_PropertyType(\n')
            parameterCitation_.exportLiteral(outfile, level, name_='CI_Citation_PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MD_Georeferenceable_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'controlPointAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_controlPointAvailability(obj_)
        elif nodeName_ == 'orientationParameterAvailability':
            obj_ = Boolean_PropertyType.factory()
            obj_.build(child_)
            self.set_orientationParameterAvailability(obj_)
        elif nodeName_ == 'orientationParameterDescription':
            class_obj_ = self.get_class_obj_(child_, CharacterString_PropertyType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_orientationParameterDescription(obj_)
        elif nodeName_ == 'georeferencedParameters':
            obj_ = Record_PropertyType.factory()
            obj_.build(child_)
            self.set_georeferencedParameters(obj_)
        elif nodeName_ == 'parameterCitation':
            obj_ = CI_Citation_PropertyType.factory()
            obj_.build(child_)
            self.parameterCitation.append(obj_)
        super(MD_Georeferenceable_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MD_Georeferenceable_Type


class DS_Initiative_Type(AbstractDS_Aggregate_Type):
    subclass = None
    superclass = AbstractDS_Aggregate_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None):
        super(DS_Initiative_Type, self).__init__(id, uuid, composedOf, seriesMetadata, subset, superset, )
        pass
    def factory(*args_, **kwargs_):
        if DS_Initiative_Type.subclass:
            return DS_Initiative_Type.subclass(*args_, **kwargs_)
        else:
            return DS_Initiative_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DS_Initiative_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Initiative_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Initiative_Type'):
        super(DS_Initiative_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Initiative_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Initiative_Type', fromsubclass_=False):
        super(DS_Initiative_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DS_Initiative_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Initiative_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_Initiative_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_Initiative_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DS_Initiative_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_Initiative_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_Initiative_Type


class DS_Series_Type(AbstractDS_Aggregate_Type):
    subclass = None
    superclass = AbstractDS_Aggregate_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None, extensiontype_=None):
        super(DS_Series_Type, self).__init__(id, uuid, composedOf, seriesMetadata, subset, superset, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DS_Series_Type.subclass:
            return DS_Series_Type.subclass(*args_, **kwargs_)
        else:
            return DS_Series_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DS_Series_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Series_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Series_Type'):
        super(DS_Series_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Series_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Series_Type', fromsubclass_=False):
        super(DS_Series_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DS_Series_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Series_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_Series_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_Series_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(DS_Series_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_Series_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_Series_Type


class DS_OtherAggregate_Type(AbstractDS_Aggregate_Type):
    subclass = None
    superclass = AbstractDS_Aggregate_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None, extensiontype_=None):
        super(DS_OtherAggregate_Type, self).__init__(id, uuid, composedOf, seriesMetadata, subset, superset, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DS_OtherAggregate_Type.subclass:
            return DS_OtherAggregate_Type.subclass(*args_, **kwargs_)
        else:
            return DS_OtherAggregate_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DS_OtherAggregate_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_OtherAggregate_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_OtherAggregate_Type'):
        super(DS_OtherAggregate_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_OtherAggregate_Type')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DS_OtherAggregate_Type', fromsubclass_=False):
        super(DS_OtherAggregate_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DS_OtherAggregate_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_OtherAggregate_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_OtherAggregate_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_OtherAggregate_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(DS_OtherAggregate_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_OtherAggregate_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_OtherAggregate_Type


class AffineCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(AffineCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if AffineCSType.subclass:
            return AffineCSType.subclass(*args_, **kwargs_)
        else:
            return AffineCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='AffineCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AffineCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AffineCSType'):
        super(AffineCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AffineCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='AffineCSType', fromsubclass_=False):
        super(AffineCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AffineCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AffineCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AffineCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AffineCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AffineCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AffineCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AffineCSType


class CylindricalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(CylindricalCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if CylindricalCSType.subclass:
            return CylindricalCSType.subclass(*args_, **kwargs_)
        else:
            return CylindricalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CylindricalCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CylindricalCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CylindricalCSType'):
        super(CylindricalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CylindricalCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='CylindricalCSType', fromsubclass_=False):
        super(CylindricalCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(CylindricalCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CylindricalCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CylindricalCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CylindricalCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CylindricalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CylindricalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CylindricalCSType


class PolarCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(PolarCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if PolarCSType.subclass:
            return PolarCSType.subclass(*args_, **kwargs_)
        else:
            return PolarCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='PolarCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolarCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolarCSType'):
        super(PolarCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PolarCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='PolarCSType', fromsubclass_=False):
        super(PolarCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(PolarCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolarCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PolarCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PolarCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PolarCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PolarCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PolarCSType


class SphericalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(SphericalCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if SphericalCSType.subclass:
            return SphericalCSType.subclass(*args_, **kwargs_)
        else:
            return SphericalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SphericalCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SphericalCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SphericalCSType'):
        super(SphericalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SphericalCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='SphericalCSType', fromsubclass_=False):
        super(SphericalCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(SphericalCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SphericalCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SphericalCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SphericalCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SphericalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SphericalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SphericalCSType


class UserDefinedCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(UserDefinedCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if UserDefinedCSType.subclass:
            return UserDefinedCSType.subclass(*args_, **kwargs_)
        else:
            return UserDefinedCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='UserDefinedCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserDefinedCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UserDefinedCSType'):
        super(UserDefinedCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UserDefinedCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='UserDefinedCSType', fromsubclass_=False):
        super(UserDefinedCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(UserDefinedCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UserDefinedCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UserDefinedCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UserDefinedCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(UserDefinedCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(UserDefinedCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UserDefinedCSType


class LinearCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(LinearCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if LinearCSType.subclass:
            return LinearCSType.subclass(*args_, **kwargs_)
        else:
            return LinearCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='LinearCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearCSType'):
        super(LinearCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LinearCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='LinearCSType', fromsubclass_=False):
        super(LinearCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(LinearCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LinearCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LinearCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LinearCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LinearCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LinearCSType


class TimeCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(TimeCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if TimeCSType.subclass:
            return TimeCSType.subclass(*args_, **kwargs_)
        else:
            return TimeCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='TimeCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCSType'):
        super(TimeCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCSType', fromsubclass_=False):
        super(TimeCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(TimeCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TimeCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TimeCSType


class VerticalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(VerticalCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if VerticalCSType.subclass:
            return VerticalCSType.subclass(*args_, **kwargs_)
        else:
            return VerticalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='VerticalCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerticalCSType'):
        super(VerticalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='VerticalCSType', fromsubclass_=False):
        super(VerticalCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(VerticalCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VerticalCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VerticalCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VerticalCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VerticalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VerticalCSType


class CartesianCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(CartesianCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if CartesianCSType.subclass:
            return CartesianCSType.subclass(*args_, **kwargs_)
        else:
            return CartesianCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CartesianCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CartesianCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CartesianCSType'):
        super(CartesianCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CartesianCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='CartesianCSType', fromsubclass_=False):
        super(CartesianCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(CartesianCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CartesianCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CartesianCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CartesianCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CartesianCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CartesianCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CartesianCSType


class EllipsoidalCSType(AbstractCoordinateSystemType):
    subclass = None
    superclass = AbstractCoordinateSystemType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, aggregationType=None, axis=None):
        super(EllipsoidalCSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, aggregationType, axis, )
        pass
    def factory(*args_, **kwargs_):
        if EllipsoidalCSType.subclass:
            return EllipsoidalCSType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidalCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='EllipsoidalCSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidalCSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EllipsoidalCSType'):
        super(EllipsoidalCSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EllipsoidalCSType')
    def exportChildren(self, outfile, level, namespace_='', name_='EllipsoidalCSType', fromsubclass_=False):
        super(EllipsoidalCSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(EllipsoidalCSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EllipsoidalCSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EllipsoidalCSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EllipsoidalCSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EllipsoidalCSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EllipsoidalCSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EllipsoidalCSType


class DerivedCRSType(AbstractGeneralDerivedCRSType):
    subclass = None
    superclass = AbstractGeneralDerivedCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, conversion=None, baseCRS=None, derivedCRSType=None, coordinateSystem=None):
        super(DerivedCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, conversion, )
        self.baseCRS = baseCRS
        self.derivedCRSType = derivedCRSType
        self.coordinateSystem = coordinateSystem
    def factory(*args_, **kwargs_):
        if DerivedCRSType.subclass:
            return DerivedCRSType.subclass(*args_, **kwargs_)
        else:
            return DerivedCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseCRS(self): return self.baseCRS
    def set_baseCRS(self, baseCRS): self.baseCRS = baseCRS
    def get_derivedCRSType(self): return self.derivedCRSType
    def set_derivedCRSType(self, derivedCRSType): self.derivedCRSType = derivedCRSType
    def get_coordinateSystem(self): return self.coordinateSystem
    def set_coordinateSystem(self, coordinateSystem): self.coordinateSystem = coordinateSystem
    def export(self, outfile, level, namespace_='', name_='DerivedCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivedCRSType'):
        super(DerivedCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='DerivedCRSType', fromsubclass_=False):
        super(DerivedCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.baseCRS is not None:
            self.baseCRS.export(outfile, level, namespace_, name_='baseCRS', )
        if self.derivedCRSType is not None:
            self.derivedCRSType.export(outfile, level, namespace_, name_='derivedCRSType', )
        if self.coordinateSystem is not None:
            self.coordinateSystem.export(outfile, level, namespace_, name_='coordinateSystem', )
    def hasContent_(self):
        if (
            self.baseCRS is not None or
            self.derivedCRSType is not None or
            self.coordinateSystem is not None or
            super(DerivedCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DerivedCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DerivedCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DerivedCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.baseCRS is not None:
            showIndent(outfile, level)
            outfile.write('baseCRS=model_.baseCRS(\n')
            self.baseCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.derivedCRSType is not None:
            showIndent(outfile, level)
            outfile.write('derivedCRSType=model_.derivedCRSType(\n')
            self.derivedCRSType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinateSystem is not None:
            showIndent(outfile, level)
            outfile.write('coordinateSystem=model_.coordinateSystem(\n')
            self.coordinateSystem.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DerivedCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseCRS':
            obj_ = SingleCRSPropertyType.factory()
            obj_.build(child_)
            self.set_baseCRS(obj_)
        elif nodeName_ == 'derivedCRSType':
            obj_ = CodeWithAuthorityType.factory()
            obj_.build(child_)
            self.set_derivedCRSType(obj_)
        elif nodeName_ == 'coordinateSystem':
            obj_ = CoordinateSystemPropertyType.factory()
            obj_.build(child_)
            self.set_coordinateSystem(obj_)
        super(DerivedCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class DerivedCRSType


class ProjectedCRSType(AbstractGeneralDerivedCRSType):
    subclass = None
    superclass = AbstractGeneralDerivedCRSType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, domainOfValidity=None, scope=None, conversion=None, baseGeodeticCRS=None, baseGeographicCRS=None, cartesianCS=None):
        super(ProjectedCRSType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, domainOfValidity, scope, conversion, )
        self.baseGeodeticCRS = baseGeodeticCRS
        self.baseGeographicCRS = baseGeographicCRS
        self.cartesianCS = cartesianCS
    def factory(*args_, **kwargs_):
        if ProjectedCRSType.subclass:
            return ProjectedCRSType.subclass(*args_, **kwargs_)
        else:
            return ProjectedCRSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseGeodeticCRS(self): return self.baseGeodeticCRS
    def set_baseGeodeticCRS(self, baseGeodeticCRS): self.baseGeodeticCRS = baseGeodeticCRS
    def get_baseGeographicCRS(self): return self.baseGeographicCRS
    def set_baseGeographicCRS(self, baseGeographicCRS): self.baseGeographicCRS = baseGeographicCRS
    def get_cartesianCS(self): return self.cartesianCS
    def set_cartesianCS(self, cartesianCS): self.cartesianCS = cartesianCS
    def export(self, outfile, level, namespace_='', name_='ProjectedCRSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedCRSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProjectedCRSType'):
        super(ProjectedCRSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectedCRSType')
    def exportChildren(self, outfile, level, namespace_='', name_='ProjectedCRSType', fromsubclass_=False):
        super(ProjectedCRSType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.baseGeodeticCRS is not None:
            self.baseGeodeticCRS.export(outfile, level, namespace_, name_='baseGeodeticCRS', )
        if self.baseGeographicCRS is not None:
            self.baseGeographicCRS.export(outfile, level, namespace_, name_='baseGeographicCRS', )
        if self.cartesianCS is not None:
            self.cartesianCS.export(outfile, level, namespace_, name_='cartesianCS', )
    def hasContent_(self):
        if (
            self.baseGeodeticCRS is not None or
            self.baseGeographicCRS is not None or
            self.cartesianCS is not None or
            super(ProjectedCRSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProjectedCRSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ProjectedCRSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProjectedCRSType, self).exportLiteralChildren(outfile, level, name_)
        if self.baseGeodeticCRS is not None:
            showIndent(outfile, level)
            outfile.write('baseGeodeticCRS=model_.baseGeodeticCRS(\n')
            self.baseGeodeticCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.baseGeographicCRS is not None:
            showIndent(outfile, level)
            outfile.write('baseGeographicCRS=model_.baseGeographicCRS(\n')
            self.baseGeographicCRS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cartesianCS is not None:
            showIndent(outfile, level)
            outfile.write('cartesianCS=model_.cartesianCS(\n')
            self.cartesianCS.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectedCRSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseGeodeticCRS':
            obj_ = GeodeticCRSPropertyType.factory()
            obj_.build(child_)
            self.set_baseGeodeticCRS(obj_)
        elif nodeName_ == 'baseGeographicCRS':
            obj_ = GeographicCRSPropertyType.factory()
            obj_.build(child_)
            self.set_baseGeographicCRS(obj_)
        elif nodeName_ == 'cartesianCS':
            obj_ = CartesianCSPropertyType.factory()
            obj_.build(child_)
            self.set_cartesianCS(obj_)
        super(ProjectedCRSType, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectedCRSType


class GridType(AbstractGeometryType):
    subclass = None
    superclass = AbstractGeometryType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, dimension=None, limits=None, axisLabels=None, axisName=None, extensiontype_=None):
        super(GridType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, extensiontype_, )
        self.dimension = _cast(None, dimension)
        self.limits = limits
        self.axisLabels = axisLabels
        if axisName is None:
            self.axisName = []
        else:
            self.axisName = axisName
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if GridType.subclass:
            return GridType.subclass(*args_, **kwargs_)
        else:
            return GridType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limits(self): return self.limits
    def set_limits(self, limits): self.limits = limits
    def get_axisLabels(self): return self.axisLabels
    def set_axisLabels(self, axisLabels): self.axisLabels = axisLabels
    def validate_NCNameList(self, value):
        # Validate type NCNameList, a restriction on NCName.
        pass
    def get_axisName(self): return self.axisName
    def set_axisName(self, axisName): self.axisName = axisName
    def add_axisName(self, value): self.axisName.append(value)
    def insert_axisName(self, index, value): self.axisName[index] = value
    def get_dimension(self): return self.dimension
    def set_dimension(self, dimension): self.dimension = dimension
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='GridType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GridType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GridType'):
        super(GridType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GridType')
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            outfile.write(' dimension=%s' % (quote_attrib(self.dimension), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='GridType', fromsubclass_=False):
        super(GridType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.limits is not None:
            self.limits.export(outfile, level, namespace_, name_='limits', )
        if self.axisLabels is not None:
            self.axisLabels.export(outfile, level, namespace_, name_='axisLabels', )
        for axisName_ in self.axisName:
            showIndent(outfile, level)
            outfile.write('<%saxisName>%s</%saxisName>\n' % (namespace_, self.gds_format_string(quote_xml(axisName_).encode(ExternalEncoding), input_name='axisName'), namespace_))
    def hasContent_(self):
        if (
            self.limits is not None or
            self.axisLabels is not None or
            self.axisName or
            super(GridType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GridType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            showIndent(outfile, level)
            outfile.write('dimension = %s,\n' % (self.dimension,))
        super(GridType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GridType, self).exportLiteralChildren(outfile, level, name_)
        if self.limits is not None:
            showIndent(outfile, level)
            outfile.write('limits=model_.GridLimitsType(\n')
            self.limits.exportLiteral(outfile, level, name_='limits')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.axisLabels is not None:
            showIndent(outfile, level)
            outfile.write('axisLabels=model_.NCName(\n')
            self.axisLabels.exportLiteral(outfile, level, name_='axisLabels')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('axisName=[\n')
        level += 1
        for axisName_ in self.axisName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(axisName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.append('dimension')
            self.dimension = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(GridType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limits':
            obj_ = GridLimitsType.factory()
            obj_.build(child_)
            self.set_limits(obj_)
        elif nodeName_ == 'axisLabels':
            axisLabels_ = child_.text
            self.axisLabels = axisLabels_
            self.axisLabels = self.axisLabels.split()
            self.validate_NCNameList(self.axisLabels)    # validate type NCNameList
        elif nodeName_ == 'axisName':
            axisName_ = child_.text
            axisName_ = self.gds_validate_string(axisName_, node, 'axisName')
            self.axisName.append(axisName_)
        super(GridType, self).buildChildren(child_, node, nodeName_, True)
# end class GridType


class AbstractContinuousCoverageType(AbstractCoverageType):
    subclass = None
    superclass = AbstractCoverageType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, domainSet=None, rangeSet=None, coverageFunction=None):
        super(AbstractContinuousCoverageType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, domainSet, rangeSet, )
        self.coverageFunction = coverageFunction
    def factory(*args_, **kwargs_):
        if AbstractContinuousCoverageType.subclass:
            return AbstractContinuousCoverageType.subclass(*args_, **kwargs_)
        else:
            return AbstractContinuousCoverageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coverageFunction(self): return self.coverageFunction
    def set_coverageFunction(self, coverageFunction): self.coverageFunction = coverageFunction
    def export(self, outfile, level, namespace_='', name_='AbstractContinuousCoverageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractContinuousCoverageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractContinuousCoverageType'):
        super(AbstractContinuousCoverageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractContinuousCoverageType')
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractContinuousCoverageType', fromsubclass_=False):
        super(AbstractContinuousCoverageType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.coverageFunction is not None:
            self.coverageFunction.export(outfile, level, namespace_, name_='coverageFunction')
    def hasContent_(self):
        if (
            self.coverageFunction is not None or
            super(AbstractContinuousCoverageType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractContinuousCoverageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractContinuousCoverageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractContinuousCoverageType, self).exportLiteralChildren(outfile, level, name_)
        if self.coverageFunction is not None:
            showIndent(outfile, level)
            outfile.write('coverageFunction=model_.coverageFunction(\n')
            self.coverageFunction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractContinuousCoverageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'coverageFunction':
            obj_ = CoverageFunctionType.factory()
            obj_.build(child_)
            self.set_coverageFunction(obj_)
        super(AbstractContinuousCoverageType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractContinuousCoverageType


class DiscreteCoverageType(AbstractCoverageType):
    subclass = None
    superclass = AbstractCoverageType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, domainSet=None, rangeSet=None, coverageFunction=None):
        super(DiscreteCoverageType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, domainSet, rangeSet, )
        self.coverageFunction = coverageFunction
    def factory(*args_, **kwargs_):
        if DiscreteCoverageType.subclass:
            return DiscreteCoverageType.subclass(*args_, **kwargs_)
        else:
            return DiscreteCoverageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coverageFunction(self): return self.coverageFunction
    def set_coverageFunction(self, coverageFunction): self.coverageFunction = coverageFunction
    def export(self, outfile, level, namespace_='', name_='DiscreteCoverageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscreteCoverageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiscreteCoverageType'):
        super(DiscreteCoverageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiscreteCoverageType')
    def exportChildren(self, outfile, level, namespace_='', name_='DiscreteCoverageType', fromsubclass_=False):
        super(DiscreteCoverageType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.coverageFunction is not None:
            self.coverageFunction.export(outfile, level, namespace_, name_='coverageFunction')
    def hasContent_(self):
        if (
            self.coverageFunction is not None or
            super(DiscreteCoverageType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DiscreteCoverageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiscreteCoverageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiscreteCoverageType, self).exportLiteralChildren(outfile, level, name_)
        if self.coverageFunction is not None:
            showIndent(outfile, level)
            outfile.write('coverageFunction=model_.coverageFunction(\n')
            self.coverageFunction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DiscreteCoverageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'coverageFunction':
            obj_ = CoverageFunctionType.factory()
            obj_.build(child_)
            self.set_coverageFunction(obj_)
        super(DiscreteCoverageType, self).buildChildren(child_, node, nodeName_, True)
# end class DiscreteCoverageType


class ConventionalUnitType(UnitDefinitionType):
    subclass = None
    superclass = UnitDefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, quantityType=None, quantityTypeReference=None, catalogSymbol=None, conversionToPreferredUnit=None, roughConversionToPreferredUnit=None, derivationUnitTerm=None):
        super(ConventionalUnitType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, quantityType, quantityTypeReference, catalogSymbol, )
        self.conversionToPreferredUnit = conversionToPreferredUnit
        self.roughConversionToPreferredUnit = roughConversionToPreferredUnit
        if derivationUnitTerm is None:
            self.derivationUnitTerm = []
        else:
            self.derivationUnitTerm = derivationUnitTerm
    def factory(*args_, **kwargs_):
        if ConventionalUnitType.subclass:
            return ConventionalUnitType.subclass(*args_, **kwargs_)
        else:
            return ConventionalUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_conversionToPreferredUnit(self): return self.conversionToPreferredUnit
    def set_conversionToPreferredUnit(self, conversionToPreferredUnit): self.conversionToPreferredUnit = conversionToPreferredUnit
    def get_roughConversionToPreferredUnit(self): return self.roughConversionToPreferredUnit
    def set_roughConversionToPreferredUnit(self, roughConversionToPreferredUnit): self.roughConversionToPreferredUnit = roughConversionToPreferredUnit
    def get_derivationUnitTerm(self): return self.derivationUnitTerm
    def set_derivationUnitTerm(self, derivationUnitTerm): self.derivationUnitTerm = derivationUnitTerm
    def add_derivationUnitTerm(self, value): self.derivationUnitTerm.append(value)
    def insert_derivationUnitTerm(self, index, value): self.derivationUnitTerm[index] = value
    def export(self, outfile, level, namespace_='', name_='ConventionalUnitType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConventionalUnitType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConventionalUnitType'):
        super(ConventionalUnitType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConventionalUnitType')
    def exportChildren(self, outfile, level, namespace_='', name_='ConventionalUnitType', fromsubclass_=False):
        super(ConventionalUnitType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.conversionToPreferredUnit is not None:
            self.conversionToPreferredUnit.export(outfile, level, namespace_, name_='conversionToPreferredUnit', )
        if self.roughConversionToPreferredUnit is not None:
            self.roughConversionToPreferredUnit.export(outfile, level, namespace_, name_='roughConversionToPreferredUnit', )
        for derivationUnitTerm_ in self.derivationUnitTerm:
            derivationUnitTerm_.export(outfile, level, namespace_, name_='derivationUnitTerm')
    def hasContent_(self):
        if (
            self.conversionToPreferredUnit is not None or
            self.roughConversionToPreferredUnit is not None or
            self.derivationUnitTerm or
            super(ConventionalUnitType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConventionalUnitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConventionalUnitType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConventionalUnitType, self).exportLiteralChildren(outfile, level, name_)
        if self.conversionToPreferredUnit is not None:
            showIndent(outfile, level)
            outfile.write('conversionToPreferredUnit=model_.conversionToPreferredUnit(\n')
            self.conversionToPreferredUnit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.roughConversionToPreferredUnit is not None:
            showIndent(outfile, level)
            outfile.write('roughConversionToPreferredUnit=model_.roughConversionToPreferredUnit(\n')
            self.roughConversionToPreferredUnit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('derivationUnitTerm=[\n')
        level += 1
        for derivationUnitTerm_ in self.derivationUnitTerm:
            showIndent(outfile, level)
            outfile.write('model_.derivationUnitTerm(\n')
            derivationUnitTerm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ConventionalUnitType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'conversionToPreferredUnit':
            obj_ = ConversionToPreferredUnitType.factory()
            obj_.build(child_)
            self.set_conversionToPreferredUnit(obj_)
        elif nodeName_ == 'roughConversionToPreferredUnit':
            obj_ = ConversionToPreferredUnitType.factory()
            obj_.build(child_)
            self.set_roughConversionToPreferredUnit(obj_)
        elif nodeName_ == 'derivationUnitTerm':
            obj_ = DerivationUnitTermType.factory()
            obj_.build(child_)
            self.derivationUnitTerm.append(obj_)
        super(ConventionalUnitType, self).buildChildren(child_, node, nodeName_, True)
# end class ConventionalUnitType


class DerivedUnitType(UnitDefinitionType):
    subclass = None
    superclass = UnitDefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, quantityType=None, quantityTypeReference=None, catalogSymbol=None, derivationUnitTerm=None):
        super(DerivedUnitType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, quantityType, quantityTypeReference, catalogSymbol, )
        if derivationUnitTerm is None:
            self.derivationUnitTerm = []
        else:
            self.derivationUnitTerm = derivationUnitTerm
    def factory(*args_, **kwargs_):
        if DerivedUnitType.subclass:
            return DerivedUnitType.subclass(*args_, **kwargs_)
        else:
            return DerivedUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_derivationUnitTerm(self): return self.derivationUnitTerm
    def set_derivationUnitTerm(self, derivationUnitTerm): self.derivationUnitTerm = derivationUnitTerm
    def add_derivationUnitTerm(self, value): self.derivationUnitTerm.append(value)
    def insert_derivationUnitTerm(self, index, value): self.derivationUnitTerm[index] = value
    def export(self, outfile, level, namespace_='', name_='DerivedUnitType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedUnitType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivedUnitType'):
        super(DerivedUnitType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedUnitType')
    def exportChildren(self, outfile, level, namespace_='', name_='DerivedUnitType', fromsubclass_=False):
        super(DerivedUnitType, self).exportChildren(outfile, level, namespace_, name_, True)
        for derivationUnitTerm_ in self.derivationUnitTerm:
            derivationUnitTerm_.export(outfile, level, namespace_, name_='derivationUnitTerm')
    def hasContent_(self):
        if (
            self.derivationUnitTerm or
            super(DerivedUnitType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DerivedUnitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DerivedUnitType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DerivedUnitType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('derivationUnitTerm=[\n')
        level += 1
        for derivationUnitTerm_ in self.derivationUnitTerm:
            showIndent(outfile, level)
            outfile.write('model_.derivationUnitTerm(\n')
            derivationUnitTerm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DerivedUnitType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'derivationUnitTerm':
            obj_ = DerivationUnitTermType.factory()
            obj_.build(child_)
            self.derivationUnitTerm.append(obj_)
        super(DerivedUnitType, self).buildChildren(child_, node, nodeName_, True)
# end class DerivedUnitType


class BaseUnitType(UnitDefinitionType):
    subclass = None
    superclass = UnitDefinitionType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, remarks=None, quantityType=None, quantityTypeReference=None, catalogSymbol=None, unitsSystem=None):
        super(BaseUnitType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, remarks, quantityType, quantityTypeReference, catalogSymbol, )
        self.unitsSystem = unitsSystem
    def factory(*args_, **kwargs_):
        if BaseUnitType.subclass:
            return BaseUnitType.subclass(*args_, **kwargs_)
        else:
            return BaseUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitsSystem(self): return self.unitsSystem
    def set_unitsSystem(self, unitsSystem): self.unitsSystem = unitsSystem
    def export(self, outfile, level, namespace_='', name_='BaseUnitType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaseUnitType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaseUnitType'):
        super(BaseUnitType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BaseUnitType')
    def exportChildren(self, outfile, level, namespace_='', name_='BaseUnitType', fromsubclass_=False):
        super(BaseUnitType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.unitsSystem is not None:
            self.unitsSystem.export(outfile, level, namespace_, name_='unitsSystem', )
    def hasContent_(self):
        if (
            self.unitsSystem is not None or
            super(BaseUnitType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaseUnitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BaseUnitType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BaseUnitType, self).exportLiteralChildren(outfile, level, name_)
        if self.unitsSystem is not None:
            showIndent(outfile, level)
            outfile.write('unitsSystem=model_.ReferenceType(\n')
            self.unitsSystem.exportLiteral(outfile, level, name_='unitsSystem')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BaseUnitType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unitsSystem':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.set_unitsSystem(obj_)
        super(BaseUnitType, self).buildChildren(child_, node, nodeName_, True)
# end class BaseUnitType


class AbstractGeometricPrimitiveType(AbstractGeometryType):
    """gml:AbstractGeometricPrimitiveType is the abstract root type of the
    geometric primitives. A geometric primitive is a geometric
    object that is not decomposed further into other primitives in
    the system. All primitives are oriented in the direction implied
    by the sequence of their coordinate tuples."""
    subclass = None
    superclass = AbstractGeometryType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, extensiontype_=None):
        super(AbstractGeometricPrimitiveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractGeometricPrimitiveType.subclass:
            return AbstractGeometricPrimitiveType.subclass(*args_, **kwargs_)
        else:
            return AbstractGeometricPrimitiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractGeometricPrimitiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeometricPrimitiveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractGeometricPrimitiveType'):
        super(AbstractGeometricPrimitiveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractGeometricPrimitiveType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractGeometricPrimitiveType', fromsubclass_=False):
        super(AbstractGeometricPrimitiveType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractGeometricPrimitiveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractGeometricPrimitiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractGeometricPrimitiveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractGeometricPrimitiveType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractGeometricPrimitiveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractGeometricPrimitiveType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractGeometricPrimitiveType


class AbstractSurfaceType(AbstractGeometricPrimitiveType):
    """gml:AbstractSurfaceType is an abstraction of a surface to support
    the different levels of complexity. A surface is always a
    continuous region of a plane."""
    subclass = None
    superclass = AbstractGeometricPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, extensiontype_=None):
        super(AbstractSurfaceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractSurfaceType.subclass:
            return AbstractSurfaceType.subclass(*args_, **kwargs_)
        else:
            return AbstractSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractSurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractSurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractSurfaceType'):
        super(AbstractSurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractSurfaceType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractSurfaceType', fromsubclass_=False):
        super(AbstractSurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractSurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractSurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractSurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractSurfaceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractSurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractSurfaceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractSurfaceType


class AbstractSolidType(AbstractGeometricPrimitiveType):
    """gml:AbstractSolidType is an abstraction of a solid to support the
    different levels of complexity. The solid may always be viewed
    as a geometric primitive, i.e. is contiguous."""
    subclass = None
    superclass = AbstractGeometricPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, extensiontype_=None):
        super(AbstractSolidType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractSolidType.subclass:
            return AbstractSolidType.subclass(*args_, **kwargs_)
        else:
            return AbstractSolidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractSolidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractSolidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractSolidType'):
        super(AbstractSolidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractSolidType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractSolidType', fromsubclass_=False):
        super(AbstractSolidType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractSolidType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractSolidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractSolidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractSolidType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractSolidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractSolidType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractSolidType


class OrientableSurfaceType(AbstractSurfaceType):
    subclass = None
    superclass = AbstractSurfaceType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, orientation='+', baseSurface=None):
        super(OrientableSurfaceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.orientation = _cast(None, orientation)
        self.baseSurface = baseSurface
    def factory(*args_, **kwargs_):
        if OrientableSurfaceType.subclass:
            return OrientableSurfaceType.subclass(*args_, **kwargs_)
        else:
            return OrientableSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseSurface(self): return self.baseSurface
    def set_baseSurface(self, baseSurface): self.baseSurface = baseSurface
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def export(self, outfile, level, namespace_='', name_='OrientableSurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrientableSurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrientableSurfaceType'):
        super(OrientableSurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrientableSurfaceType')
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrientableSurfaceType', fromsubclass_=False):
        super(OrientableSurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.baseSurface is not None:
            self.baseSurface.export(outfile, level, namespace_, name_='baseSurface', )
    def hasContent_(self):
        if (
            self.baseSurface is not None or
            super(OrientableSurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrientableSurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            showIndent(outfile, level)
            outfile.write('orientation = %s,\n' % (self.orientation,))
        super(OrientableSurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrientableSurfaceType, self).exportLiteralChildren(outfile, level, name_)
        if self.baseSurface is not None:
            showIndent(outfile, level)
            outfile.write('baseSurface=model_.baseSurface(\n')
            self.baseSurface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            self.orientation = value
        super(OrientableSurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseSurface':
            obj_ = SurfacePropertyType.factory()
            obj_.build(child_)
            self.set_baseSurface(obj_)
        super(OrientableSurfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class OrientableSurfaceType


class SurfaceType(AbstractSurfaceType):
    subclass = None
    superclass = AbstractSurfaceType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, patches=None, extensiontype_=None):
        super(SurfaceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, extensiontype_, )
        self.patches = patches
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SurfaceType.subclass:
            return SurfaceType.subclass(*args_, **kwargs_)
        else:
            return SurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_patches(self): return self.patches
    def set_patches(self, patches): self.patches = patches
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='SurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SurfaceType'):
        super(SurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SurfaceType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='SurfaceType', fromsubclass_=False):
        super(SurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.patches is not None:
            self.patches.export(outfile, level, namespace_, name_='patches', )
    def hasContent_(self):
        if (
            self.patches is not None or
            super(SurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SurfaceType, self).exportLiteralChildren(outfile, level, name_)
        if self.patches is not None:
            showIndent(outfile, level)
            outfile.write('patches=model_.patches(\n')
            self.patches.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(SurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'patches':
            obj_ = SurfacePatchArrayPropertyType.factory()
            obj_.build(child_)
            self.set_patches(obj_)
        super(SurfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class SurfaceType


class MultiSolidType(AbstractGeometricAggregateType):
    subclass = None
    superclass = AbstractGeometricAggregateType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, solidMember=None, solidMembers=None):
        super(MultiSolidType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, aggregationType, )
        if solidMember is None:
            self.solidMember = []
        else:
            self.solidMember = solidMember
        self.solidMembers = solidMembers
    def factory(*args_, **kwargs_):
        if MultiSolidType.subclass:
            return MultiSolidType.subclass(*args_, **kwargs_)
        else:
            return MultiSolidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_solidMember(self): return self.solidMember
    def set_solidMember(self, solidMember): self.solidMember = solidMember
    def add_solidMember(self, value): self.solidMember.append(value)
    def insert_solidMember(self, index, value): self.solidMember[index] = value
    def get_solidMembers(self): return self.solidMembers
    def set_solidMembers(self, solidMembers): self.solidMembers = solidMembers
    def export(self, outfile, level, namespace_='', name_='MultiSolidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiSolidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiSolidType'):
        super(MultiSolidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MultiSolidType')
    def exportChildren(self, outfile, level, namespace_='', name_='MultiSolidType', fromsubclass_=False):
        super(MultiSolidType, self).exportChildren(outfile, level, namespace_, name_, True)
        for solidMember_ in self.solidMember:
            solidMember_.export(outfile, level, namespace_, name_='solidMember')
        if self.solidMembers is not None:
            self.solidMembers.export(outfile, level, namespace_, name_='solidMembers')
    def hasContent_(self):
        if (
            self.solidMember or
            self.solidMembers is not None or
            super(MultiSolidType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiSolidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MultiSolidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MultiSolidType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('solidMember=[\n')
        level += 1
        for solidMember_ in self.solidMember:
            showIndent(outfile, level)
            outfile.write('model_.solidMember(\n')
            solidMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.solidMembers is not None:
            showIndent(outfile, level)
            outfile.write('solidMembers=model_.solidMembers(\n')
            self.solidMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiSolidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'solidMember':
            obj_ = SolidPropertyType.factory()
            obj_.build(child_)
            self.solidMember.append(obj_)
        elif nodeName_ == 'solidMembers':
            obj_ = SolidArrayPropertyType.factory()
            obj_.build(child_)
            self.set_solidMembers(obj_)
        super(MultiSolidType, self).buildChildren(child_, node, nodeName_, True)
# end class MultiSolidType


class MultiSurfaceType(AbstractGeometricAggregateType):
    subclass = None
    superclass = AbstractGeometricAggregateType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, surfaceMember=None, surfaceMembers=None):
        super(MultiSurfaceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, aggregationType, )
        if surfaceMember is None:
            self.surfaceMember = []
        else:
            self.surfaceMember = surfaceMember
        self.surfaceMembers = surfaceMembers
    def factory(*args_, **kwargs_):
        if MultiSurfaceType.subclass:
            return MultiSurfaceType.subclass(*args_, **kwargs_)
        else:
            return MultiSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_surfaceMember(self): return self.surfaceMember
    def set_surfaceMember(self, surfaceMember): self.surfaceMember = surfaceMember
    def add_surfaceMember(self, value): self.surfaceMember.append(value)
    def insert_surfaceMember(self, index, value): self.surfaceMember[index] = value
    def get_surfaceMembers(self): return self.surfaceMembers
    def set_surfaceMembers(self, surfaceMembers): self.surfaceMembers = surfaceMembers
    def export(self, outfile, level, namespace_='', name_='MultiSurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiSurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiSurfaceType'):
        super(MultiSurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MultiSurfaceType')
    def exportChildren(self, outfile, level, namespace_='', name_='MultiSurfaceType', fromsubclass_=False):
        super(MultiSurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        for surfaceMember_ in self.surfaceMember:
            surfaceMember_.export(outfile, level, namespace_, name_='surfaceMember')
        if self.surfaceMembers is not None:
            self.surfaceMembers.export(outfile, level, namespace_, name_='surfaceMembers')
    def hasContent_(self):
        if (
            self.surfaceMember or
            self.surfaceMembers is not None or
            super(MultiSurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiSurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MultiSurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MultiSurfaceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('surfaceMember=[\n')
        level += 1
        for surfaceMember_ in self.surfaceMember:
            showIndent(outfile, level)
            outfile.write('model_.surfaceMember(\n')
            surfaceMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.surfaceMembers is not None:
            showIndent(outfile, level)
            outfile.write('surfaceMembers=model_.surfaceMembers(\n')
            self.surfaceMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiSurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'surfaceMember':
            obj_ = SurfacePropertyType.factory()
            obj_.build(child_)
            self.surfaceMember.append(obj_)
        elif nodeName_ == 'surfaceMembers':
            obj_ = SurfaceArrayPropertyType.factory()
            obj_.build(child_)
            self.set_surfaceMembers(obj_)
        super(MultiSurfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class MultiSurfaceType


class MultiCurveType(AbstractGeometricAggregateType):
    subclass = None
    superclass = AbstractGeometricAggregateType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, curveMember=None, curveMembers=None):
        super(MultiCurveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, aggregationType, )
        if curveMember is None:
            self.curveMember = []
        else:
            self.curveMember = curveMember
        self.curveMembers = curveMembers
    def factory(*args_, **kwargs_):
        if MultiCurveType.subclass:
            return MultiCurveType.subclass(*args_, **kwargs_)
        else:
            return MultiCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_curveMember(self): return self.curveMember
    def set_curveMember(self, curveMember): self.curveMember = curveMember
    def add_curveMember(self, value): self.curveMember.append(value)
    def insert_curveMember(self, index, value): self.curveMember[index] = value
    def get_curveMembers(self): return self.curveMembers
    def set_curveMembers(self, curveMembers): self.curveMembers = curveMembers
    def export(self, outfile, level, namespace_='', name_='MultiCurveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiCurveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiCurveType'):
        super(MultiCurveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MultiCurveType')
    def exportChildren(self, outfile, level, namespace_='', name_='MultiCurveType', fromsubclass_=False):
        super(MultiCurveType, self).exportChildren(outfile, level, namespace_, name_, True)
        for curveMember_ in self.curveMember:
            curveMember_.export(outfile, level, namespace_, name_='curveMember')
        if self.curveMembers is not None:
            self.curveMembers.export(outfile, level, namespace_, name_='curveMembers')
    def hasContent_(self):
        if (
            self.curveMember or
            self.curveMembers is not None or
            super(MultiCurveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiCurveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MultiCurveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MultiCurveType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('curveMember=[\n')
        level += 1
        for curveMember_ in self.curveMember:
            showIndent(outfile, level)
            outfile.write('model_.curveMember(\n')
            curveMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.curveMembers is not None:
            showIndent(outfile, level)
            outfile.write('curveMembers=model_.curveMembers(\n')
            self.curveMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiCurveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'curveMember':
            obj_ = CurvePropertyType.factory()
            obj_.build(child_)
            self.curveMember.append(obj_)
        elif nodeName_ == 'curveMembers':
            obj_ = CurveArrayPropertyType.factory()
            obj_.build(child_)
            self.set_curveMembers(obj_)
        super(MultiCurveType, self).buildChildren(child_, node, nodeName_, True)
# end class MultiCurveType


class MultiPointType(AbstractGeometricAggregateType):
    subclass = None
    superclass = AbstractGeometricAggregateType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, pointMember=None, pointMembers=None):
        super(MultiPointType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, aggregationType, )
        if pointMember is None:
            self.pointMember = []
        else:
            self.pointMember = pointMember
        self.pointMembers = pointMembers
    def factory(*args_, **kwargs_):
        if MultiPointType.subclass:
            return MultiPointType.subclass(*args_, **kwargs_)
        else:
            return MultiPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pointMember(self): return self.pointMember
    def set_pointMember(self, pointMember): self.pointMember = pointMember
    def add_pointMember(self, value): self.pointMember.append(value)
    def insert_pointMember(self, index, value): self.pointMember[index] = value
    def get_pointMembers(self): return self.pointMembers
    def set_pointMembers(self, pointMembers): self.pointMembers = pointMembers
    def export(self, outfile, level, namespace_='', name_='MultiPointType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiPointType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiPointType'):
        super(MultiPointType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MultiPointType')
    def exportChildren(self, outfile, level, namespace_='', name_='MultiPointType', fromsubclass_=False):
        super(MultiPointType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pointMember_ in self.pointMember:
            pointMember_.export(outfile, level, namespace_, name_='pointMember')
        if self.pointMembers is not None:
            self.pointMembers.export(outfile, level, namespace_, name_='pointMembers')
    def hasContent_(self):
        if (
            self.pointMember or
            self.pointMembers is not None or
            super(MultiPointType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MultiPointType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MultiPointType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pointMember=[\n')
        level += 1
        for pointMember_ in self.pointMember:
            showIndent(outfile, level)
            outfile.write('model_.pointMember(\n')
            pointMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.pointMembers is not None:
            showIndent(outfile, level)
            outfile.write('pointMembers=model_.pointMembers(\n')
            self.pointMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiPointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pointMember':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointMember.append(obj_)
        elif nodeName_ == 'pointMembers':
            obj_ = PointArrayPropertyType.factory()
            obj_.build(child_)
            self.set_pointMembers(obj_)
        super(MultiPointType, self).buildChildren(child_, node, nodeName_, True)
# end class MultiPointType


class MultiGeometryType(AbstractGeometricAggregateType):
    subclass = None
    superclass = AbstractGeometricAggregateType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, geometryMember=None, geometryMembers=None):
        super(MultiGeometryType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, aggregationType, )
        if geometryMember is None:
            self.geometryMember = []
        else:
            self.geometryMember = geometryMember
        self.geometryMembers = geometryMembers
    def factory(*args_, **kwargs_):
        if MultiGeometryType.subclass:
            return MultiGeometryType.subclass(*args_, **kwargs_)
        else:
            return MultiGeometryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geometryMember(self): return self.geometryMember
    def set_geometryMember(self, geometryMember): self.geometryMember = geometryMember
    def add_geometryMember(self, value): self.geometryMember.append(value)
    def insert_geometryMember(self, index, value): self.geometryMember[index] = value
    def get_geometryMembers(self): return self.geometryMembers
    def set_geometryMembers(self, geometryMembers): self.geometryMembers = geometryMembers
    def export(self, outfile, level, namespace_='', name_='MultiGeometryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiGeometryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiGeometryType'):
        super(MultiGeometryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MultiGeometryType')
    def exportChildren(self, outfile, level, namespace_='', name_='MultiGeometryType', fromsubclass_=False):
        super(MultiGeometryType, self).exportChildren(outfile, level, namespace_, name_, True)
        for geometryMember_ in self.geometryMember:
            geometryMember_.export(outfile, level, namespace_, name_='geometryMember')
        if self.geometryMembers is not None:
            self.geometryMembers.export(outfile, level, namespace_, name_='geometryMembers')
    def hasContent_(self):
        if (
            self.geometryMember or
            self.geometryMembers is not None or
            super(MultiGeometryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiGeometryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MultiGeometryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MultiGeometryType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('geometryMember=[\n')
        level += 1
        for geometryMember_ in self.geometryMember:
            showIndent(outfile, level)
            outfile.write('model_.geometryMember(\n')
            geometryMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.geometryMembers is not None:
            showIndent(outfile, level)
            outfile.write('geometryMembers=model_.geometryMembers(\n')
            self.geometryMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiGeometryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geometryMember':
            obj_ = GeometryPropertyType.factory()
            obj_.build(child_)
            self.geometryMember.append(obj_)
        elif nodeName_ == 'geometryMembers':
            obj_ = GeometryArrayPropertyType.factory()
            obj_.build(child_)
            self.set_geometryMembers(obj_)
        super(MultiGeometryType, self).buildChildren(child_, node, nodeName_, True)
# end class MultiGeometryType


class CompositeSolidType(AbstractSolidType):
    subclass = None
    superclass = AbstractSolidType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, solidMember=None):
        super(CompositeSolidType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.aggregationType = _cast(None, aggregationType)
        if solidMember is None:
            self.solidMember = []
        else:
            self.solidMember = solidMember
    def factory(*args_, **kwargs_):
        if CompositeSolidType.subclass:
            return CompositeSolidType.subclass(*args_, **kwargs_)
        else:
            return CompositeSolidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_solidMember(self): return self.solidMember
    def set_solidMember(self, solidMember): self.solidMember = solidMember
    def add_solidMember(self, value): self.solidMember.append(value)
    def insert_solidMember(self, index, value): self.solidMember[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='CompositeSolidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeSolidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompositeSolidType'):
        super(CompositeSolidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeSolidType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CompositeSolidType', fromsubclass_=False):
        super(CompositeSolidType, self).exportChildren(outfile, level, namespace_, name_, True)
        for solidMember_ in self.solidMember:
            solidMember_.export(outfile, level, namespace_, name_='solidMember')
    def hasContent_(self):
        if (
            self.solidMember or
            super(CompositeSolidType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CompositeSolidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(CompositeSolidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CompositeSolidType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('solidMember=[\n')
        level += 1
        for solidMember_ in self.solidMember:
            showIndent(outfile, level)
            outfile.write('model_.solidMember(\n')
            solidMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(CompositeSolidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'solidMember':
            obj_ = SolidPropertyType.factory()
            obj_.build(child_)
            self.solidMember.append(obj_)
        super(CompositeSolidType, self).buildChildren(child_, node, nodeName_, True)
# end class CompositeSolidType


class CompositeSurfaceType(AbstractSurfaceType):
    subclass = None
    superclass = AbstractSurfaceType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, surfaceMember=None):
        super(CompositeSurfaceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.aggregationType = _cast(None, aggregationType)
        if surfaceMember is None:
            self.surfaceMember = []
        else:
            self.surfaceMember = surfaceMember
    def factory(*args_, **kwargs_):
        if CompositeSurfaceType.subclass:
            return CompositeSurfaceType.subclass(*args_, **kwargs_)
        else:
            return CompositeSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_surfaceMember(self): return self.surfaceMember
    def set_surfaceMember(self, surfaceMember): self.surfaceMember = surfaceMember
    def add_surfaceMember(self, value): self.surfaceMember.append(value)
    def insert_surfaceMember(self, index, value): self.surfaceMember[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='CompositeSurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeSurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompositeSurfaceType'):
        super(CompositeSurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeSurfaceType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CompositeSurfaceType', fromsubclass_=False):
        super(CompositeSurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        for surfaceMember_ in self.surfaceMember:
            surfaceMember_.export(outfile, level, namespace_, name_='surfaceMember')
    def hasContent_(self):
        if (
            self.surfaceMember or
            super(CompositeSurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CompositeSurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(CompositeSurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CompositeSurfaceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('surfaceMember=[\n')
        level += 1
        for surfaceMember_ in self.surfaceMember:
            showIndent(outfile, level)
            outfile.write('model_.surfaceMember(\n')
            surfaceMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(CompositeSurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'surfaceMember':
            obj_ = SurfacePropertyType.factory()
            obj_.build(child_)
            self.surfaceMember.append(obj_)
        super(CompositeSurfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class CompositeSurfaceType


class TopoComplexType(AbstractTopologyType):
    subclass = None
    superclass = AbstractTopologyType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, isMaximal='false', maximalComplex=None, superComplex=None, subComplex=None, topoPrimitiveMember=None, topoPrimitiveMembers=None):
        super(TopoComplexType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        self.isMaximal = _cast(None, isMaximal)
        self.maximalComplex = maximalComplex
        if superComplex is None:
            self.superComplex = []
        else:
            self.superComplex = superComplex
        if subComplex is None:
            self.subComplex = []
        else:
            self.subComplex = subComplex
        if topoPrimitiveMember is None:
            self.topoPrimitiveMember = []
        else:
            self.topoPrimitiveMember = topoPrimitiveMember
        self.topoPrimitiveMembers = topoPrimitiveMembers
    def factory(*args_, **kwargs_):
        if TopoComplexType.subclass:
            return TopoComplexType.subclass(*args_, **kwargs_)
        else:
            return TopoComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maximalComplex(self): return self.maximalComplex
    def set_maximalComplex(self, maximalComplex): self.maximalComplex = maximalComplex
    def get_superComplex(self): return self.superComplex
    def set_superComplex(self, superComplex): self.superComplex = superComplex
    def add_superComplex(self, value): self.superComplex.append(value)
    def insert_superComplex(self, index, value): self.superComplex[index] = value
    def get_subComplex(self): return self.subComplex
    def set_subComplex(self, subComplex): self.subComplex = subComplex
    def add_subComplex(self, value): self.subComplex.append(value)
    def insert_subComplex(self, index, value): self.subComplex[index] = value
    def get_topoPrimitiveMember(self): return self.topoPrimitiveMember
    def set_topoPrimitiveMember(self, topoPrimitiveMember): self.topoPrimitiveMember = topoPrimitiveMember
    def add_topoPrimitiveMember(self, value): self.topoPrimitiveMember.append(value)
    def insert_topoPrimitiveMember(self, index, value): self.topoPrimitiveMember[index] = value
    def get_topoPrimitiveMembers(self): return self.topoPrimitiveMembers
    def set_topoPrimitiveMembers(self, topoPrimitiveMembers): self.topoPrimitiveMembers = topoPrimitiveMembers
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def get_isMaximal(self): return self.isMaximal
    def set_isMaximal(self, isMaximal): self.isMaximal = isMaximal
    def export(self, outfile, level, namespace_='', name_='TopoComplexType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoComplexType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoComplexType'):
        super(TopoComplexType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TopoComplexType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.isMaximal is not None and 'isMaximal' not in already_processed:
            already_processed.append('isMaximal')
            outfile.write(' isMaximal=%s' % (quote_attrib(self.isMaximal), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoComplexType', fromsubclass_=False):
        super(TopoComplexType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.maximalComplex is not None:
            self.maximalComplex.export(outfile, level, namespace_, name_='maximalComplex', )
        for superComplex_ in self.superComplex:
            superComplex_.export(outfile, level, namespace_, name_='superComplex')
        for subComplex_ in self.subComplex:
            subComplex_.export(outfile, level, namespace_, name_='subComplex')
        for topoPrimitiveMember_ in self.topoPrimitiveMember:
            topoPrimitiveMember_.export(outfile, level, namespace_, name_='topoPrimitiveMember')
        if self.topoPrimitiveMembers is not None:
            self.topoPrimitiveMembers.export(outfile, level, namespace_, name_='topoPrimitiveMembers')
    def hasContent_(self):
        if (
            self.maximalComplex is not None or
            self.superComplex or
            self.subComplex or
            self.topoPrimitiveMember or
            self.topoPrimitiveMembers is not None or
            super(TopoComplexType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoComplexType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        if self.isMaximal is not None and 'isMaximal' not in already_processed:
            already_processed.append('isMaximal')
            showIndent(outfile, level)
            outfile.write('isMaximal = %s,\n' % (self.isMaximal,))
        super(TopoComplexType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TopoComplexType, self).exportLiteralChildren(outfile, level, name_)
        if self.maximalComplex is not None:
            showIndent(outfile, level)
            outfile.write('maximalComplex=model_.maximalComplex(\n')
            self.maximalComplex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('superComplex=[\n')
        level += 1
        for superComplex_ in self.superComplex:
            showIndent(outfile, level)
            outfile.write('model_.superComplex(\n')
            superComplex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subComplex=[\n')
        level += 1
        for subComplex_ in self.subComplex:
            showIndent(outfile, level)
            outfile.write('model_.subComplex(\n')
            subComplex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('topoPrimitiveMember=[\n')
        level += 1
        for topoPrimitiveMember_ in self.topoPrimitiveMember:
            showIndent(outfile, level)
            outfile.write('model_.topoPrimitiveMember(\n')
            topoPrimitiveMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.topoPrimitiveMembers is not None:
            showIndent(outfile, level)
            outfile.write('topoPrimitiveMembers=model_.topoPrimitiveMembers(\n')
            self.topoPrimitiveMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('isMaximal', node)
        if value is not None and 'isMaximal' not in already_processed:
            already_processed.append('isMaximal')
            self.isMaximal = value
        super(TopoComplexType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'maximalComplex':
            obj_ = TopoComplexPropertyType.factory()
            obj_.build(child_)
            self.set_maximalComplex(obj_)
        elif nodeName_ == 'superComplex':
            obj_ = TopoComplexPropertyType.factory()
            obj_.build(child_)
            self.superComplex.append(obj_)
        elif nodeName_ == 'subComplex':
            obj_ = TopoComplexPropertyType.factory()
            obj_.build(child_)
            self.subComplex.append(obj_)
        elif nodeName_ == 'topoPrimitiveMember':
            obj_ = TopoPrimitiveMemberType.factory()
            obj_.build(child_)
            self.topoPrimitiveMember.append(obj_)
        elif nodeName_ == 'topoPrimitiveMembers':
            obj_ = TopoPrimitiveArrayAssociationType.factory()
            obj_.build(child_)
            self.set_topoPrimitiveMembers(obj_)
        super(TopoComplexType, self).buildChildren(child_, node, nodeName_, True)
# end class TopoComplexType


class TopoVolumeType(AbstractTopologyType):
    subclass = None
    superclass = AbstractTopologyType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, directedTopoSolid=None):
        super(TopoVolumeType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        if directedTopoSolid is None:
            self.directedTopoSolid = []
        else:
            self.directedTopoSolid = directedTopoSolid
    def factory(*args_, **kwargs_):
        if TopoVolumeType.subclass:
            return TopoVolumeType.subclass(*args_, **kwargs_)
        else:
            return TopoVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directedTopoSolid(self): return self.directedTopoSolid
    def set_directedTopoSolid(self, directedTopoSolid): self.directedTopoSolid = directedTopoSolid
    def add_directedTopoSolid(self, value): self.directedTopoSolid.append(value)
    def insert_directedTopoSolid(self, index, value): self.directedTopoSolid[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='TopoVolumeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoVolumeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoVolumeType'):
        super(TopoVolumeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TopoVolumeType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoVolumeType', fromsubclass_=False):
        super(TopoVolumeType, self).exportChildren(outfile, level, namespace_, name_, True)
        for directedTopoSolid_ in self.directedTopoSolid:
            directedTopoSolid_.export(outfile, level, namespace_, name_='directedTopoSolid')
    def hasContent_(self):
        if (
            self.directedTopoSolid or
            super(TopoVolumeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoVolumeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(TopoVolumeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TopoVolumeType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('directedTopoSolid=[\n')
        level += 1
        for directedTopoSolid_ in self.directedTopoSolid:
            showIndent(outfile, level)
            outfile.write('model_.directedTopoSolid(\n')
            directedTopoSolid_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(TopoVolumeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'directedTopoSolid':
            obj_ = DirectedTopoSolidPropertyType.factory()
            obj_.build(child_)
            self.directedTopoSolid.append(obj_)
        super(TopoVolumeType, self).buildChildren(child_, node, nodeName_, True)
# end class TopoVolumeType


class TopoSurfaceType(AbstractTopologyType):
    subclass = None
    superclass = AbstractTopologyType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, directedFace=None):
        super(TopoSurfaceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        if directedFace is None:
            self.directedFace = []
        else:
            self.directedFace = directedFace
    def factory(*args_, **kwargs_):
        if TopoSurfaceType.subclass:
            return TopoSurfaceType.subclass(*args_, **kwargs_)
        else:
            return TopoSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directedFace(self): return self.directedFace
    def set_directedFace(self, directedFace): self.directedFace = directedFace
    def add_directedFace(self, value): self.directedFace.append(value)
    def insert_directedFace(self, index, value): self.directedFace[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='TopoSurfaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoSurfaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoSurfaceType'):
        super(TopoSurfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TopoSurfaceType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoSurfaceType', fromsubclass_=False):
        super(TopoSurfaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        for directedFace_ in self.directedFace:
            directedFace_.export(outfile, level, namespace_, name_='directedFace')
    def hasContent_(self):
        if (
            self.directedFace or
            super(TopoSurfaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoSurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(TopoSurfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TopoSurfaceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('directedFace=[\n')
        level += 1
        for directedFace_ in self.directedFace:
            showIndent(outfile, level)
            outfile.write('model_.directedFace(\n')
            directedFace_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(TopoSurfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'directedFace':
            obj_ = DirectedFacePropertyType.factory()
            obj_.build(child_)
            self.directedFace.append(obj_)
        super(TopoSurfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class TopoSurfaceType


class TopoCurveType(AbstractTopologyType):
    subclass = None
    superclass = AbstractTopologyType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, directedEdge=None):
        super(TopoCurveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        if directedEdge is None:
            self.directedEdge = []
        else:
            self.directedEdge = directedEdge
    def factory(*args_, **kwargs_):
        if TopoCurveType.subclass:
            return TopoCurveType.subclass(*args_, **kwargs_)
        else:
            return TopoCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directedEdge(self): return self.directedEdge
    def set_directedEdge(self, directedEdge): self.directedEdge = directedEdge
    def add_directedEdge(self, value): self.directedEdge.append(value)
    def insert_directedEdge(self, index, value): self.directedEdge[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='TopoCurveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoCurveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoCurveType'):
        super(TopoCurveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TopoCurveType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoCurveType', fromsubclass_=False):
        super(TopoCurveType, self).exportChildren(outfile, level, namespace_, name_, True)
        for directedEdge_ in self.directedEdge:
            directedEdge_.export(outfile, level, namespace_, name_='directedEdge')
    def hasContent_(self):
        if (
            self.directedEdge or
            super(TopoCurveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoCurveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(TopoCurveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TopoCurveType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('directedEdge=[\n')
        level += 1
        for directedEdge_ in self.directedEdge:
            showIndent(outfile, level)
            outfile.write('model_.directedEdge(\n')
            directedEdge_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(TopoCurveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'directedEdge':
            obj_ = DirectedEdgePropertyType.factory()
            obj_.build(child_)
            self.directedEdge.append(obj_)
        super(TopoCurveType, self).buildChildren(child_, node, nodeName_, True)
# end class TopoCurveType


class TopoPointType(AbstractTopologyType):
    subclass = None
    superclass = AbstractTopologyType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, directedNode=None):
        super(TopoPointType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.directedNode = directedNode
    def factory(*args_, **kwargs_):
        if TopoPointType.subclass:
            return TopoPointType.subclass(*args_, **kwargs_)
        else:
            return TopoPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directedNode(self): return self.directedNode
    def set_directedNode(self, directedNode): self.directedNode = directedNode
    def export(self, outfile, level, namespace_='', name_='TopoPointType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoPointType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoPointType'):
        super(TopoPointType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TopoPointType')
    def exportChildren(self, outfile, level, namespace_='', name_='TopoPointType', fromsubclass_=False):
        super(TopoPointType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.directedNode is not None:
            self.directedNode.export(outfile, level, namespace_, name_='directedNode', )
    def hasContent_(self):
        if (
            self.directedNode is not None or
            super(TopoPointType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TopoPointType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TopoPointType, self).exportLiteralChildren(outfile, level, name_)
        if self.directedNode is not None:
            showIndent(outfile, level)
            outfile.write('directedNode=model_.directedNode(\n')
            self.directedNode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TopoPointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'directedNode':
            obj_ = DirectedNodePropertyType.factory()
            obj_.build(child_)
            self.set_directedNode(obj_)
        super(TopoPointType, self).buildChildren(child_, node, nodeName_, True)
# end class TopoPointType


class AbstractTopoPrimitiveType(AbstractTopologyType):
    subclass = None
    superclass = AbstractTopologyType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, extensiontype_=None):
        super(AbstractTopoPrimitiveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractTopoPrimitiveType.subclass:
            return AbstractTopoPrimitiveType.subclass(*args_, **kwargs_)
        else:
            return AbstractTopoPrimitiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractTopoPrimitiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTopoPrimitiveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractTopoPrimitiveType'):
        super(AbstractTopoPrimitiveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractTopoPrimitiveType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractTopoPrimitiveType', fromsubclass_=False):
        super(AbstractTopoPrimitiveType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractTopoPrimitiveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractTopoPrimitiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractTopoPrimitiveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTopoPrimitiveType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractTopoPrimitiveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractTopoPrimitiveType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractTopoPrimitiveType


class DynamicFeatureCollectionType(DynamicFeatureType):
    subclass = None
    superclass = DynamicFeatureType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, boundedBy=None, location=None, validTime=None, history=None, dataSource=None, dataSourceReference=None, dynamicMembers=None):
        super(DynamicFeatureCollectionType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, boundedBy, location, validTime, history, dataSource, dataSourceReference, )
        self.dynamicMembers = dynamicMembers
    def factory(*args_, **kwargs_):
        if DynamicFeatureCollectionType.subclass:
            return DynamicFeatureCollectionType.subclass(*args_, **kwargs_)
        else:
            return DynamicFeatureCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dynamicMembers(self): return self.dynamicMembers
    def set_dynamicMembers(self, dynamicMembers): self.dynamicMembers = dynamicMembers
    def export(self, outfile, level, namespace_='', name_='DynamicFeatureCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicFeatureCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DynamicFeatureCollectionType'):
        super(DynamicFeatureCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicFeatureCollectionType')
    def exportChildren(self, outfile, level, namespace_='', name_='DynamicFeatureCollectionType', fromsubclass_=False):
        super(DynamicFeatureCollectionType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.dynamicMembers is not None:
            self.dynamicMembers.export(outfile, level, namespace_, name_='dynamicMembers', )
    def hasContent_(self):
        if (
            self.dynamicMembers is not None or
            super(DynamicFeatureCollectionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DynamicFeatureCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DynamicFeatureCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DynamicFeatureCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.dynamicMembers is not None:
            showIndent(outfile, level)
            outfile.write('dynamicMembers=model_.dynamicMembers(\n')
            self.dynamicMembers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DynamicFeatureCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dynamicMembers':
            obj_ = DynamicFeatureMemberType.factory()
            obj_.build(child_)
            self.set_dynamicMembers(obj_)
        super(DynamicFeatureCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class DynamicFeatureCollectionType


class DS_StereoMate_Type(DS_OtherAggregate_Type):
    subclass = None
    superclass = DS_OtherAggregate_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None):
        super(DS_StereoMate_Type, self).__init__(id, uuid, composedOf, seriesMetadata, subset, superset, )
        pass
    def factory(*args_, **kwargs_):
        if DS_StereoMate_Type.subclass:
            return DS_StereoMate_Type.subclass(*args_, **kwargs_)
        else:
            return DS_StereoMate_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DS_StereoMate_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_StereoMate_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_StereoMate_Type'):
        super(DS_StereoMate_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_StereoMate_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DS_StereoMate_Type', fromsubclass_=False):
        super(DS_StereoMate_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DS_StereoMate_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_StereoMate_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_StereoMate_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_StereoMate_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DS_StereoMate_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_StereoMate_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_StereoMate_Type


class DS_ProductionSeries_Type(DS_Series_Type):
    subclass = None
    superclass = DS_Series_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None):
        super(DS_ProductionSeries_Type, self).__init__(id, uuid, composedOf, seriesMetadata, subset, superset, )
        pass
    def factory(*args_, **kwargs_):
        if DS_ProductionSeries_Type.subclass:
            return DS_ProductionSeries_Type.subclass(*args_, **kwargs_)
        else:
            return DS_ProductionSeries_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DS_ProductionSeries_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_ProductionSeries_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_ProductionSeries_Type'):
        super(DS_ProductionSeries_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_ProductionSeries_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DS_ProductionSeries_Type', fromsubclass_=False):
        super(DS_ProductionSeries_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DS_ProductionSeries_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_ProductionSeries_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_ProductionSeries_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_ProductionSeries_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DS_ProductionSeries_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_ProductionSeries_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_ProductionSeries_Type


class DS_Sensor_Type(DS_Series_Type):
    subclass = None
    superclass = DS_Series_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None):
        super(DS_Sensor_Type, self).__init__(id, uuid, composedOf, seriesMetadata, subset, superset, )
        pass
    def factory(*args_, **kwargs_):
        if DS_Sensor_Type.subclass:
            return DS_Sensor_Type.subclass(*args_, **kwargs_)
        else:
            return DS_Sensor_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DS_Sensor_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Sensor_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Sensor_Type'):
        super(DS_Sensor_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Sensor_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Sensor_Type', fromsubclass_=False):
        super(DS_Sensor_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DS_Sensor_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Sensor_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_Sensor_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_Sensor_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DS_Sensor_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_Sensor_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_Sensor_Type


class DS_Platform_Type(DS_Series_Type):
    subclass = None
    superclass = DS_Series_Type
    def __init__(self, id=None, uuid=None, composedOf=None, seriesMetadata=None, subset=None, superset=None):
        super(DS_Platform_Type, self).__init__(id, uuid, composedOf, seriesMetadata, subset, superset, )
        pass
    def factory(*args_, **kwargs_):
        if DS_Platform_Type.subclass:
            return DS_Platform_Type.subclass(*args_, **kwargs_)
        else:
            return DS_Platform_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DS_Platform_Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Platform_Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_Platform_Type'):
        super(DS_Platform_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DS_Platform_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DS_Platform_Type', fromsubclass_=False):
        super(DS_Platform_Type, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DS_Platform_Type, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DS_Platform_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DS_Platform_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DS_Platform_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DS_Platform_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DS_Platform_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DS_Platform_Type


class RectifiedGridType(GridType):
    subclass = None
    superclass = GridType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, dimension=None, limits=None, axisLabels=None, axisName=None, origin=None, offsetVector=None):
        super(RectifiedGridType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, dimension, limits, axisLabels, axisName, )
        self.origin = origin
        if offsetVector is None:
            self.offsetVector = []
        else:
            self.offsetVector = offsetVector
    def factory(*args_, **kwargs_):
        if RectifiedGridType.subclass:
            return RectifiedGridType.subclass(*args_, **kwargs_)
        else:
            return RectifiedGridType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_offsetVector(self): return self.offsetVector
    def set_offsetVector(self, offsetVector): self.offsetVector = offsetVector
    def add_offsetVector(self, value): self.offsetVector.append(value)
    def insert_offsetVector(self, index, value): self.offsetVector[index] = value
    def export(self, outfile, level, namespace_='', name_='RectifiedGridType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RectifiedGridType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RectifiedGridType'):
        super(RectifiedGridType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RectifiedGridType')
    def exportChildren(self, outfile, level, namespace_='', name_='RectifiedGridType', fromsubclass_=False):
        super(RectifiedGridType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', )
        for offsetVector_ in self.offsetVector:
            offsetVector_.export(outfile, level, namespace_, name_='offsetVector')
    def hasContent_(self):
        if (
            self.origin is not None or
            self.offsetVector or
            super(RectifiedGridType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RectifiedGridType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RectifiedGridType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RectifiedGridType, self).exportLiteralChildren(outfile, level, name_)
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.PointPropertyType(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('offsetVector=[\n')
        level += 1
        for offsetVector_ in self.offsetVector:
            showIndent(outfile, level)
            outfile.write('model_.VectorType(\n')
            offsetVector_.exportLiteral(outfile, level, name_='VectorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(RectifiedGridType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_origin(obj_)
        elif nodeName_ == 'offsetVector':
            obj_ = VectorType.factory()
            obj_.build(child_)
            self.offsetVector.append(obj_)
        super(RectifiedGridType, self).buildChildren(child_, node, nodeName_, True)
# end class RectifiedGridType


class AbstractCurveType(AbstractGeometricPrimitiveType):
    """gml:AbstractCurveType is an abstraction of a curve to support the
    different levels of complexity. The curve may always be viewed
    as a geometric primitive, i.e. is continuous."""
    subclass = None
    superclass = AbstractGeometricPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, extensiontype_=None):
        super(AbstractCurveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractCurveType.subclass:
            return AbstractCurveType.subclass(*args_, **kwargs_)
        else:
            return AbstractCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractCurveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCurveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractCurveType'):
        super(AbstractCurveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCurveType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCurveType', fromsubclass_=False):
        super(AbstractCurveType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractCurveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCurveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractCurveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractCurveType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractCurveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractCurveType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractCurveType


class PointType(AbstractGeometricPrimitiveType):
    subclass = None
    superclass = AbstractGeometricPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, pos=None, coordinates=None):
        super(PointType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.pos = pos
        self.coordinates = coordinates
    def factory(*args_, **kwargs_):
        if PointType.subclass:
            return PointType.subclass(*args_, **kwargs_)
        else:
            return PointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def export(self, outfile, level, namespace_='', name_='PointType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointType'):
        super(PointType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PointType')
    def exportChildren(self, outfile, level, namespace_='', name_='PointType', fromsubclass_=False):
        super(PointType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.pos is not None:
            self.pos.export(outfile, level, namespace_, name_='pos', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
    def hasContent_(self):
        if (
            self.pos is not None or
            self.coordinates is not None or
            super(PointType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PointType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PointType, self).exportLiteralChildren(outfile, level, name_)
        if self.pos is not None:
            showIndent(outfile, level)
            outfile.write('pos=model_.pos(\n')
            self.pos.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_pos(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        super(PointType, self).buildChildren(child_, node, nodeName_, True)
# end class PointType


class PolygonType(AbstractSurfaceType):
    subclass = None
    superclass = AbstractSurfaceType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, exterior=None, interior=None):
        super(PolygonType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.exterior = exterior
        if interior is None:
            self.interior = []
        else:
            self.interior = interior
    def factory(*args_, **kwargs_):
        if PolygonType.subclass:
            return PolygonType.subclass(*args_, **kwargs_)
        else:
            return PolygonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exterior(self): return self.exterior
    def set_exterior(self, exterior): self.exterior = exterior
    def get_interior(self): return self.interior
    def set_interior(self, interior): self.interior = interior
    def add_interior(self, value): self.interior.append(value)
    def insert_interior(self, index, value): self.interior[index] = value
    def export(self, outfile, level, namespace_='', name_='PolygonType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolygonType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolygonType'):
        super(PolygonType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PolygonType')
    def exportChildren(self, outfile, level, namespace_='', name_='PolygonType', fromsubclass_=False):
        super(PolygonType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.exterior is not None:
            self.exterior.export(outfile, level, namespace_, name_='exterior')
        for interior_ in self.interior:
            interior_.export(outfile, level, namespace_, name_='interior')
    def hasContent_(self):
        if (
            self.exterior is not None or
            self.interior or
            super(PolygonType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolygonType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PolygonType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PolygonType, self).exportLiteralChildren(outfile, level, name_)
        if self.exterior is not None:
            showIndent(outfile, level)
            outfile.write('exterior=model_.exterior(\n')
            self.exterior.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('interior=[\n')
        level += 1
        for interior_ in self.interior:
            showIndent(outfile, level)
            outfile.write('model_.interior(\n')
            interior_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PolygonType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exterior':
            obj_ = AbstractRingPropertyType.factory()
            obj_.build(child_)
            self.set_exterior(obj_)
        elif nodeName_ == 'interior':
            obj_ = AbstractRingPropertyType.factory()
            obj_.build(child_)
            self.interior.append(obj_)
        super(PolygonType, self).buildChildren(child_, node, nodeName_, True)
# end class PolygonType


class SolidType(AbstractSolidType):
    subclass = None
    superclass = AbstractSolidType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, exterior=None, interior=None):
        super(SolidType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.exterior = exterior
        if interior is None:
            self.interior = []
        else:
            self.interior = interior
    def factory(*args_, **kwargs_):
        if SolidType.subclass:
            return SolidType.subclass(*args_, **kwargs_)
        else:
            return SolidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exterior(self): return self.exterior
    def set_exterior(self, exterior): self.exterior = exterior
    def get_interior(self): return self.interior
    def set_interior(self, interior): self.interior = interior
    def add_interior(self, value): self.interior.append(value)
    def insert_interior(self, index, value): self.interior[index] = value
    def export(self, outfile, level, namespace_='', name_='SolidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SolidType'):
        super(SolidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SolidType')
    def exportChildren(self, outfile, level, namespace_='', name_='SolidType', fromsubclass_=False):
        super(SolidType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.exterior is not None:
            self.exterior.export(outfile, level, namespace_, name_='exterior')
        for interior_ in self.interior:
            interior_.export(outfile, level, namespace_, name_='interior')
    def hasContent_(self):
        if (
            self.exterior is not None or
            self.interior or
            super(SolidType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SolidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SolidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SolidType, self).exportLiteralChildren(outfile, level, name_)
        if self.exterior is not None:
            showIndent(outfile, level)
            outfile.write('exterior=model_.ShellPropertyType(\n')
            self.exterior.exportLiteral(outfile, level, name_='exterior')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('interior=[\n')
        level += 1
        for interior_ in self.interior:
            showIndent(outfile, level)
            outfile.write('model_.ShellPropertyType(\n')
            interior_.exportLiteral(outfile, level, name_='ShellPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SolidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exterior':
            obj_ = ShellPropertyType.factory()
            obj_.build(child_)
            self.set_exterior(obj_)
        elif nodeName_ == 'interior':
            obj_ = ShellPropertyType.factory()
            obj_.build(child_)
            self.interior.append(obj_)
        super(SolidType, self).buildChildren(child_, node, nodeName_, True)
# end class SolidType


class TinType(SurfaceType):
    subclass = None
    superclass = SurfaceType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, patches=None, stopLines=None, breakLines=None, maxLength=None, controlPoint=None):
        super(TinType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, patches, )
        if stopLines is None:
            self.stopLines = []
        else:
            self.stopLines = stopLines
        if breakLines is None:
            self.breakLines = []
        else:
            self.breakLines = breakLines
        self.maxLength = maxLength
        self.controlPoint = controlPoint
    def factory(*args_, **kwargs_):
        if TinType.subclass:
            return TinType.subclass(*args_, **kwargs_)
        else:
            return TinType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stopLines(self): return self.stopLines
    def set_stopLines(self, stopLines): self.stopLines = stopLines
    def add_stopLines(self, value): self.stopLines.append(value)
    def insert_stopLines(self, index, value): self.stopLines[index] = value
    def get_breakLines(self): return self.breakLines
    def set_breakLines(self, breakLines): self.breakLines = breakLines
    def add_breakLines(self, value): self.breakLines.append(value)
    def insert_breakLines(self, index, value): self.breakLines[index] = value
    def get_maxLength(self): return self.maxLength
    def set_maxLength(self, maxLength): self.maxLength = maxLength
    def get_controlPoint(self): return self.controlPoint
    def set_controlPoint(self, controlPoint): self.controlPoint = controlPoint
    def export(self, outfile, level, namespace_='', name_='TinType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TinType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TinType'):
        super(TinType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TinType')
    def exportChildren(self, outfile, level, namespace_='', name_='TinType', fromsubclass_=False):
        super(TinType, self).exportChildren(outfile, level, namespace_, name_, True)
        for stopLines_ in self.stopLines:
            stopLines_.export(outfile, level, namespace_, name_='stopLines')
        for breakLines_ in self.breakLines:
            breakLines_.export(outfile, level, namespace_, name_='breakLines')
        if self.maxLength is not None:
            self.maxLength.export(outfile, level, namespace_, name_='maxLength', )
        if self.controlPoint is not None:
            self.controlPoint.export(outfile, level, namespace_, name_='controlPoint', )
    def hasContent_(self):
        if (
            self.stopLines or
            self.breakLines or
            self.maxLength is not None or
            self.controlPoint is not None or
            super(TinType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TinType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TinType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TinType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('stopLines=[\n')
        level += 1
        for stopLines_ in self.stopLines:
            showIndent(outfile, level)
            outfile.write('model_.LineStringSegmentArrayPropertyType(\n')
            stopLines_.exportLiteral(outfile, level, name_='LineStringSegmentArrayPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('breakLines=[\n')
        level += 1
        for breakLines_ in self.breakLines:
            showIndent(outfile, level)
            outfile.write('model_.LineStringSegmentArrayPropertyType(\n')
            breakLines_.exportLiteral(outfile, level, name_='LineStringSegmentArrayPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.maxLength is not None:
            showIndent(outfile, level)
            outfile.write('maxLength=model_.LengthType(\n')
            self.maxLength.exportLiteral(outfile, level, name_='maxLength')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.controlPoint is not None:
            showIndent(outfile, level)
            outfile.write('controlPoint=model_.controlPointType(\n')
            self.controlPoint.exportLiteral(outfile, level, name_='controlPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TinType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stopLines':
            obj_ = LineStringSegmentArrayPropertyType.factory()
            obj_.build(child_)
            self.stopLines.append(obj_)
        elif nodeName_ == 'breakLines':
            obj_ = LineStringSegmentArrayPropertyType.factory()
            obj_.build(child_)
            self.breakLines.append(obj_)
        elif nodeName_ == 'maxLength':
            obj_ = LengthType.factory()
            obj_.build(child_)
            self.set_maxLength(obj_)
        elif nodeName_ == 'controlPoint':
            obj_ = controlPointType.factory()
            obj_.build(child_)
            self.set_controlPoint(obj_)
        super(TinType, self).buildChildren(child_, node, nodeName_, True)
# end class TinType


class OrientableCurveType(AbstractCurveType):
    subclass = None
    superclass = AbstractCurveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, orientation='+', baseCurve=None):
        super(OrientableCurveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.orientation = _cast(None, orientation)
        self.baseCurve = baseCurve
    def factory(*args_, **kwargs_):
        if OrientableCurveType.subclass:
            return OrientableCurveType.subclass(*args_, **kwargs_)
        else:
            return OrientableCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseCurve(self): return self.baseCurve
    def set_baseCurve(self, baseCurve): self.baseCurve = baseCurve
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def export(self, outfile, level, namespace_='', name_='OrientableCurveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrientableCurveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrientableCurveType'):
        super(OrientableCurveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrientableCurveType')
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            outfile.write(' orientation=%s' % (quote_attrib(self.orientation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrientableCurveType', fromsubclass_=False):
        super(OrientableCurveType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.baseCurve is not None:
            self.baseCurve.export(outfile, level, namespace_, name_='baseCurve', )
    def hasContent_(self):
        if (
            self.baseCurve is not None or
            super(OrientableCurveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrientableCurveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            showIndent(outfile, level)
            outfile.write('orientation = %s,\n' % (self.orientation,))
        super(OrientableCurveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrientableCurveType, self).exportLiteralChildren(outfile, level, name_)
        if self.baseCurve is not None:
            showIndent(outfile, level)
            outfile.write('baseCurve=model_.baseCurve(\n')
            self.baseCurve.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.append('orientation')
            self.orientation = value
        super(OrientableCurveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseCurve':
            obj_ = CurvePropertyType.factory()
            obj_.build(child_)
            self.set_baseCurve(obj_)
        super(OrientableCurveType, self).buildChildren(child_, node, nodeName_, True)
# end class OrientableCurveType


class CurveType(AbstractCurveType):
    subclass = None
    superclass = AbstractCurveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, segments=None):
        super(CurveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.segments = segments
    def factory(*args_, **kwargs_):
        if CurveType.subclass:
            return CurveType.subclass(*args_, **kwargs_)
        else:
            return CurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segments(self): return self.segments
    def set_segments(self, segments): self.segments = segments
    def export(self, outfile, level, namespace_='', name_='CurveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurveType'):
        super(CurveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CurveType')
    def exportChildren(self, outfile, level, namespace_='', name_='CurveType', fromsubclass_=False):
        super(CurveType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.segments is not None:
            self.segments.export(outfile, level, namespace_, name_='segments', )
    def hasContent_(self):
        if (
            self.segments is not None or
            super(CurveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CurveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CurveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CurveType, self).exportLiteralChildren(outfile, level, name_)
        if self.segments is not None:
            showIndent(outfile, level)
            outfile.write('segments=model_.segments(\n')
            self.segments.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CurveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segments':
            obj_ = CurveSegmentArrayPropertyType.factory()
            obj_.build(child_)
            self.set_segments(obj_)
        super(CurveType, self).buildChildren(child_, node, nodeName_, True)
# end class CurveType


class CompositeCurveType(AbstractCurveType):
    subclass = None
    superclass = AbstractCurveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, aggregationType=None, curveMember=None):
        super(CompositeCurveType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        self.aggregationType = _cast(None, aggregationType)
        if curveMember is None:
            self.curveMember = []
        else:
            self.curveMember = curveMember
    def factory(*args_, **kwargs_):
        if CompositeCurveType.subclass:
            return CompositeCurveType.subclass(*args_, **kwargs_)
        else:
            return CompositeCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_curveMember(self): return self.curveMember
    def set_curveMember(self, curveMember): self.curveMember = curveMember
    def add_curveMember(self, value): self.curveMember.append(value)
    def insert_curveMember(self, index, value): self.curveMember[index] = value
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='CompositeCurveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeCurveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompositeCurveType'):
        super(CompositeCurveType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CompositeCurveType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CompositeCurveType', fromsubclass_=False):
        super(CompositeCurveType, self).exportChildren(outfile, level, namespace_, name_, True)
        for curveMember_ in self.curveMember:
            curveMember_.export(outfile, level, namespace_, name_='curveMember')
    def hasContent_(self):
        if (
            self.curveMember or
            super(CompositeCurveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CompositeCurveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(CompositeCurveType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CompositeCurveType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('curveMember=[\n')
        level += 1
        for curveMember_ in self.curveMember:
            showIndent(outfile, level)
            outfile.write('model_.curveMember(\n')
            curveMember_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(CompositeCurveType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'curveMember':
            obj_ = CurvePropertyType.factory()
            obj_.build(child_)
            self.curveMember.append(obj_)
        super(CompositeCurveType, self).buildChildren(child_, node, nodeName_, True)
# end class CompositeCurveType


class TopoSolidType(AbstractTopoPrimitiveType):
    """A gml:TopoSolid must indicate whether it is a universal topo-solid
    or not, to ensure a lossless topology representation as defined
    by Kuijpers, et. al. (see OGC 05-102 Topology IPR). The optional
    universal attribute of type boolean is used to indicate this and
    the default is fault. NOTE The universal topo-solid is normally
    not part of any feature, and is used to represent the unbounded
    portion of the data set. Its interior boundary (it has no
    exterior boundary) would normally be considered the exterior
    boundary of the data set."""
    subclass = None
    superclass = AbstractTopoPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, universal='false', isolated=None, directedFace=None, solidProperty=None):
        super(TopoSolidType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        self.universal = _cast(None, universal)
        if isolated is None:
            self.isolated = []
        else:
            self.isolated = isolated
        if directedFace is None:
            self.directedFace = []
        else:
            self.directedFace = directedFace
        self.solidProperty = solidProperty
    def factory(*args_, **kwargs_):
        if TopoSolidType.subclass:
            return TopoSolidType.subclass(*args_, **kwargs_)
        else:
            return TopoSolidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isolated(self): return self.isolated
    def set_isolated(self, isolated): self.isolated = isolated
    def add_isolated(self, value): self.isolated.append(value)
    def insert_isolated(self, index, value): self.isolated[index] = value
    def get_directedFace(self): return self.directedFace
    def set_directedFace(self, directedFace): self.directedFace = directedFace
    def add_directedFace(self, value): self.directedFace.append(value)
    def insert_directedFace(self, index, value): self.directedFace[index] = value
    def get_solidProperty(self): return self.solidProperty
    def set_solidProperty(self, solidProperty): self.solidProperty = solidProperty
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def get_universal(self): return self.universal
    def set_universal(self, universal): self.universal = universal
    def export(self, outfile, level, namespace_='', name_='TopoSolidType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopoSolidType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopoSolidType'):
        super(TopoSolidType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TopoSolidType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.universal is not None and 'universal' not in already_processed:
            already_processed.append('universal')
            outfile.write(' universal=%s' % (quote_attrib(self.universal), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TopoSolidType', fromsubclass_=False):
        super(TopoSolidType, self).exportChildren(outfile, level, namespace_, name_, True)
        for isolated_ in self.isolated:
            isolated_.export(outfile, level, namespace_, name_='isolated')
        for directedFace_ in self.directedFace:
            directedFace_.export(outfile, level, namespace_, name_='directedFace')
        if self.solidProperty is not None:
            self.solidProperty.export(outfile, level, namespace_, name_='solidProperty')
    def hasContent_(self):
        if (
            self.isolated or
            self.directedFace or
            self.solidProperty is not None or
            super(TopoSolidType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopoSolidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        if self.universal is not None and 'universal' not in already_processed:
            already_processed.append('universal')
            showIndent(outfile, level)
            outfile.write('universal = %s,\n' % (self.universal,))
        super(TopoSolidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TopoSolidType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('isolated=[\n')
        level += 1
        for isolated_ in self.isolated:
            showIndent(outfile, level)
            outfile.write('model_.NodeOrEdgePropertyType(\n')
            isolated_.exportLiteral(outfile, level, name_='NodeOrEdgePropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('directedFace=[\n')
        level += 1
        for directedFace_ in self.directedFace:
            showIndent(outfile, level)
            outfile.write('model_.directedFace(\n')
            directedFace_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.solidProperty is not None:
            showIndent(outfile, level)
            outfile.write('solidProperty=model_.solidProperty(\n')
            self.solidProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('universal', node)
        if value is not None and 'universal' not in already_processed:
            already_processed.append('universal')
            self.universal = value
        super(TopoSolidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isolated':
            obj_ = NodeOrEdgePropertyType.factory()
            obj_.build(child_)
            self.isolated.append(obj_)
        elif nodeName_ == 'directedFace':
            obj_ = DirectedFacePropertyType.factory()
            obj_.build(child_)
            self.directedFace.append(obj_)
        elif nodeName_ == 'solidProperty':
            obj_ = SolidPropertyType.factory()
            obj_.build(child_)
            self.set_solidProperty(obj_)
        super(TopoSolidType, self).buildChildren(child_, node, nodeName_, True)
# end class TopoSolidType


class FaceType(AbstractTopoPrimitiveType):
    """If the topological representation exists an unbounded manifold (e.g.
    Euclidean plane), a gml:Face must indicate whether it is a
    universal face or not, to ensure a lossless topology
    representation as defined by Kuijpers, et. al. (see OGC 05-102
    Topology IPR). The optional universal attribute of type boolean
    is used to indicate this. NOTE The universal face is normally
    not part of any feature, and is used to represent the unbounded
    portion of the data set. Its interior boundary (it has no
    exterior boundary) would normally be considered the exterior
    boundary of the map represented by the data set."""
    subclass = None
    superclass = AbstractTopoPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, universal='false', isolated=None, directedEdge=None, directedTopoSolid=None, surfaceProperty=None):
        super(FaceType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        self.universal = _cast(None, universal)
        if isolated is None:
            self.isolated = []
        else:
            self.isolated = isolated
        if directedEdge is None:
            self.directedEdge = []
        else:
            self.directedEdge = directedEdge
        if directedTopoSolid is None:
            self.directedTopoSolid = []
        else:
            self.directedTopoSolid = directedTopoSolid
        self.surfaceProperty = surfaceProperty
    def factory(*args_, **kwargs_):
        if FaceType.subclass:
            return FaceType.subclass(*args_, **kwargs_)
        else:
            return FaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isolated(self): return self.isolated
    def set_isolated(self, isolated): self.isolated = isolated
    def add_isolated(self, value): self.isolated.append(value)
    def insert_isolated(self, index, value): self.isolated[index] = value
    def get_directedEdge(self): return self.directedEdge
    def set_directedEdge(self, directedEdge): self.directedEdge = directedEdge
    def add_directedEdge(self, value): self.directedEdge.append(value)
    def insert_directedEdge(self, index, value): self.directedEdge[index] = value
    def get_directedTopoSolid(self): return self.directedTopoSolid
    def set_directedTopoSolid(self, directedTopoSolid): self.directedTopoSolid = directedTopoSolid
    def add_directedTopoSolid(self, value): self.directedTopoSolid.append(value)
    def insert_directedTopoSolid(self, index, value): self.directedTopoSolid[index] = value
    def get_surfaceProperty(self): return self.surfaceProperty
    def set_surfaceProperty(self, surfaceProperty): self.surfaceProperty = surfaceProperty
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def get_universal(self): return self.universal
    def set_universal(self, universal): self.universal = universal
    def export(self, outfile, level, namespace_='', name_='FaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FaceType'):
        super(FaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FaceType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
        if self.universal is not None and 'universal' not in already_processed:
            already_processed.append('universal')
            outfile.write(' universal=%s' % (quote_attrib(self.universal), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FaceType', fromsubclass_=False):
        super(FaceType, self).exportChildren(outfile, level, namespace_, name_, True)
        for isolated_ in self.isolated:
            isolated_.export(outfile, level, namespace_, name_='isolated')
        for directedEdge_ in self.directedEdge:
            directedEdge_.export(outfile, level, namespace_, name_='directedEdge')
        for directedTopoSolid_ in self.directedTopoSolid:
            directedTopoSolid_.export(outfile, level, namespace_, name_='directedTopoSolid')
        if self.surfaceProperty is not None:
            self.surfaceProperty.export(outfile, level, namespace_, name_='surfaceProperty')
    def hasContent_(self):
        if (
            self.isolated or
            self.directedEdge or
            self.directedTopoSolid or
            self.surfaceProperty is not None or
            super(FaceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        if self.universal is not None and 'universal' not in already_processed:
            already_processed.append('universal')
            showIndent(outfile, level)
            outfile.write('universal = %s,\n' % (self.universal,))
        super(FaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FaceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('isolated=[\n')
        level += 1
        for isolated_ in self.isolated:
            showIndent(outfile, level)
            outfile.write('model_.NodePropertyType(\n')
            isolated_.exportLiteral(outfile, level, name_='NodePropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('directedEdge=[\n')
        level += 1
        for directedEdge_ in self.directedEdge:
            showIndent(outfile, level)
            outfile.write('model_.directedEdge(\n')
            directedEdge_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('directedTopoSolid=[\n')
        level += 1
        for directedTopoSolid_ in self.directedTopoSolid:
            showIndent(outfile, level)
            outfile.write('model_.directedTopoSolid(\n')
            directedTopoSolid_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.surfaceProperty is not None:
            showIndent(outfile, level)
            outfile.write('surfaceProperty=model_.surfaceProperty(\n')
            self.surfaceProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        value = find_attr_value_('universal', node)
        if value is not None and 'universal' not in already_processed:
            already_processed.append('universal')
            self.universal = value
        super(FaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isolated':
            obj_ = NodePropertyType.factory()
            obj_.build(child_)
            self.isolated.append(obj_)
        elif nodeName_ == 'directedEdge':
            obj_ = DirectedEdgePropertyType.factory()
            obj_.build(child_)
            self.directedEdge.append(obj_)
        elif nodeName_ == 'directedTopoSolid':
            obj_ = DirectedTopoSolidPropertyType.factory()
            obj_.build(child_)
            self.directedTopoSolid.append(obj_)
        elif nodeName_ == 'surfaceProperty':
            obj_ = SurfacePropertyType.factory()
            obj_.build(child_)
            self.set_surfaceProperty(obj_)
        super(FaceType, self).buildChildren(child_, node, nodeName_, True)
# end class FaceType


class EdgeType(AbstractTopoPrimitiveType):
    subclass = None
    superclass = AbstractTopoPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, container=None, directedNode=None, directedFace=None, curveProperty=None):
        super(EdgeType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        self.container = container
        if directedNode is None:
            self.directedNode = []
        else:
            self.directedNode = directedNode
        if directedFace is None:
            self.directedFace = []
        else:
            self.directedFace = directedFace
        self.curveProperty = curveProperty
    def factory(*args_, **kwargs_):
        if EdgeType.subclass:
            return EdgeType.subclass(*args_, **kwargs_)
        else:
            return EdgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_container(self): return self.container
    def set_container(self, container): self.container = container
    def get_directedNode(self): return self.directedNode
    def set_directedNode(self, directedNode): self.directedNode = directedNode
    def add_directedNode(self, value): self.directedNode.append(value)
    def insert_directedNode(self, index, value): self.directedNode[index] = value
    def get_directedFace(self): return self.directedFace
    def set_directedFace(self, directedFace): self.directedFace = directedFace
    def add_directedFace(self, value): self.directedFace.append(value)
    def insert_directedFace(self, index, value): self.directedFace[index] = value
    def get_curveProperty(self): return self.curveProperty
    def set_curveProperty(self, curveProperty): self.curveProperty = curveProperty
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='EdgeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EdgeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EdgeType'):
        super(EdgeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EdgeType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EdgeType', fromsubclass_=False):
        super(EdgeType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.container is not None:
            self.container.export(outfile, level, namespace_, name_='container')
        for directedNode_ in self.directedNode:
            directedNode_.export(outfile, level, namespace_, name_='directedNode')
        for directedFace_ in self.directedFace:
            directedFace_.export(outfile, level, namespace_, name_='directedFace')
        if self.curveProperty is not None:
            self.curveProperty.export(outfile, level, namespace_, name_='curveProperty')
    def hasContent_(self):
        if (
            self.container is not None or
            self.directedNode or
            self.directedFace or
            self.curveProperty is not None or
            super(EdgeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EdgeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(EdgeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EdgeType, self).exportLiteralChildren(outfile, level, name_)
        if self.container is not None:
            showIndent(outfile, level)
            outfile.write('container=model_.TopoSolidPropertyType(\n')
            self.container.exportLiteral(outfile, level, name_='container')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('directedNode=[\n')
        level += 1
        for directedNode_ in self.directedNode:
            showIndent(outfile, level)
            outfile.write('model_.directedNode(\n')
            directedNode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('directedFace=[\n')
        level += 1
        for directedFace_ in self.directedFace:
            showIndent(outfile, level)
            outfile.write('model_.directedFace(\n')
            directedFace_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.curveProperty is not None:
            showIndent(outfile, level)
            outfile.write('curveProperty=model_.curveProperty(\n')
            self.curveProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(EdgeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'container':
            obj_ = TopoSolidPropertyType.factory()
            obj_.build(child_)
            self.set_container(obj_)
        elif nodeName_ == 'directedNode':
            obj_ = DirectedNodePropertyType.factory()
            obj_.build(child_)
            self.directedNode.append(obj_)
        elif nodeName_ == 'directedFace':
            obj_ = DirectedFacePropertyType.factory()
            obj_.build(child_)
            self.directedFace.append(obj_)
        elif nodeName_ == 'curveProperty':
            obj_ = CurvePropertyType.factory()
            obj_.build(child_)
            self.set_curveProperty(obj_)
        super(EdgeType, self).buildChildren(child_, node, nodeName_, True)
# end class EdgeType


class NodeType(AbstractTopoPrimitiveType):
    subclass = None
    superclass = AbstractTopoPrimitiveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, aggregationType=None, container=None, directedEdge=None, pointProperty=None):
        super(NodeType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, )
        self.aggregationType = _cast(None, aggregationType)
        self.container = container
        if directedEdge is None:
            self.directedEdge = []
        else:
            self.directedEdge = directedEdge
        self.pointProperty = pointProperty
    def factory(*args_, **kwargs_):
        if NodeType.subclass:
            return NodeType.subclass(*args_, **kwargs_)
        else:
            return NodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_container(self): return self.container
    def set_container(self, container): self.container = container
    def get_directedEdge(self): return self.directedEdge
    def set_directedEdge(self, directedEdge): self.directedEdge = directedEdge
    def add_directedEdge(self, value): self.directedEdge.append(value)
    def insert_directedEdge(self, index, value): self.directedEdge[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def get_aggregationType(self): return self.aggregationType
    def set_aggregationType(self, aggregationType): self.aggregationType = aggregationType
    def export(self, outfile, level, namespace_='', name_='NodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NodeType'):
        super(NodeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NodeType')
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            outfile.write(' aggregationType=%s' % (quote_attrib(self.aggregationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NodeType', fromsubclass_=False):
        super(NodeType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.container is not None:
            self.container.export(outfile, level, namespace_, name_='container')
        for directedEdge_ in self.directedEdge:
            directedEdge_.export(outfile, level, namespace_, name_='directedEdge')
        if self.pointProperty is not None:
            self.pointProperty.export(outfile, level, namespace_, name_='pointProperty')
    def hasContent_(self):
        if (
            self.container is not None or
            self.directedEdge or
            self.pointProperty is not None or
            super(NodeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aggregationType is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            showIndent(outfile, level)
            outfile.write('aggregationType = %s,\n' % (self.aggregationType,))
        super(NodeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NodeType, self).exportLiteralChildren(outfile, level, name_)
        if self.container is not None:
            showIndent(outfile, level)
            outfile.write('container=model_.FaceOrTopoSolidPropertyType(\n')
            self.container.exportLiteral(outfile, level, name_='container')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('directedEdge=[\n')
        level += 1
        for directedEdge_ in self.directedEdge:
            showIndent(outfile, level)
            outfile.write('model_.directedEdge(\n')
            directedEdge_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.pointProperty is not None:
            showIndent(outfile, level)
            outfile.write('pointProperty=model_.pointProperty(\n')
            self.pointProperty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationType', node)
        if value is not None and 'aggregationType' not in already_processed:
            already_processed.append('aggregationType')
            self.aggregationType = value
        super(NodeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'container':
            obj_ = FaceOrTopoSolidPropertyType.factory()
            obj_.build(child_)
            self.set_container(obj_)
        elif nodeName_ == 'directedEdge':
            obj_ = DirectedEdgePropertyType.factory()
            obj_.build(child_)
            self.directedEdge.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.set_pointProperty(obj_)
        super(NodeType, self).buildChildren(child_, node, nodeName_, True)
# end class NodeType


class LineStringType(AbstractCurveType):
    subclass = None
    superclass = AbstractCurveType
    def __init__(self, id=None, metaDataProperty=None, description=None, descriptionReference=None, identifier=None, name=None, srsName=None, srsDimension=None, pos=None, pointProperty=None, pointRep=None, posList=None, coordinates=None):
        super(LineStringType, self).__init__(id, metaDataProperty, description, descriptionReference, identifier, name, srsName, srsDimension, )
        if pos is None:
            self.pos = []
        else:
            self.pos = pos
        if pointProperty is None:
            self.pointProperty = []
        else:
            self.pointProperty = pointProperty
        if pointRep is None:
            self.pointRep = []
        else:
            self.pointRep = pointRep
        self.posList = posList
        self.coordinates = coordinates
    def factory(*args_, **kwargs_):
        if LineStringType.subclass:
            return LineStringType.subclass(*args_, **kwargs_)
        else:
            return LineStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pos(self): return self.pos
    def set_pos(self, pos): self.pos = pos
    def add_pos(self, value): self.pos.append(value)
    def insert_pos(self, index, value): self.pos[index] = value
    def get_pointProperty(self): return self.pointProperty
    def set_pointProperty(self, pointProperty): self.pointProperty = pointProperty
    def add_pointProperty(self, value): self.pointProperty.append(value)
    def insert_pointProperty(self, index, value): self.pointProperty[index] = value
    def get_pointRep(self): return self.pointRep
    def set_pointRep(self, pointRep): self.pointRep = pointRep
    def add_pointRep(self, value): self.pointRep.append(value)
    def insert_pointRep(self, index, value): self.pointRep[index] = value
    def get_posList(self): return self.posList
    def set_posList(self, posList): self.posList = posList
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def export(self, outfile, level, namespace_='', name_='LineStringType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineStringType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineStringType'):
        super(LineStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LineStringType')
    def exportChildren(self, outfile, level, namespace_='', name_='LineStringType', fromsubclass_=False):
        super(LineStringType, self).exportChildren(outfile, level, namespace_, name_, True)
        for pos_ in self.pos:
            pos_.export(outfile, level, namespace_, name_='pos')
        for pointProperty_ in self.pointProperty:
            pointProperty_.export(outfile, level, namespace_, name_='pointProperty')
        for pointRep_ in self.pointRep:
            pointRep_.export(outfile, level, namespace_, name_='pointRep')
        if self.posList is not None:
            self.posList.export(outfile, level, namespace_, name_='posList', )
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_, name_='coordinates', )
    def hasContent_(self):
        if (
            self.pos or
            self.pointProperty or
            self.pointRep or
            self.posList is not None or
            self.coordinates is not None or
            super(LineStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineStringType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LineStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LineStringType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('pos=[\n')
        level += 1
        for pos_ in self.pos:
            showIndent(outfile, level)
            outfile.write('model_.pos(\n')
            pos_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointProperty=[\n')
        level += 1
        for pointProperty_ in self.pointProperty:
            showIndent(outfile, level)
            outfile.write('model_.pointProperty(\n')
            pointProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pointRep=[\n')
        level += 1
        for pointRep_ in self.pointRep:
            showIndent(outfile, level)
            outfile.write('model_.pointRep(\n')
            pointRep_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.posList is not None:
            showIndent(outfile, level)
            outfile.write('posList=model_.posList(\n')
            self.posList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coordinates is not None:
            showIndent(outfile, level)
            outfile.write('coordinates=model_.coordinates(\n')
            self.coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LineStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pos':
            class_obj_ = self.get_class_obj_(child_, DirectPositionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pos.append(obj_)
        elif nodeName_ == 'pointProperty':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointProperty.append(obj_)
        elif nodeName_ == 'pointRep':
            obj_ = PointPropertyType.factory()
            obj_.build(child_)
            self.pointRep.append(obj_)
        elif nodeName_ == 'posList':
            obj_ = DirectPositionListType.factory()
            obj_.build(child_)
            self.set_posList(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = CoordinatesType.factory()
            obj_.build(child_)
            self.set_coordinates(obj_)
        super(LineStringType, self).buildChildren(child_, node, nodeName_, True)
# end class LineStringType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'StopsRequest'
        rootClass = AbstractRequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'StopsRequest'
        rootClass = AbstractRequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="StopsRequest",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'StopsRequest'
        rootClass = AbstractRequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from mis_collect_stops import *\n\n')
    sys.stdout.write('import mis_collect_stops as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractCRSType",
    "AbstractContinuousCoverageType",
    "AbstractCoordinateOperationType",
    "AbstractCoordinateSystemType",
    "AbstractCoverageType",
    "AbstractCurveSegmentType",
    "AbstractCurveType",
    "AbstractDQ_Completeness_Type",
    "AbstractDQ_Element_Type",
    "AbstractDQ_LogicalConsistency_Type",
    "AbstractDQ_PositionalAccuracy_Type",
    "AbstractDQ_Result_Type",
    "AbstractDQ_TemporalAccuracy_Type",
    "AbstractDQ_ThematicAccuracy_Type",
    "AbstractDS_Aggregate_Type",
    "AbstractDatumType",
    "AbstractEX_GeographicExtent_Type",
    "AbstractFeatureCollectionType",
    "AbstractFeatureMemberType",
    "AbstractFeatureType",
    "AbstractGMLType",
    "AbstractGeneralConversionType",
    "AbstractGeneralDerivedCRSType",
    "AbstractGeneralOperationParameterPropertyType",
    "AbstractGeneralOperationParameterType",
    "AbstractGeneralParameterValuePropertyType",
    "AbstractGeneralParameterValueType",
    "AbstractGeneralTransformationType",
    "AbstractGeometricAggregateType",
    "AbstractGeometricPrimitiveType",
    "AbstractGeometryType",
    "AbstractGriddedSurfaceType",
    "AbstractMD_ContentInformation_Type",
    "AbstractMD_Identification_Type",
    "AbstractMD_SpatialRepresentation_Type",
    "AbstractMemberType",
    "AbstractMetaDataType",
    "AbstractMetadataPropertyType",
    "AbstractObject",
    "AbstractObject_Type",
    "AbstractParametricCurveSurfaceType",
    "AbstractRS_ReferenceSystem_Type",
    "AbstractRequestType",
    "AbstractResponseType",
    "AbstractRingPropertyType",
    "AbstractRingType",
    "AbstractSolidType",
    "AbstractSurfacePatchType",
    "AbstractSurfaceType",
    "AbstractTimeComplexType",
    "AbstractTimeGeometricPrimitiveType",
    "AbstractTimeObjectType",
    "AbstractTimePrimitiveType",
    "AbstractTimeSliceType",
    "AbstractTimeTopologyPrimitiveType",
    "AbstractTopoPrimitiveType",
    "AbstractTopologyType",
    "AffineCSPropertyType",
    "AffineCSType",
    "AffinePlacementType",
    "AngleChoiceType",
    "AngleType",
    "Angle_PropertyType",
    "ArcByBulgeType",
    "ArcByCenterPointType",
    "ArcStringByBulgeType",
    "ArcStringType",
    "ArcType",
    "AreaType",
    "ArrayAssociationType",
    "ArrayType",
    "AssociationRoleType",
    "BSplineType",
    "BagType",
    "BaseUnitType",
    "BezierType",
    "Binary_PropertyType",
    "Binary_Type",
    "Boolean",
    "BooleanPropertyType",
    "Boolean_PropertyType",
    "BoundedFeatureType",
    "BoundingShapeType",
    "CI_Address_PropertyType",
    "CI_Address_Type",
    "CI_Citation_PropertyType",
    "CI_Citation_Type",
    "CI_Contact_PropertyType",
    "CI_Contact_Type",
    "CI_DateTypeCode_PropertyType",
    "CI_Date_PropertyType",
    "CI_Date_Type",
    "CI_OnLineFunctionCode_PropertyType",
    "CI_OnlineResource_PropertyType",
    "CI_OnlineResource_Type",
    "CI_PresentationFormCode_PropertyType",
    "CI_ResponsibleParty_PropertyType",
    "CI_ResponsibleParty_Type",
    "CI_RoleCode_PropertyType",
    "CI_Series_PropertyType",
    "CI_Series_Type",
    "CI_Telephone_PropertyType",
    "CI_Telephone_Type",
    "CRSPropertyType",
    "CartesianCSPropertyType",
    "CartesianCSType",
    "Category",
    "CategoryExtentType",
    "CategoryPropertyType",
    "CentroidType",
    "CharacterString_PropertyType",
    "CircleByCenterPointType",
    "CircleType",
    "ClothoidType",
    "CodeListType",
    "CodeListValue_Type",
    "CodeOrNilReasonListType",
    "CodeType",
    "CodeWithAuthorityType",
    "CompositeCurveType",
    "CompositeFrameType",
    "CompositeSolidType",
    "CompositeSurfaceType",
    "CompositeValueType",
    "CompoundCRSPropertyType",
    "CompoundCRSType",
    "ConcatenatedOperationPropertyType",
    "ConcatenatedOperationType",
    "ConeType",
    "ConventionalUnitType",
    "ConversionPropertyType",
    "ConversionToPreferredUnitType",
    "ConversionType",
    "CoordinateOperationPropertyType",
    "CoordinateSystemAxisPropertyType",
    "CoordinateSystemAxisType",
    "CoordinateSystemPropertyType",
    "CoordinatesType",
    "Count",
    "CountPropertyType",
    "CountryRefType",
    "Country_PropertyType",
    "CoverageFunctionType",
    "CubicSplineType",
    "CurveArrayPropertyType",
    "CurvePropertyType",
    "CurveSegmentArrayPropertyType",
    "CurveType",
    "CylinderType",
    "CylindricalCSPropertyType",
    "CylindricalCSType",
    "DMSAngleType",
    "DQ_AbsoluteExternalPositionalAccuracy_PropertyType",
    "DQ_AbsoluteExternalPositionalAccuracy_Type",
    "DQ_AccuracyOfATimeMeasurement_PropertyType",
    "DQ_AccuracyOfATimeMeasurement_Type",
    "DQ_CompletenessCommission_PropertyType",
    "DQ_CompletenessCommission_Type",
    "DQ_CompletenessOmission_PropertyType",
    "DQ_CompletenessOmission_Type",
    "DQ_Completeness_PropertyType",
    "DQ_ConceptualConsistency_PropertyType",
    "DQ_ConceptualConsistency_Type",
    "DQ_ConformanceResult_PropertyType",
    "DQ_ConformanceResult_Type",
    "DQ_DataQuality_PropertyType",
    "DQ_DataQuality_Type",
    "DQ_DomainConsistency_PropertyType",
    "DQ_DomainConsistency_Type",
    "DQ_Element_PropertyType",
    "DQ_EvaluationMethodTypeCode_PropertyType",
    "DQ_FormatConsistency_PropertyType",
    "DQ_FormatConsistency_Type",
    "DQ_GriddedDataPositionalAccuracy_PropertyType",
    "DQ_GriddedDataPositionalAccuracy_Type",
    "DQ_LogicalConsistency_PropertyType",
    "DQ_NonQuantitativeAttributeAccuracy_PropertyType",
    "DQ_NonQuantitativeAttributeAccuracy_Type",
    "DQ_PositionalAccuracy_PropertyType",
    "DQ_QuantitativeAttributeAccuracy_PropertyType",
    "DQ_QuantitativeAttributeAccuracy_Type",
    "DQ_QuantitativeResult_PropertyType",
    "DQ_QuantitativeResult_Type",
    "DQ_RelativeInternalPositionalAccuracy_PropertyType",
    "DQ_RelativeInternalPositionalAccuracy_Type",
    "DQ_Result_PropertyType",
    "DQ_Scope_PropertyType",
    "DQ_Scope_Type",
    "DQ_TemporalAccuracy_PropertyType",
    "DQ_TemporalConsistency_PropertyType",
    "DQ_TemporalConsistency_Type",
    "DQ_TemporalValidity_PropertyType",
    "DQ_TemporalValidity_Type",
    "DQ_ThematicAccuracy_PropertyType",
    "DQ_ThematicClassificationCorrectness_PropertyType",
    "DQ_ThematicClassificationCorrectness_Type",
    "DQ_TopologicalConsistency_PropertyType",
    "DQ_TopologicalConsistency_Type",
    "DS_Aggregate_PropertyType",
    "DS_AssociationTypeCode_PropertyType",
    "DS_Association_PropertyType",
    "DS_Association_Type",
    "DS_DataSet_PropertyType",
    "DS_DataSet_Type",
    "DS_InitiativeTypeCode_PropertyType",
    "DS_Initiative_PropertyType",
    "DS_Initiative_Type",
    "DS_OtherAggregate_PropertyType",
    "DS_OtherAggregate_Type",
    "DS_Platform_PropertyType",
    "DS_Platform_Type",
    "DS_ProductionSeries_PropertyType",
    "DS_ProductionSeries_Type",
    "DS_Sensor_PropertyType",
    "DS_Sensor_Type",
    "DS_Series_PropertyType",
    "DS_Series_Type",
    "DS_StereoMate_PropertyType",
    "DS_StereoMate_Type",
    "DataBlockType",
    "DateTime_PropertyType",
    "Date_PropertyType",
    "DatumPropertyType",
    "Decimal_PropertyType",
    "DefaultLocaleType",
    "DefinitionBaseType",
    "DefinitionProxyType",
    "DefinitionType",
    "DegreesType",
    "DerivationUnitTermType",
    "DerivedCRSPropertyType",
    "DerivedCRSType",
    "DerivedUnitType",
    "DictionaryEntryType",
    "DictionaryType",
    "DirectPositionListType",
    "DirectPositionType",
    "DirectedEdgePropertyType",
    "DirectedFacePropertyType",
    "DirectedNodePropertyType",
    "DirectedObservationAtDistanceType",
    "DirectedObservationType",
    "DirectedTopoSolidPropertyType",
    "DirectionDescriptionType",
    "DirectionPropertyType",
    "DirectionVectorType",
    "DiscreteCoverageType",
    "Distance_PropertyType",
    "DomainSetType",
    "DynamicFeatureCollectionType",
    "DynamicFeatureMemberType",
    "DynamicFeatureType",
    "EX_BoundingPolygon_PropertyType",
    "EX_BoundingPolygon_Type",
    "EX_Extent_PropertyType",
    "EX_Extent_Type",
    "EX_GeographicBoundingBox_PropertyType",
    "EX_GeographicBoundingBox_Type",
    "EX_GeographicDescription_PropertyType",
    "EX_GeographicDescription_Type",
    "EX_GeographicExtent_PropertyType",
    "EX_SpatialTemporalExtent_PropertyType",
    "EX_SpatialTemporalExtent_Type",
    "EX_TemporalExtent_PropertyType",
    "EX_TemporalExtent_Type",
    "EX_VerticalExtent_PropertyType",
    "EX_VerticalExtent_Type",
    "EdgeType",
    "EllipsoidPropertyType",
    "EllipsoidType",
    "EllipsoidalCSPropertyType",
    "EllipsoidalCSType",
    "EngineeringCRSPropertyType",
    "EngineeringCRSType",
    "EngineeringDatumPropertyType",
    "EngineeringDatumType",
    "EnvelopeType",
    "EnvelopeWithTimePeriodType",
    "FaceOrTopoSolidPropertyType",
    "FaceType",
    "FeatureArrayPropertyType",
    "FeatureCollectionType",
    "FeaturePropertyType",
    "FileType",
    "FormulaType",
    "GM_Object_PropertyType",
    "GM_Point_PropertyType",
    "GeneralConversionPropertyType",
    "GeneralTransformationPropertyType",
    "GenericMetaDataType",
    "GenericName_PropertyType",
    "GeocentricCRSPropertyType",
    "GeocentricCRSType",
    "GeodesicStringType",
    "GeodesicType",
    "GeodeticCRSPropertyType",
    "GeodeticCRSType",
    "GeodeticDatumPropertyType",
    "GeodeticDatumType",
    "GeographicCRSPropertyType",
    "GeographicCRSType",
    "GeographicOverviewFormatType",
    "GeometricComplexPropertyType",
    "GeometricComplexType",
    "GeometricPrimitivePropertyType",
    "GeometryArrayPropertyType",
    "GeometryPropertyType",
    "GridEnvelopeType",
    "GridFunctionType",
    "GridLengthType",
    "GridLimitsType",
    "GridType",
    "HistoryPropertyType",
    "IdentifiedObjectType",
    "ImageCRSPropertyType",
    "ImageCRSType",
    "ImageDatumPropertyType",
    "ImageDatumType",
    "IndirectEntryType",
    "InlinePropertyType",
    "Integer_PropertyType",
    "KnotPropertyType",
    "KnotType",
    "LI_Lineage_PropertyType",
    "LI_Lineage_Type",
    "LI_ProcessStep_PropertyType",
    "LI_ProcessStep_Type",
    "LI_Source_PropertyType",
    "LI_Source_Type",
    "LanguageCode_PropertyType",
    "Latitude",
    "LengthType",
    "Length_PropertyType",
    "LineStringSegmentArrayPropertyType",
    "LineStringSegmentType",
    "LineStringType",
    "LinearCSPropertyType",
    "LinearCSType",
    "LinearRingPropertyType",
    "LinearRingType",
    "LocalName_PropertyType",
    "LocalisedCharacterString_PropertyType",
    "LocalisedCharacterString_Type",
    "LocationPropertyType",
    "LocationStructure",
    "Longitude",
    "MD_AggregateInformation_PropertyType",
    "MD_AggregateInformation_Type",
    "MD_ApplicationSchemaInformation_PropertyType",
    "MD_ApplicationSchemaInformation_Type",
    "MD_Band_PropertyType",
    "MD_Band_Type",
    "MD_BrowseGraphic_PropertyType",
    "MD_BrowseGraphic_Type",
    "MD_CellGeometryCode_PropertyType",
    "MD_CharacterSetCode_PropertyType",
    "MD_ClassificationCode_PropertyType",
    "MD_Constraints_PropertyType",
    "MD_Constraints_Type",
    "MD_ContentInformation_PropertyType",
    "MD_CoverageContentTypeCode_PropertyType",
    "MD_CoverageDescription_PropertyType",
    "MD_CoverageDescription_Type",
    "MD_DataIdentification_PropertyType",
    "MD_DataIdentification_Type",
    "MD_DatatypeCode_PropertyType",
    "MD_DigitalTransferOptions_PropertyType",
    "MD_DigitalTransferOptions_Type",
    "MD_DimensionNameTypeCode_PropertyType",
    "MD_Dimension_PropertyType",
    "MD_Dimension_Type",
    "MD_DistributionUnits_PropertyType",
    "MD_Distribution_PropertyType",
    "MD_Distribution_Type",
    "MD_Distributor_PropertyType",
    "MD_Distributor_Type",
    "MD_ExtendedElementInformation_PropertyType",
    "MD_ExtendedElementInformation_Type",
    "MD_FeatureCatalogueDescription_PropertyType",
    "MD_FeatureCatalogueDescription_Type",
    "MD_Format_PropertyType",
    "MD_Format_Type",
    "MD_GeometricObjectTypeCode_PropertyType",
    "MD_GeometricObjects_PropertyType",
    "MD_GeometricObjects_Type",
    "MD_Georectified_PropertyType",
    "MD_Georectified_Type",
    "MD_Georeferenceable_PropertyType",
    "MD_Georeferenceable_Type",
    "MD_GridSpatialRepresentation_PropertyType",
    "MD_GridSpatialRepresentation_Type",
    "MD_Identification_PropertyType",
    "MD_Identifier_PropertyType",
    "MD_Identifier_Type",
    "MD_ImageDescription_PropertyType",
    "MD_ImageDescription_Type",
    "MD_ImagingConditionCode_PropertyType",
    "MD_KeywordTypeCode_PropertyType",
    "MD_Keywords_PropertyType",
    "MD_Keywords_Type",
    "MD_LegalConstraints_PropertyType",
    "MD_LegalConstraints_Type",
    "MD_MaintenanceFrequencyCode_PropertyType",
    "MD_MaintenanceInformation_PropertyType",
    "MD_MaintenanceInformation_Type",
    "MD_MediumFormatCode_PropertyType",
    "MD_MediumNameCode_PropertyType",
    "MD_Medium_PropertyType",
    "MD_Medium_Type",
    "MD_MetadataExtensionInformation_PropertyType",
    "MD_MetadataExtensionInformation_Type",
    "MD_Metadata_PropertyType",
    "MD_Metadata_Type",
    "MD_ObligationCode_PropertyType",
    "MD_PixelOrientationCode_PropertyType",
    "MD_PortrayalCatalogueReference_PropertyType",
    "MD_PortrayalCatalogueReference_Type",
    "MD_ProgressCode_PropertyType",
    "MD_RangeDimension_PropertyType",
    "MD_RangeDimension_Type",
    "MD_ReferenceSystem_PropertyType",
    "MD_ReferenceSystem_Type",
    "MD_RepresentativeFraction_PropertyType",
    "MD_RepresentativeFraction_Type",
    "MD_Resolution_PropertyType",
    "MD_Resolution_Type",
    "MD_RestrictionCode_PropertyType",
    "MD_ScopeCode_PropertyType",
    "MD_ScopeDescription_PropertyType",
    "MD_ScopeDescription_Type",
    "MD_SecurityConstraints_PropertyType",
    "MD_SecurityConstraints_Type",
    "MD_ServiceIdentification_PropertyType",
    "MD_ServiceIdentification_Type",
    "MD_SpatialRepresentationTypeCode_PropertyType",
    "MD_SpatialRepresentation_PropertyType",
    "MD_StandardOrderProcess_PropertyType",
    "MD_StandardOrderProcess_Type",
    "MD_TopicCategoryCode_PropertyType",
    "MD_TopologyLevelCode_PropertyType",
    "MD_Usage_PropertyType",
    "MD_Usage_Type",
    "MD_VectorSpatialRepresentation_PropertyType",
    "MD_VectorSpatialRepresentation_Type",
    "MappingRuleType",
    "MeasureListType",
    "MeasureOrNilReasonListType",
    "MeasureType",
    "Measure_PropertyType",
    "MemberName_PropertyType",
    "MemberName_Type",
    "MetaDataPropertyType",
    "MovingObjectStatusType",
    "MultiCurvePropertyType",
    "MultiCurveType",
    "MultiGeometryPropertyType",
    "MultiGeometryType",
    "MultiPointPropertyType",
    "MultiPointType",
    "MultiSolidPropertyType",
    "MultiSolidType",
    "MultiSurfacePropertyType",
    "MultiSurfaceType",
    "MultiplicityRange_PropertyType",
    "MultiplicityRange_Type",
    "Multiplicity_PropertyType",
    "Multiplicity_Type",
    "NodeOrEdgePropertyType",
    "NodePropertyType",
    "NodeType",
    "Number_PropertyType",
    "ObjectReference_PropertyType",
    "ObliqueCartesianCSPropertyType",
    "ObliqueCartesianCSType",
    "ObservationType",
    "OffsetCurveType",
    "OperationMethodPropertyType",
    "OperationMethodType",
    "OperationParameterGroupPropertyType",
    "OperationParameterGroupType",
    "OperationParameterPropertyType",
    "OperationParameterType",
    "OperationPropertyType",
    "OrientableCurveType",
    "OrientableSurfaceType",
    "PT_FreeText_PropertyType",
    "PT_FreeText_Type",
    "PT_LocaleContainer_PropertyType",
    "PT_LocaleContainer_Type",
    "PT_Locale_PropertyType",
    "PT_Locale_Type",
    "ParameterValueGroupType",
    "ParameterValueType",
    "PassThroughOperationPropertyType",
    "PassThroughOperationType",
    "PointArrayPropertyType",
    "PointPropertyType",
    "PointType",
    "PolarCSPropertyType",
    "PolarCSType",
    "PolygonPatchType",
    "PolygonType",
    "PostalAddressType",
    "PrimeMeridianPropertyType",
    "PrimeMeridianType",
    "PriorityLocationPropertyType",
    "ProcedurePropertyType",
    "ProjectedCRSPropertyType",
    "ProjectedCRSType",
    "PublicationDeliveryType",
    "Quantity",
    "QuantityExtentType",
    "QuantityPropertyType",
    "QuayType",
    "RS_Identifier_PropertyType",
    "RS_Identifier_Type",
    "RS_ReferenceSystem_PropertyType",
    "RangeSetType",
    "Real_PropertyType",
    "Record",
    "RecordType_PropertyType",
    "RecordType_Type",
    "Record_PropertyType",
    "RectangleType",
    "RectifiedGridType",
    "ReferenceType",
    "RelatedTimeType",
    "ResultType",
    "RingPropertyType",
    "RingType",
    "RowType",
    "RowType1",
    "SC_CRS_PropertyType",
    "ScaleType",
    "Scale_PropertyType",
    "ScopedName_PropertyType",
    "SecondDefiningParameter",
    "SequenceRuleType",
    "ServiceDefaultsType",
    "ShellPropertyType",
    "ShellType",
    "SimpleValidityConditionType",
    "SingleCRSPropertyType",
    "SingleOperationPropertyType",
    "SiteFrameType",
    "SolidArrayPropertyType",
    "SolidPropertyType",
    "SolidType",
    "SpeedType",
    "SphereType",
    "SphericalCSPropertyType",
    "SphericalCSType",
    "StatusType",
    "StopPlaceType",
    "StopsResponseType",
    "StringOrRefType",
    "SurfaceArrayPropertyType",
    "SurfacePatchArrayPropertyType",
    "SurfacePropertyType",
    "SurfaceType",
    "TM_PeriodDuration_PropertyType",
    "TM_Primitive_PropertyType",
    "TargetPropertyType",
    "TemporalCRSPropertyType",
    "TemporalCRSType",
    "TemporalCSPropertyType",
    "TemporalCSType",
    "TemporalDatumBaseType",
    "TemporalDatumPropertyType",
    "TemporalDatumType",
    "TimeCSPropertyType",
    "TimeCSType",
    "TimeCalendarEraPropertyType",
    "TimeCalendarEraType",
    "TimeCalendarPropertyType",
    "TimeCalendarType",
    "TimeClockPropertyType",
    "TimeClockType",
    "TimeCoordinateSystemType",
    "TimeEdgePropertyType",
    "TimeEdgeType",
    "TimeInstantPropertyType",
    "TimeInstantType",
    "TimeIntervalLengthType",
    "TimeNodePropertyType",
    "TimeNodeType",
    "TimeOrdinalEraPropertyType",
    "TimeOrdinalEraType",
    "TimeOrdinalReferenceSystemType",
    "TimePeriodPropertyType",
    "TimePeriodType",
    "TimePositionType",
    "TimePrimitivePropertyType",
    "TimeReferenceSystemType",
    "TimeTopologyComplexPropertyType",
    "TimeTopologyComplexType",
    "TimeTopologyPrimitivePropertyType",
    "TimeType",
    "TinType",
    "TopoComplexPropertyType",
    "TopoComplexType",
    "TopoCurvePropertyType",
    "TopoCurveType",
    "TopoPointPropertyType",
    "TopoPointType",
    "TopoPrimitiveArrayAssociationType",
    "TopoPrimitiveMemberType",
    "TopoSolidPropertyType",
    "TopoSolidType",
    "TopoSurfacePropertyType",
    "TopoSurfaceType",
    "TopoVolumePropertyType",
    "TopoVolumeType",
    "TransformationPropertyType",
    "TransformationType",
    "TriangleType",
    "TypeName_PropertyType",
    "TypeName_Type",
    "URL_PropertyType",
    "UnitDefinitionType",
    "UnitOfMeasureType",
    "UnitOfMeasure_PropertyType",
    "UnlimitedInteger_PropertyType",
    "UnlimitedInteger_Type",
    "UomAngle_PropertyType",
    "UomArea_PropertyType",
    "UomLength_PropertyType",
    "UomScale_PropertyType",
    "UomTime_PropertyType",
    "UomVelocity_PropertyType",
    "UomVolume_PropertyType",
    "UserDefinedCSPropertyType",
    "UserDefinedCSType",
    "ValueArrayPropertyType",
    "ValueArrayType",
    "ValuePropertyType",
    "VectorType",
    "VerticalCRSPropertyType",
    "VerticalCRSType",
    "VerticalCSPropertyType",
    "VerticalCSType",
    "VerticalDatumPropertyType",
    "VerticalDatumType",
    "VolumeType",
    "arcType",
    "controlPointType",
    "coordinateOperationAccuracy",
    "dataObjectsType",
    "domainOfValidity",
    "extended",
    "formulaCitation",
    "frameValidityConditionsType",
    "framesType",
    "geographicOverviewFormatsType",
    "locatorType",
    "placeTypesType",
    "quaysType",
    "refLocationType",
    "resourceType",
    "rowsType",
    "rowsType1",
    "secondDefiningParameter",
    "simple",
    "stopPlacesType",
    "titleEltType"
    ]
